<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0058)http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-435 -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" slick-uniqueid="3"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Ruby/SDL Reference Manual</title>
<style type="text/css"></style></head>
<body>
<h1><a name="label-0" id="label-0">Contents</a></h1><!-- RDLabel: "Contents" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-1">Ruby/SDL Outline</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-5">Initialize</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-18">Video</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-277">OpenGL</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-289">Window Management</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-299">Event</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-408">Joystick</a></li>
<li><a href="./Ruby SDL Reference Manual_files/Ruby SDL Reference Manual.html">CD-ROM</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-468">Audio</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-546">Time</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-551">Font</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-616">Collision Detection</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-631">SDLSKK</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-657">MPEG playback</a></li>
</ul>
<h1><a name="label-1" id="label-1">Ruby/SDL Outline</a></h1><!-- RDLabel: "Ruby/SDL Outline" -->
<p>Ruby/SDL is Ruby extension library for
<a href="http://www.libsdl.org/">SDL</a>.
This library enables you to create games, demo, or so on.</p>
<p>Ruby/SDL has following functions.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-18">access to 2D video framebuffer</a></li>
<li>Access <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-299">Keyboard and mouse</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-408">Joystick</a> input</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-468">Audio Playback</a> with <a href="http://www.libsdl.org/projects/SDL_mixer/index.html">SDL_mixer</a></li>
<li><a href="./Ruby SDL Reference Manual_files/Ruby SDL Reference Manual.html">Control CD-ROM</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-551">Font drawing </a> with <a href="http://www.libsdl.org/projects/SDL_ttf/index.html">SDL_ttf</a>,
  <a href="http://shinh.skr.jp/sdlkanji/">SDL_kanji</a> and
  <a href="http://www.etek.chalmers.se/~e8cal1/sge/index.html">SGE</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-277">Using OpenGL</a> via <a href="http://www2.giganet.net/~yoshi/">OpenGL Interface</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-546">Dealing with time</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-631">SKK like Japanese input</a> with <a href="http://www.kmc.gr.jp/~ohai/sdlskk.html">SDLSKK</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-657">MPEG playback</a> with <a href="http://www.icculus.org/smpeg/">SMPGE</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-289">Window Management</a> and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-616">Collision Detection</a></li>
</ul>
<h1><a name="label-2" id="label-2">m17n on Ruby 1.9</a></h1><!-- RDLabel: "m17n on Ruby 1.9" -->
<p>On ruby 1.9, strings have encoding information
but many methods of Ruby/SDL ignore this information
since SDL doesn't define the treatment of multibyte 
encodings. 
Only some methods use encoding information such as
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-293">SDL::WM.set_caption</a> and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-613">SDL::Kanji#put</a>.</p>
<p>Please see items in this reference for more details.</p>
<p>You can enable/disable Ruby/SDL m17n support 
to use --enable-m17n/--disable-m17n when you
run extconf.rb.</p>
<h2><a name="label-3" id="label-3">SDL::Error</a></h2><!-- RDLabel: "SDL::Error" -->
<p>A Exception class for SDL specific errors.
This class is subclass of StandardError.</p>
<h2><a name="label-4" id="label-4">SDL::VERSION</a></h2><!-- RDLabel: "SDL::VERSION" -->
<p>Ruby/SDL version string.</p>
<h1><a name="label-5" id="label-5">Initialize</a></h1><!-- RDLabel: "Initialize" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a> -- Initializes SDL</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-13">SDL.quit</a> -- Shut down SDL</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-14">SDL.inited_system</a> -- Check which subsystems are initialized</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-16">SDL.getenv</a> -- Get an environmental variable</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-17">SDL.putenv</a> -- Change or add an  environmental variable</li>
</ul>
<p>Before SDL can be used in a program it must be initialized
with <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a>. <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a> initializes all the subsystems that</p>
<pre>the user requests (video, audio, joystick, timers and/or cdrom).</pre>
<h2><a name="label-6" id="label-6">Methods</a></h2><!-- RDLabel: "Methods" -->
<dl>
<dt><a name="label-7" id="label-7"><code>SDL.init(<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL.init" -->
<dd>
<p>Initializes SDL. This should be called before all other 
Ruby/SDL methods. The <var>flags</var> parameter specifies what</p>
<pre>part(s) of SDL to initialize.</pre>
<dl>
<dt><a name="label-8" id="label-8">SDL::INIT_AUDIO</a></dt><!-- RDLabel: "SDL::INIT_AUDIO" -->
<dd>
Initialize autio subsystems.
</dd>
<dt><a name="label-9" id="label-9">SDL::INIT_VIDEO</a></dt><!-- RDLabel: "SDL::INIT_VIDEO" -->
<dd>
Initialize <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-18">Video</a> subsystem.
</dd>
<dt><a name="label-10" id="label-10">SDL::INIT_CDROM</a></dt><!-- RDLabel: "SDL::INIT_CDROM" -->
<dd>
Initialize <a href="./Ruby SDL Reference Manual_files/Ruby SDL Reference Manual.html">CD-ROM</a> subsystem.
</dd>
<dt><a name="label-11" id="label-11">SDL::INIT_JOYSTICK</a></dt><!-- RDLabel: "SDL::INIT_JOYSTICK" -->
<dd>
Initialize <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-408">Joystick</a> subsystem.
</dd>
<dt><a name="label-12" id="label-12">SDL::INIT_EVERYTHING</a></dt><!-- RDLabel: "SDL::INIT_EVERYTHING" -->
<dd>
Initialize all of the avobe.
</dd>
</dl>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p></dd>
<dt><a name="label-13" id="label-13"><code>SDL.quit</code></a></dt><!-- RDLabel: "SDL.quit" -->
<dd>
<p>This method shots down all SDL subsystem and frees the resources
allocated to them. Because this method is automatically called 
when ruby stops, you don't have to call this function normally.</p>
<p>You should know SDL and Ruby/SDL very well when you use
this method.</p></dd>
<dt><a name="label-14" id="label-14"><code>SDL.inited_system(<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL.inited_system" -->
<dt><a name="label-15" id="label-15"><code>SDL.initedSystem(<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL.initedSystem" -->
<dd>
<p>This method allows you to see which SDL subsytems have</p>
<pre>been ((&lt;initialized|SDL.init&gt;)). ((|flags|)) is a bitwise OR'd </pre>
<p>combination of the subsystems you wish to check 
(see <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a> for a list of subsystem flags).</p>
<p>Returns a bitwised OR'd combination of the initialized subsystems.</p>
<p>EXAMPLE</p>
<pre># Here are several ways you can use SDL.inited_system

# Get init data on all the subsystem
subsystem_init = SDL.inited_system(SDL::INIT_EVERYTHING)

if subsystem_init &amp; SDL::INIT_VIDEO
  puts "video is initialized"
else
  puts "video is not initialized"
end

# Just check for one specfic subsystem

if SDL.inited_system(SDL::INIT_VIDEO) != 0
  puts "Video is initialized"
else
  puts "Video is not initialized        "
end

# Check for two subsystem

subsystem_mask = SDL::INIT_VIDEO|SDL::INIT_AUDIO;

if SDL.inited_system(subsystem_mask) == subsystem_mask
  puts "Video and Audio initialized."
else
  puts "Video and Audio not initialized"
end</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a></p></li>
</ul></dd>
<dt><a name="label-16" id="label-16"><code>SDL.getenv(<var>var</var>)</code></a></dt><!-- RDLabel: "SDL.getenv" -->
<dd>
Returns the environment variable string matched by <var>var</var>.</dd>
<dt><a name="label-17" id="label-17"><code>SDL.putenv(<var>string</var>)</code></a></dt><!-- RDLabel: "SDL.putenv" -->
<dd>
<p>Add or Change the value of environmental variables.
The argument <var>string</var> is of the form "name=value"</p>
<p>If you want to change SDL_WINDOWID or SDL_VIDEODRIVER environmental variable 
to modify the behavior of SDL in your program, you should use 
this function instead of ENV.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>EXAMPLE</p>
<pre># from http://moriq.tdiary.net/20051006.html 
# Apollo with Ruby/SDL
require 'phi'
require 'sdl'

# Create form
form = Phi::Form.new
$terminated = false
form.on_close{ $terminated = true }
form.caption = "Ruby/SDL on Phi::Form"
# Create a panel on new form
panel = Phi::Panel.new(form)
panel.align = Phi::AL_LEFT

# Put SDL window on panel with WINDOWID hack
SDL.putenv("SDL_VIDEODRIVER=windib")
SDL.putenv("SDL_WINDOWID=#{panel.handle}")
form.show

# initialize SDL
SDL.init(SDL::INIT_VIDEO)
screen = SDL.setVideoMode(640, 480, 16, SDL::SWSURFACE)

# main loop
unless $terminated
  while event = SDL::Event2.poll
    case event
    when SDL::Event2::KeyDown, SDL::Event2::Quit
      exit
    end
  end

  sleep 0.05
end</pre></dd>
</dl>
<h1><a name="label-18" id="label-18">Video</a></h1><!-- RDLabel: "Video" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-19">Video Subsystem Outline</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-21">SDL::Screen</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-22">SDL::VideoInfo</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-35">Color, PixelFormat and Pixel value</a></li>
<li>Methods
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-41">SDL::Screen.get</a> -- returns the current display surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-44">SDL::Screen.info</a> -- returns information about the video hardware</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-47">SDL::Screen.driver_name</a> -- Obtain the name of the video driver</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-51">SDL::Screen.list_modes</a> -- Returns an array of available screen dimensions for the given format and video flags</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-55">SDL::Screen.check_mode</a> -- Check to see if a particular video mode is supported.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a> -- Set up a video mode with the specified width, height and bits-per-pixel.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-72">SDL::Screen#update_rect</a> -- Makes sure the given area is updated on the given screen.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-73">SDL::Screen#update_rects</a> -- Makes sure the given list of rectangles is updated on the given screen</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-75">SDL::Screen#flip</a> -- Swaps screen buffers</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-76">SDL::Surface#set_colors</a> -- Sets a portion of the colormap for the given 8-bit surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-78">SDL::Surface#set_palette</a> -- Sets the colors in the palette of an 8-bit surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-82">SDL::Screen.set_gamma</a> -- Sets the color gamma function for the display</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-86">SDL::Screen.get_gamma_ramp</a> -- Gets the color gamma lookup tables for the display</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-90">SDL::Screen.set_gamma_ramp</a> -- Sets the color gamma lookup tables for the display</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-94">SDL::PixelFormat#map_rgb</a> -- RGB Map a RGB color value to a pixel format.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-98">SDL::PixelFormat#map_rgba</a> -- Map a RGBA color value to a pixel format.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-102">SDL::PixelFormat#get_rgb</a> -- Get RGB values from a pixel in the specified pixel format.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-106">SDL::PixelFormat#get_rgba</a> -- Get RGBA values from a pixel in the specified pixel format.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-108">SDL::Surface.new</a> -- Create an empty <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-114">SDL::Surface.new_from</a> -- Create an <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a> object from pixel data</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">SDL::Surface#lock</a> -- Lock a surface for directly access.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-116">SDL::Surface#unlock</a> -- Unlocks a previously locked surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-117">SDL::Surface#must_lock?</a> -- Get whether the surface require locking or not.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-119">SDL::Surface.load_bmp</a> -- Load a Windows BMP file into an SDL_Surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-121">SDL::Surface.load_bmp_from_io</a> -- Load a Windows BMP file into an Surface from IO object.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-123">SDL::Surface#save_bmp</a> -- Save an SDL_Surface as a Windows BMP file.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-125">SDL::Surface#destroy</a> -- Frees a Surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-126">SDL::Surface#destroyed?</a> -- Returns whether surface is destoryed or not.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-127">SDL::Surface#set_color_key</a> -- Sets the color key (transparent pixel) in a blittable surface and RLE acceleration.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-129">SDL::Surface#set_alpha</a> -- Adjust the alpha properties of a surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-136">SDL::Surface#set_clip_rect</a> -- Sets the clipping rectangle for a surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-138">SDL::Surface#get_clip_rect</a> -- Gets the clipping rectangle for a surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-142">SDL::Surface.blit</a> -- This performs a fast blit from the source surface to the destination surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-143">SDL::Surface#fill_rect</a> -- This function performs a fast fill of the given rectangle with some color</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-145">SDL::Surface#display_format</a> -- Convert a surface to the display format</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-147">SDL::Surface#display_format_alpha</a> -- Convert a surface to the display format</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-149">SDL::Surface#flags</a> -- Get surface flags</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-164">SDL::Surface#format</a> -- Get surface pixel format</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-165">SDL::Surface#w</a> -- Get surface width</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-166">SDL::Surface#h</a> -- Get surface height</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-167">SDL::Surface#pixels</a> -- Get the actual pixel data</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-168">SDL::PixelFormat#Rmask</a> -- Get binary mask used to retrieve red color value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-169">SDL::PixelFormat#Gmask</a> -- Get binary mask used to retrieve green color value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-170">SDL::PixelFormat#Bmask</a> -- Get binary mask used to retrieve blue color value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-171">SDL::PixelFormat#Amask</a> -- Get binary mask used to retrieve alpla value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-172">SDL::PixelFormat#Rloss</a> -- Precision loss of red component</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-173">SDL::PixelFormat#Gloss</a> -- Precision loss of green component</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-174">SDL::PixelFormat#Bloss</a> -- Precision loss of blue component</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-175">SDL::PixelFormat#Aloss</a> -- Precision loss of alpha component</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-176">SDL::PixelFormat#Rshift</a> -- Binary left shift of red component in the pixel value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-177">SDL::PixelFormat#Gshift</a> -- Binary left shift of green component in the pixel value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-178">SDL::PixelFormat#Bshift</a> -- Binary left shift of blue component in the pixel value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-179">SDL::PixelFormat#Ashift</a> -- Binary left shift of alpha component in the pixel value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-180">SDL::Surface#colorkey</a> -- Pixel value of transparent pixels</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-181">SDL::Surface#alpha</a> -- Overall surface alpha value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-182">SDL::PixelFormat#colorkey</a> -- Pixel value of transparent pixels.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-183">SDL::PixelFormat#alpha</a> -- Overall surface alpha value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-185">SDL::PixelFormat#bpp</a> -- The number of bits used to represent each pixel in a surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-186">SDL::Surface#pitch</a> -- The number of bytes used for one scanline in a surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-187">SDL::Surface.load</a> -- Load image into an surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-188">SDL::Surface.load_from_io</a> -- Load a image file into an Surface from IO object.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-190">SDL::Surface#put_pixel</a> -- Writes a pixel to the specified position</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-193">SDL::Surface#get_pixel</a> -- Gets the color of the specified pixel.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-196">SDL::Surface#put</a> -- Performs a fast blit from entire surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-197">SDL::Surface#copy_rect</a> -- Copies a part of surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-203">SDL::Surface.auto_lock?</a> -- Get whether surface is automatically locked</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-207">SDL::Surface.auto_lock_on</a> -- Switch on auto locking</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-211">SDL::Surface.auto_lock_off</a> -- Switch off auto locking.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-216">SDL::Surface.transform_draw</a> -- Draw a rotated and scaled image.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-223">SDL::Surface.transform_blit</a> -- Draw a rotated and scaled image with colorkey and blending</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-225">SDL::Surface#draw_line</a> -- Draw a line</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-233">SDL::Surface#draw_rect</a> -- Draws a rect</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-239">SDL::Surface#draw_circle</a> -- Draws a circle</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a> -- Draws an ellipse.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-267">SDL::Surface#draw_bezier</a> -- Draws a bezier curve</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-275">SDL::Surface#transform_surface</a> -- Creates an rotated an scaled surface</li>
</ul></li>
</ul>
<h2><a name="label-19" id="label-19">Video Subsystem Outline</a></h2><!-- RDLabel: "Video Subsystem Outline" -->
<p>SDL presents a very simple interface to the display framebuffer.
The framebuffer is represented as an offscreen surface to which
you can write directly. If you want the screen to show what you
have written, call the <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-72">update</a>
function which will guarantee that
the desired portion of the screen is updated.</p>
<p>Before you call any of the SDL video functions, you must first
call <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a>(SDL::INIT_VIDEO), which initializes the video and
events in the SDL library. </p>
<p>If you use both sound and video in your application, you need to
call <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a>(SDL::INIT_AUDIO | SDL::INIT_VIDEO) before opening
the sound device, otherwise under Win32 DirectX, you won't be
able to set full-screen display modes.</p>
<p>After you have initialized the library, you can start up the
video display in a number of ways. The easiest way is to pick a
common screen resolution and depth and just initialize the
video, checking for errors. You will probably get what you want,
but SDL may be emulating your requested mode and converting the
display on update. The best way is to <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-44">query</a>, 
for the best video
mode closest to the desired one, and then 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-145">convert</a> your images to 
that pixel format.</p>
<p>SDL currently supports any bit depth &gt;= 8 bits per pixel. 8 bpp
formats are considered 8-bit palettized modes, while 12, 15, 16,
24, and 32 bits per pixel are considered "packed pixel" modes,
meaning each pixel contains the RGB color components packed in
the bits of the pixel.</p>
<p>After you have initialized your video mode, you can take the
surface that was returned, and write to it like any other
framebuffer, calling the update routine as you go.</p>
<h2><a name="label-20" id="label-20">SDL::Surface</a></h2><!-- RDLabel: "SDL::Surface" -->
<p>Graphical Surface class.</p>
<p>This class represent areas of "graphical" memory, memory that
can be drawn to. </p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-76">SDL::Surface#set_colors</a> -- Sets a portion of the colormap for the given 8-bit surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-78">SDL::Surface#set_palette</a> -- Sets the colors in the palette of an 8-bit surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-108">SDL::Surface.new</a> -- Create an empty <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-114">SDL::Surface.new_from</a> -- Create an <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a> object from pixel data</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">SDL::Surface#lock</a> -- Lock a surface for directly access.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-116">SDL::Surface#unlock</a> -- Unlocks a previously locked surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-117">SDL::Surface#must_lock?</a> -- Get whether the surface require locking or not.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-119">SDL::Surface.load_bmp</a> -- Load a Windows BMP file into an SDL_Surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-121">SDL::Surface.load_bmp_from_io</a> -- Load a Windows BMP file into an Surface from IO object.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-123">SDL::Surface#save_bmp</a> -- Save an SDL_Surface as a Windows BMP file.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-125">SDL::Surface#destroy</a> -- Frees a Surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-126">SDL::Surface#destroyed?</a> -- Returns whether surface is destoryed or not.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-127">SDL::Surface#set_color_key</a> -- Sets the color key (transparent pixel) in a blittable surface and RLE acceleration.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-129">SDL::Surface#set_alpha</a> -- Adjust the alpha properties of a surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-136">SDL::Surface#set_clip_rect</a> -- Sets the clipping rectangle for a surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-138">SDL::Surface#get_clip_rect</a> -- Gets the clipping rectangle for a surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-142">SDL::Surface.blit</a> -- This performs a fast blit from the source surface to the destination surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-143">SDL::Surface#fill_rect</a> -- This function performs a fast fill of the given rectangle with some color</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-145">SDL::Surface#display_format</a> -- Convert a surface to the display format</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-147">SDL::Surface#display_format_alpha</a> -- Convert a surface to the display format</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-149">SDL::Surface#flags</a> -- Get surface flags</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-164">SDL::Surface#format</a> -- Get surface pixel format</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-165">SDL::Surface#w</a> -- Get surface width</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-166">SDL::Surface#h</a> -- Get surface height</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-167">SDL::Surface#pixels</a> -- Get the actual pixel data</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-180">SDL::Surface#colorkey</a> -- Pixel value of transparent pixels</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-181">SDL::Surface#alpha</a> -- Overall surface alpha value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-186">SDL::Surface#pitch</a> -- The number of bytes used for one scanline in a surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-187">SDL::Surface.load</a> -- Load image into an surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-188">SDL::Surface.load_from_io</a> -- Load a image file into an Surface from IO object.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-190">SDL::Surface#put_pixel</a> -- Writes a pixel to the specified position</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-193">SDL::Surface#get_pixel</a> -- Gets the color of the specified pixel.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-196">SDL::Surface#put</a> -- Performs a fast blit from entire surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-197">SDL::Surface#copy_rect</a> -- Copies a part of surface.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-203">SDL::Surface.auto_lock?</a> -- Get whether surface is automatically locked</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-207">SDL::Surface.auto_lock_on</a> -- Switch on auto locking</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-211">SDL::Surface.auto_lock_off</a> -- Switch off auto locking.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-216">SDL::Surface.transform_draw</a> -- Draw a rotated and scaled image.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-223">SDL::Surface.transform_blit</a> -- Draw a rotated and scaled image with colorkey and blending</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-225">SDL::Surface#draw_line</a> -- Draw a line</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-233">SDL::Surface#draw_rect</a> -- Draws a rect</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-239">SDL::Surface#draw_circle</a> -- Draws a circle</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a> -- Draws an ellipse.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-267">SDL::Surface#draw_bezier</a> -- Draws a bezier curve</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-275">SDL::Surface#transform_surface</a> -- Creates an rotated an scaled surface</li>
</ul>
<h2><a name="label-21" id="label-21">SDL::Screen</a></h2><!-- RDLabel: "SDL::Screen" -->
<p>Video framebuffer class. </p>
<p>This class is subclass of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a>, and contents 
is shown in display.</p>
<p>The video framebuffer is returned by 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a> and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-41">SDL::Screen.get</a>.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-41">SDL::Screen.get</a> -- returns the current display surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-44">SDL::Screen.info</a> -- returns information about the video hardware</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-47">SDL::Screen.driver_name</a> -- Obtain the name of the video driver</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-51">SDL::Screen.list_modes</a> -- Returns an array of available screen dimensions for the given format and video flags</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-55">SDL::Screen.check_mode</a> -- Check to see if a particular video mode is supported.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a> -- Set up a video mode with the specified width, height and bits-per-pixel.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-72">SDL::Screen#update_rect</a> -- Makes sure the given area is updated on the given screen.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-73">SDL::Screen#update_rects</a> -- Makes sure the given list of rectangles is updated on the given screen</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-75">SDL::Screen#flip</a> -- Swaps screen buffers</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-82">SDL::Screen.set_gamma</a> -- Sets the color gamma function for the display</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-86">SDL::Screen.get_gamma_ramp</a> -- Gets the color gamma lookup tables for the display</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-90">SDL::Screen.set_gamma_ramp</a> -- Sets the color gamma lookup tables for the display</li>
</ul>
<h2><a name="label-22" id="label-22">SDL::VideoInfo</a></h2><!-- RDLabel: "SDL::VideoInfo" -->
<p>Video Target information class.</p>
<p>The instance of this class is returned by <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-44">SDL::Screen.info</a>. It
contains information on either the 'best' available mode (if
called before <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a>) or the current video mode.</p>
<p>This class has following methods.</p>
<dl>
<dt><a name="label-23" id="label-23"><code>SDL::VideoInfo#hw_available</code></a></dt><!-- RDLabel: "SDL::VideoInfo#hw_available" -->
<dd>
Is it possible to create hardware surfaces?</dd>
<dt><a name="label-24" id="label-24"><code>SDL::VideoInfo#wm_available</code></a></dt><!-- RDLabel: "SDL::VideoInfo#wm_available" -->
<dd>
Is there a window manager available?</dd>
<dt><a name="label-25" id="label-25"><code>SDL::VideoInfo#blit_hw</code></a></dt><!-- RDLabel: "SDL::VideoInfo#blit_hw" -->
<dd>
Are hardware to hardware blits accelerated?</dd>
<dt><a name="label-26" id="label-26"><code>SDL::VideoInfo#blit_hw_CC</code></a></dt><!-- RDLabel: "SDL::VideoInfo#blit_hw_CC" -->
<dd>
Are hardware to hardware colorkey blits accelerated?</dd>
<dt><a name="label-27" id="label-27"><code>SDL::VideoInfo#blit_hw_A</code></a></dt><!-- RDLabel: "SDL::VideoInfo#blit_hw_A" -->
<dd>
Are hardware to hardware alpha blits accelerated?</dd>
<dt><a name="label-28" id="label-28"><code>SDL::VideoInfo#blit_sw</code></a></dt><!-- RDLabel: "SDL::VideoInfo#blit_sw" -->
<dd>
Are software to hardware blits accelerated?</dd>
<dt><a name="label-29" id="label-29"><code>SDL::VideoInfo#blit_sw_CC</code></a></dt><!-- RDLabel: "SDL::VideoInfo#blit_sw_CC" -->
<dd>
Are software to hardware colorkey blits accelerated?</dd>
<dt><a name="label-30" id="label-30"><code>SDL::VideoInfo#blit_sw_A</code></a></dt><!-- RDLabel: "SDL::VideoInfo#blit_sw_A" -->
<dd>
Are software to hardware alpha blits accelerated?</dd>
<dt><a name="label-31" id="label-31"><code>SDL::VideoInfo#blit_fill</code></a></dt><!-- RDLabel: "SDL::VideoInfo#blit_fill" -->
<dd>
Are color fills accelerated?</dd>
<dt><a name="label-32" id="label-32"><code>SDL::VideoInfo#video_mem</code></a></dt><!-- RDLabel: "SDL::VideoInfo#video_mem" -->
<dd>
Total amount of video memory in Kilobytes</dd>
<dt><a name="label-33" id="label-33"><code>SDL::VideoInfo#bpp</code></a></dt><!-- RDLabel: "SDL::VideoInfo#bpp" -->
<dd>
bits per pixel of the video device</dd>
</dl>
<h2><a name="label-34" id="label-34">SDL::PixelFormat</a></h2><!-- RDLabel: "SDL::PixelFormat" -->
<p>Surface format information class.
Please see <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-35">Color, PixelFormat and Pixel value</a>.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-94">SDL::PixelFormat#map_rgb</a> -- RGB Map a RGB color value to a pixel format.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-98">SDL::PixelFormat#map_rgba</a> -- Map a RGBA color value to a pixel format.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-102">SDL::PixelFormat#get_rgb</a> -- Get RGB values from a pixel in the specified pixel format.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-106">SDL::PixelFormat#get_rgba</a> -- Get RGBA values from a pixel in the specified pixel format.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-168">SDL::PixelFormat#Rmask</a> -- Get binary mask used to retrieve red color value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-169">SDL::PixelFormat#Gmask</a> -- Get binary mask used to retrieve green color value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-170">SDL::PixelFormat#Bmask</a> -- Get binary mask used to retrieve blue color value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-171">SDL::PixelFormat#Amask</a> -- Get binary mask used to retrieve alpla value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-172">SDL::PixelFormat#Rloss</a> -- Precision loss of red component</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-173">SDL::PixelFormat#Gloss</a> -- Precision loss of green component</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-174">SDL::PixelFormat#Bloss</a> -- Precision loss of blue component</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-175">SDL::PixelFormat#Aloss</a> -- Precision loss of alpha component</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-176">SDL::PixelFormat#Rshift</a> -- Binary left shift of red component in the pixel value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-177">SDL::PixelFormat#Gshift</a> -- Binary left shift of green component in the pixel value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-178">SDL::PixelFormat#Bshift</a> -- Binary left shift of blue component in the pixel value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-179">SDL::PixelFormat#Ashift</a> -- Binary left shift of alpha component in the pixel value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-182">SDL::PixelFormat#colorkey</a> -- Pixel value of transparent pixels.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-183">SDL::PixelFormat#alpha</a> -- Overall surface alpha value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-185">SDL::PixelFormat#bpp</a> -- The number of bits used to represent each pixel in a surface</li>
</ul>
<h2><a name="label-35" id="label-35">Color, PixelFormat and Pixel value</a></h2><!-- RDLabel: "Color, PixelFormat and Pixel value" -->
<h3><a name="label-36" id="label-36">Outline</a></h3><!-- RDLabel: "Outline" -->
<p>In Ruby/SDL, color is described as four elements
of 8-bit unsigned interger(from 0 to 255), Red, Green,
Blue and Alpha. In Ruby/SDL, this values are
packed as unsigned n-bit integer(n=8,16,24,32).
The rules of this conversion is called PixelFormat
and converted n-bit integer is called pixel value.
Each surface has one PixelFormat, and you can use
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-164">SDL::Surface#format</a> to get PixelFormat from surface object.
You can also covert from or to pixel values calling
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-94">SDL::PixelFormat#map_rgb</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-98">SDL::PixelFormat#map_rgba</a>,
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-102">SDL::PixelFormat#get_rgb</a> and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-106">SDL::PixelFormat#get_rgba</a>.
You can use pixel value or 3 elements array 
or 4 elements array as color parameter.
Return values are normally pixel values.</p>
<h3><a name="label-37" id="label-37">Details</a></h3><!-- RDLabel: "Details" -->
<p>Not documented yet.</p>
<h2><a name="label-38" id="label-38">Video Methods</a></h2><!-- RDLabel: "Video Methods" -->
<dl>
<dt><a name="label-39" id="label-39"><code>SDL.get_video_surface</code></a></dt><!-- RDLabel: "SDL.get_video_surface" -->
<dt><a name="label-40" id="label-40"><code>SDL.getVideoSurface</code></a></dt><!-- RDLabel: "SDL.getVideoSurface" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-41">SDL::Screen.get</a> instead.</dd>
<dt><a name="label-41" id="label-41"><code>SDL::Screen.get</code></a></dt><!-- RDLabel: "SDL::Screen.get" -->
<dd>
<p>This method returns the current display surface.
If SDL is doing format conversion on the display surface, this
method returns the publicly visible surface, not the real
video surface.</p>
<p>Returns the instance of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-21">SDL::Screen</a>.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p></dd>
<dt><a name="label-42" id="label-42"><code>SDL.video_info</code></a></dt><!-- RDLabel: "SDL.video_info" -->
<dt><a name="label-43" id="label-43"><code>SDL.videoInfo</code></a></dt><!-- RDLabel: "SDL.videoInfo" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-44">SDL::Screen.info</a> instead.</dd>
<dt><a name="label-44" id="label-44"><code>SDL::Screen.info</code></a></dt><!-- RDLabel: "SDL::Screen.info" -->
<dd>
<p>This function returns a <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-22">information</a> about
the video hardware. If this is called before <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a>,
bpp attribute of the returned object will contain the pixel
format of the "best" video mode.</p>
<p>Returns the instance of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-22">SDL::VideoInfo</a>.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-22">SDL::VideoInfo</a></p></li>
</ul></dd>
<dt><a name="label-45" id="label-45"><code>SDL.video_driver_name</code></a></dt><!-- RDLabel: "SDL.video_driver_name" -->
<dt><a name="label-46" id="label-46"><code>SDL.videoDriverName</code></a></dt><!-- RDLabel: "SDL.videoDriverName" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-47">SDL::Screen.driver_name</a> instead.</dd>
<dt><a name="label-47" id="label-47"><code>SDL::Screen.driver_name</code></a></dt><!-- RDLabel: "SDL::Screen.driver_name" -->
<dt><a name="label-48" id="label-48"><code>SDL::Screen.driverName</code></a></dt><!-- RDLabel: "SDL::Screen.driverName" -->
<dd>
<p>The driver name is a simple one
word identifier like "x11" or "windib".</p>
<p>Returns driver name as string.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> if video has not been initialized with 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a>.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a></p></li>
</ul></dd>
<dt><a name="label-49" id="label-49"><code>SDL.list_modes(<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL.list_modes" -->
<dt><a name="label-50" id="label-50"><code>SDL.listModes(<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL.listModes" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-51">SDL::Screen.list_modes</a> instead.</dd>
<dt><a name="label-51" id="label-51"><code>SDL::Screen.list_modes(<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL::Screen.list_modes" -->
<dt><a name="label-52" id="label-52"><code>SDL::Screen.listModes(<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL::Screen.listModes" -->
<dd>
<p>Return an array of available screen dimensions for
the given format and video flags, sorted largest to smallest.</p>
<p>Returns nil if there are no dimensions available for a
particular format, or true if any dimension is okay for the given
format.
The flag parameter is an OR'd
combination of surface flags. The flags are the same as those
used <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a> and they play a strong role in deciding
what modes are valid.
For instance, if you pass SDL::HWSURFACE as
a flag only modes that support hardware video surfaces will be
returned.</p>
<p>EXAMPLE</p>
<pre># Get available fullscreen/hardware modes
modes = SDL::Screen.list_modes(SDL::FULLSCREEN|SDL::HWSURFACE)

# Check is there are any modes available
if modes == nil
  puts "No modes available!"
  exit 1
end

# Check is there are any modes available
if modes == true
  puts "All resolutions available."
else
  # Print valid modes
  puts "Available Modes"
  modes.each{|w, h| puts "  #{w} x #{h}"}
end</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-44">SDL::Screen.info</a></p></li>
</ul></dd>
<dt><a name="label-53" id="label-53"><code>SDL.check_video_mode(<var>w</var>,<var>h</var>,<var>bpp</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL.check_video_mode" -->
<dt><a name="label-54" id="label-54"><code>SDL.checkVideoMode(<var>w</var>,<var>h</var>,<var>bpp</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL.checkVideoMode" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-55">SDL::Screen.check_mode</a> instead.</dd>
<dt><a name="label-55" id="label-55"><code>SDL::Screen.check_mode(<var>w</var>,<var>h</var>,<var>bpp</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL::Screen.check_mode" -->
<dt><a name="label-56" id="label-56"><code>SDL::Screen.checkMode(<var>w</var>,<var>h</var>,<var>bpp</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL::Screen.checkMode" -->
<dd>
<p>Returns 0 if the requested mode is not supported
under any bit depth,
or returns the bits-per-pixel of the
closest available mode with the given width, height and
requested surface flags (see <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a>).</p>
<p>The bits-per-pixel value returned is only a suggested mode. You
can usually request and bpp you want when 
<!-- Reference, RDLabel "SDL::Screen.opn" doesn't exist --><em class="label-not-found">setting</em><!-- Reference end --> the video mode
and SDL will emulate that color depth with a shadow video
surface.</p>
<p>EXAMPLE</p>
<pre>puts "Checking mode 640x480@16bpp."
bpp = SDL::Screen.check_mode(640, 480, 16, SDL::HWSURFACE)
if bpp == 0
  puts "Mode not available."
  exit 1
end

puts "SDL Recomemends 640x480@#{bpp}bpp."
screen = SDL::Screen.open(640, 480, bpp, SDL_HWSURFACE)</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-44">SDL::Screen.info</a></p></li>
</ul></dd>
<dt><a name="label-57" id="label-57"><code>SDL.setVideoMode(<var>w</var>,<var>h</var>,<var>bpp</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL.setVideoMode" -->
<dt><a name="label-58" id="label-58"><code>SDL.set_video_mode(<var>w</var>,<var>h</var>,<var>bpp</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL.set_video_mode" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a> instead.</dd>
<dt><a name="label-59" id="label-59"><code>SDL::Screen.open(<var>w</var>,<var>h</var>,<var>bpp</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL::Screen.open" -->
<dd>
<p>Set up a video mode with the specified width, height and
bits-per-pixel.</p>
<p>If bpp is 0, it is treated as the current display bits per
pixel.</p>
<p>The flags parameter is the same as the <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-149">SDL::Surface#flags</a>
OR'd combinations of the following values
are valid.</p>
<dl>
<dt><a name="label-60" id="label-60">SDL::SWSURFACE</a></dt><!-- RDLabel: "SDL::SWSURFACE" -->
<dd>
Create the video surface in system memory
</dd>
<dt><a name="label-61" id="label-61">SDL::HWSURFACE</a></dt><!-- RDLabel: "SDL::HWSURFACE" -->
<dd>
Create the video surface in video memory
</dd>
<dt><a name="label-62" id="label-62">SDL::ASYNCBLIT</a></dt><!-- RDLabel: "SDL::ASYNCBLIT" -->
<dd>
Enables the use of asynchronous updates of the
display surface. This will usually slow down
blitting on single CPU machines, but may
provide a speed increase on SMP systems.
</dd>
<dt><a name="label-63" id="label-63">SDL::ANYFORMAT</a></dt><!-- RDLabel: "SDL::ANYFORMAT" -->
<dd>
Normally, if a video surface of the requested
bits-per-pixel (<var>bpp</var>) is not available, SDL will
emulate one with a shadow surface. Passing
SDL_ANYFORMAT prevents this and causes SDL to
use the video surface, regardless of its pixel
depth.
</dd>
<dt><a name="label-64" id="label-64">SDL::HWPALETTE</a></dt><!-- RDLabel: "SDL::HWPALETTE" -->
<dd>
Give SDL exclusive palette access. Without this
flag you may not always get the the colors you
request with <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-76">SDL::Surface#set_colors</a> or <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-78">SDL::Surface#set_palette</a>.
</dd>
<dt><a name="label-65" id="label-65">SDL::DOUBLEBUF</a></dt><!-- RDLabel: "SDL::DOUBLEBUF" -->
<dd>
Enable hardware double buffering; only valid
with SDL::HWSURFACE. Calling <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-75">SDL::Screen#flip</a> will flip
the buffers and update the screen. All drawing
will take place on the surface that is not
displayed at the moment. If double buffering
could not be enabled then <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-75">SDL::Screen#flip</a> will just
perform a <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-72">SDL::Screen#update_rect</a> on the entire screen.
</dd>
<dt><a name="label-66" id="label-66">SDL::FULLSCREEN</a></dt><!-- RDLabel: "SDL::FULLSCREEN" -->
<dd>
SDL will attempt to use a fullscreen mode. If a
hardware resolution change is not possible (for
whatever reason), the next higher resolution
will be used and the display window centered on
a black background.
</dd>
<dt><a name="label-67" id="label-67">SDL::OPENGL</a></dt><!-- RDLabel: "SDL::OPENGL" -->
<dd>
Create an OpenGL rendering context. You should
have previously set OpenGL video attributes
with <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-285">SDL::GL.set_attr</a>.
</dd>
<dt><a name="label-68" id="label-68">SDL::OPENGLBLIT</a></dt><!-- RDLabel: "SDL::OPENGLBLIT" -->
<dd>
Create an OpenGL rendering context, like above,
but allow normal blitting operations. The
screen (2D) surface may have an alpha channel,
and <!-- Reference, RDLabel "SDL::Screen.update_rect" doesn't exist --><em class="label-not-found">SDL::Screen.update_rect</em><!-- Reference end --> must be used for updating
changes to the screen surface. NOTE: This
option is kept for compatibility only, and is
<em>not recommended</em> for new code.
</dd>
<dt><a name="label-69" id="label-69">SDL::RESIZABLE</a></dt><!-- RDLabel: "SDL::RESIZABLE" -->
<dd>
Create a resizable window. When the window is
resized by the user a <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-316">SDL::Event::VideoResize</a> event is
generated and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a> can be called
again with the new size.
</dd>
<dt><a name="label-70" id="label-70">SDL::NOFRAME</a></dt><!-- RDLabel: "SDL::NOFRAME" -->
<dd>
If possible, SDL::NOFRAME causes SDL to create a
window with no title bar or frame decoration.
Fullscreen modes automatically have this flag
set.
</dd>
</dl>
<p>Returns the framebuffer surface as instace of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-21">SDL::Screen</a>.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>NOTES</p>
<p>Whatever flags <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a> could satisfy are set
in the <var>Surface#flags</var> of the returned surface.</p>
<p>The <var>bpp</var> parameter is the number of bits per pixel, so
a <var>bpp</var> of 24 uses the packed representation of 3 bytes/pixel.
For the more common 4 bytes/pixel mode, use a <var>bpp</var> of 32.
Somewhat oddly, both 15 and 16 will request a 2 bytes/pixel
mode, but different pixel formats.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">SDL::Surface#lock</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-76">SDL::Surface#set_colors</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-75">SDL::Screen#flip</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-21">SDL::Screen</a></p></li>
</ul></dd>
<dt><a name="label-71" id="label-71"><code>SDL::Screen#updateRect(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>)</code></a></dt><!-- RDLabel: "SDL::Screen#updateRect" -->
<dt><a name="label-72" id="label-72"><code>SDL::Screen#update_rect(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>)</code></a></dt><!-- RDLabel: "SDL::Screen#update_rect" -->
<dd>
<p>Makes sure the given area is updated on the given screen. The
rectangle must be confined within the screen boundaries (no
clipping is done).</p>
<p>If <var>x</var>, <var>y</var>, <var>w</var> and <var>h</var> are all 0, this method
update the entire screen.</p>
<p>This method should not be called while screen is
<var>locked|Surface#lock</var>.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">SDL::Surface#lock</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-73">SDL::Screen#update_rects</a></p></li>
</ul></dd>
<dt><a name="label-73" id="label-73"><code>SDL::Screen#update_rects(*<var>rects</var>)</code></a></dt><!-- RDLabel: "SDL::Screen#update_rects" -->
<dt><a name="label-74" id="label-74"><code>SDL::Screen#updateRects(*<var>rects</var>)</code></a></dt><!-- RDLabel: "SDL::Screen#updateRects" -->
<dd>
<p>Makes sure the given list of rectangles is updated on the given
screen. Each rectangle parameter should be an array
of 4 elements as [x, y, w, h].
The rectangles must all be confined within the screen
boundaries (no clipping is done).</p>
<p>This method should not be called while screen(<var>self</var>),
is <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">locked</a>.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">SDL::Surface#lock</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-72">SDL::Screen#update_rect</a></p></li>
</ul></dd>
<dt><a name="label-75" id="label-75"><code>SDL::Screen#flip</code></a></dt><!-- RDLabel: "SDL::Screen#flip" -->
<dd>
<p>On hardware that supports double-buffering, this function sets
up a flip and returns. The hardware will wait for vertical
retrace, and then swap video buffers before the next video
surface blit or lock will return. On hardware that doesn't
support double-buffering, this is equivalent to calling 
<var>self</var>.<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-72">update_rect</a>(0, 0, 0, 0)</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-58">SDL.set_video_mode</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-72">SDL::Screen#update_rect</a></p></li>
</ul></dd>
<dt><a name="label-76" id="label-76"><code>SDL::Surface#set_colors(<var>colors</var>,<var>firstcolor</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#set_colors" -->
<dt><a name="label-77" id="label-77"><code>SDL::Surface#setColors(<var>colors</var>,<var>firstcolor</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#setColors" -->
<dd>
<p>Sets a portion of the colormap for the given 8-bit surface.</p>
<p>When <var>self</var> is the surface associated with the current display,
the display colormap will be updated with the requested colors.
If SDL::HWPALETTE was set in <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a> flags,
this method will always return true, and the palette is
guaranteed to be set the way you desire, even if the window
colormap has to be warped or run under emulation.</p>
<p><var>colors</var> is array of colors, one color has three componets,
R, G, B and each component is 8-bits in size.</p>
<p>Palettized (8-bit) screen surfaces with the SDL::HWPALETTE flag
have two palettes, a logical palette that is used for mapping
blits to/from the surface and a physical palette (that
determines how the hardware will map the colors to the display).
SDL_SetColors modifies both palettes (if present), and is
equivalent to calling <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-78">SDL::Surface#set_palette</a> 
with the flags set to (SDL::OGPAL | SDL::PHYSPAL).</p>
<p>If <var>self</var> is not a palettized surface, this method does
nothing, returning false.
If all of the colors were set as passed to
this method, it will return true.
If not all the color entries
were set exactly as given, it will return false,
and you should look
at the surface palette to determine the actual color palette.</p>
<p>EXAMPLE</p>
<pre># Create a display surface with a grayscale palette

# Fill colors with color information
colors = Array.new(256){|i| [i, i, i]}
# Create display
screen = SDL::Screen.open(640, 480, 8, SDL::HWPALETTE)

# Set palette
screen.set_colors(colors, 0)</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-78">SDL::Surface#set_palette</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a></p></li>
</ul></dd>
<dt><a name="label-78" id="label-78"><code>SDL::Surface#set_palette(<var>flags</var>,<var>colors</var>,<var>firstcolor</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#set_palette" -->
<dt><a name="label-79" id="label-79"><code>SDL::Surface#setPalette(<var>flags</var>,<var>colors</var>,<var>firstcolor</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#setPalette" -->
<dd>
<p>Sets a portion of the palette for the given 8-bit surface.</p>
<p>Palettized (8-bit) screen surfaces with the SDL::HWPALETTE flag
have two palettes, a logical palette that is used for mapping
blits to/from the surface and a physical palette (that
determines how the hardware will map the colors to the display).
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-142">SDL::Surface.blit</a> always uses the logical palette when blitting
surfaces (if it has to convert between surface pixel formats).
Because of this, it is often useful to modify only one or the
other palette to achieve various special color effects (e.g.,
screen fading, color flashes, screen dimming).</p>
<p>This method can modify either the logical or physical palette
by specifing SDL::LOGPAL or SDL::PHYSPALthe in the <var>flags</var>
parameter.</p>
<p>When <var>self</var> is the surface associated with the current display,
the display colormap will be updated with the requested colors.
If SDL::HWPALETTE was set in <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a> flags,
this method will always return true, and the palette is
guaranteed to be set the way you desire, even if the window
colormap has to be warped or run under emulation.</p>
<p><var>colors</var> is array of colors, one color has three componets,
R, G, B and each component is 8-bits in size.</p>
<p>If surface is not a palettized surface, this function does
nothing, returning false.
If all of the colors were set as passed to
this method, it will return true.
If not all the color entries
were set exactly as given, it will return false,</p>
<pre>and you should look</pre>
<p>at the surface palette to determine the actual color palette.</p>
<p>EXAMPLE</p>
<pre># Create a display surface with a grayscale palette

# Fill colors with color information
colors = Array.new(256){|i| [i, i, i]}
# Create display
screen = SDL::Screen.open(640, 480, 8, SDL::HWPALETTE)

# Setpalette
screen.set_palette(SDL::LOGPAL|SDL::PHYSPAL, colors, 0)</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-76">SDL::Surface#set_colors</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a></p></li>
</ul></dd>
<dt><a name="label-80" id="label-80"><code>SDL.set_gamma(<var>redgamma</var>,<var>greengamma</var>,<var>bluegamma</var>)</code></a></dt><!-- RDLabel: "SDL.set_gamma" -->
<dt><a name="label-81" id="label-81"><code>SDL.setGamma(<var>redgamma</var>,<var>greengamma</var>,<var>bluegamma</var>)</code></a></dt><!-- RDLabel: "SDL.setGamma" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-82">SDL::Screen.set_gamma</a> instead.</dd>
<dt><a name="label-82" id="label-82"><code>SDL::Screen.set_gamma(<var>redgamma</var>,<var>greengamma</var>,<var>bluegamma</var>)</code></a></dt><!-- RDLabel: "SDL::Screen.set_gamma" -->
<dt><a name="label-83" id="label-83"><code>SDL::Screen.setGamma(<var>redgamma</var>,<var>greengamma</var>,<var>bluegamma</var>)</code></a></dt><!-- RDLabel: "SDL::Screen.setGamma" -->
<dd>
<p>Sets the "gamma function" for the display of each color
component. Gamma controls the brightness/contrast of colors
displayed on the screen. A gamma value of 1.0 is identity (i.e.,
no adjustment is made).</p>
<p>This function adjusts the gamma based on the "gamma function"
parameter, you can directly specify lookup tables for gamma
adjustment with <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-90">SDL::Screen.set_gamma_ramp</a>.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>NOTES</p>
<p>Not all display hardware is able to change gamma.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-86">SDL::Screen.get_gamma_ramp</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-90">SDL::Screen.set_gamma_ramp</a></p></li>
</ul></dd>
<dt><a name="label-84" id="label-84"><code>SDL.get_gamma_ramp</code></a></dt><!-- RDLabel: "SDL.get_gamma_ramp" -->
<dt><a name="label-85" id="label-85"><code>SDL.getGammaRamp</code></a></dt><!-- RDLabel: "SDL.getGammaRamp" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-86">SDL::Screen.get_gamma_ramp</a> instead.</dd>
<dt><a name="label-86" id="label-86"><code>SDL::Screen.get_gamma_ramp</code></a></dt><!-- RDLabel: "SDL::Screen.get_gamma_ramp" -->
<dt><a name="label-87" id="label-87"><code>SDL::Screen.getGammaRamp</code></a></dt><!-- RDLabel: "SDL::Screen.getGammaRamp" -->
<dd>
<p>Gets the gamma translation lookup tables currently used by the
display. Each table is an array of 256 16bit unsigned integer
values.</p>
<p>Returns an array of 3 elements of an array of 256 16bit unsigned integer.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>NOTES</p>
<p>Not all display hardware is able to change gamma.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-82">SDL::Screen.set_gamma</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-90">SDL::Screen.set_gamma_ramp</a></p></li>
</ul></dd>
<dt><a name="label-88" id="label-88"><code>SDL.set_gamma_ramp(<var>table</var>)</code></a></dt><!-- RDLabel: "SDL.set_gamma_ramp" -->
<dt><a name="label-89" id="label-89"><code>SDL.setGammaRamp(<var>table</var>)</code></a></dt><!-- RDLabel: "SDL.setGammaRamp" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-90">SDL::Screen.set_gamma_ramp</a> instead.</dd>
<dt><a name="label-90" id="label-90"><code>SDL::Screen.set_gamma_ramp(<var>tables</var>)</code></a></dt><!-- RDLabel: "SDL::Screen.set_gamma_ramp" -->
<dt><a name="label-91" id="label-91"><code>SDL::Screen.setGammaRamp(<var>tables</var>)</code></a></dt><!-- RDLabel: "SDL::Screen.setGammaRamp" -->
<dd>
<p>Sets the gamma lookup tables for the display for each color
component. 
<var>tables</var> parameter is same as <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-86">SDL::Screen.get_gamma_ramp</a>,
representing a mapping between the input and output for that
channel. The input is the index into the array, and the output
is the 16-bit gamma value at that index, scaled to the output
color precision. </p>
<p>This function adjusts the gamma based on lookup tables, you can
also have the gamma calculated based on a "gamma function"
parameter with <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-82">SDL::Screen.set_gamma</a>.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-82">SDL::Screen.set_gamma</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-86">SDL::Screen.get_gamma_ramp</a></p></li>
</ul></dd>
<dt><a name="label-92" id="label-92"><code>SDL::Surface#map_rgb(<var>r</var>,<var>g</var>,<var>b</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#map_rgb" -->
<dt><a name="label-93" id="label-93"><code>SDL::Surface#mapRGB(<var>r</var>,<var>g</var>,<var>b</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#mapRGB" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-94">SDL::PixelFormat#map_rgb</a> instead.</dd>
<dt><a name="label-94" id="label-94"><code>SDL::PixelFormat#map_rgb(<var>r</var>,<var>g</var>,<var>b</var>)</code></a></dt><!-- RDLabel: "SDL::PixelFormat#map_rgb" -->
<dt><a name="label-95" id="label-95"><code>SDL::PixelFormat#mapRGB(<var>r</var>,<var>g</var>,<var>b</var>)</code></a></dt><!-- RDLabel: "SDL::PixelFormat#mapRGB" -->
<dd>
<p>Maps the RGB color value to the specified pixel format and
returns the pixel value as a 32-bit integer.
<var>r</var>, <var>g</var>, <var>b</var> should be more than and equal to 0,
and less than or equal to 255.</p>
<p>If the format has a palette (8-bit) the index of the closest
matching color in the palette will be returned.</p>
<p>If the specified pixel format has an alpha component it will be
returned as all 1 bits (fully opaque).</p>
<p>A pixel value best approximating the given RGB color value for a
given pixel format. If the pixel format bpp (color depth) is
less than 32-bpp then the unused upper bits of the return value
can safely be ignored (e.g., with a 16-bpp format the return
value can be assigned to a 16-bit unsigned integer,
and similarly a 8-bit unsigned integer for an 8-bpp format).</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-102">SDL::PixelFormat#get_rgb</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-106">SDL::PixelFormat#get_rgba</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-98">SDL::PixelFormat#map_rgba</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-35">Color, PixelFormat and Pixel value</a></p></li>
</ul></dd>
<dt><a name="label-96" id="label-96"><code>SDL::Surface#map_rgba(<var>r</var>,<var>g</var>,<var>b</var>,<var>a</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#map_rgba" -->
<dt><a name="label-97" id="label-97"><code>SDL::Surface#mapRGBA(<var>r</var>,<var>g</var>,<var>b</var>,<var>a</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#mapRGBA" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-98">SDL::PixelFormat#map_rgba</a> instead.</dd>
<dt><a name="label-98" id="label-98"><code>SDL::PixelFormat#map_rgba(<var>r</var>,<var>g</var>,<var>b</var>,<var>a</var>)</code></a></dt><!-- RDLabel: "SDL::PixelFormat#map_rgba" -->
<dt><a name="label-99" id="label-99"><code>SDL::PixelFormat#mapRGBA(<var>r</var>,<var>g</var>,<var>b</var>,<var>a</var>)</code></a></dt><!-- RDLabel: "SDL::PixelFormat#mapRGBA" -->
<dd>
<p>Maps the RGBA color value to the specified pixel format and
returns the pixel value as a 32-bit integer.
<var>r</var>, <var>g</var>, <var>b</var> should be more than and equal to 0,
and less than or equal to 255.</p>
<p>If the format has a palette (8-bit) the index of the closest
matching color in the palette will be returned.</p>
<p>If the specified pixel format has no alpha component the alpha
value will be ignored (as it will be in formats with a palette).</p>
<p>A pixel value best approximating the given RGBA color value for a
given pixel format. If the pixel format bpp (color depth) is
less than 32-bpp then the unused upper bits of the return value
can safely be ignored (e.g., with a 16-bpp format the return
value can be assigned to a 16-bit unsigned integer,
and similarly a 8-bit unsigned integer for an 8-bpp format).</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-102">SDL::PixelFormat#get_rgb</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-106">SDL::PixelFormat#get_rgba</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-94">SDL::PixelFormat#map_rgb</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-35">Color, PixelFormat and Pixel value</a></p></li>
</ul></dd>
<dt><a name="label-100" id="label-100"><code>SDL::Surface#get_rgb(<var>pixel</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#get_rgb" -->
<dt><a name="label-101" id="label-101"><code>SDL::Surface#getRGB(<var>pixel</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#getRGB" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-102">SDL::PixelFormat#get_rgb</a> instead.</dd>
<dt><a name="label-102" id="label-102"><code>SDL::PixelFormat#get_rgb(<var>pixel</var>)</code></a></dt><!-- RDLabel: "SDL::PixelFormat#get_rgb" -->
<dt><a name="label-103" id="label-103"><code>SDL::PixelFormat#getRGB(<var>pixel</var>)</code></a></dt><!-- RDLabel: "SDL::PixelFormat#getRGB" -->
<dd>
<p>Get RGB component values from a pixel stored in the specified
pixel format. It returns an array of 3 elements.</p>
<p>This function uses the entire 8-bit [0..255] range when
converting color components from pixel formats with less than
8-bits per RGB component (e.g., a completely white pixel in
16-bit RGB565 format would return [0xff, 0xff, 0xff] not [0xf8,
0xfc, 0xf8]).</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-106">SDL::PixelFormat#get_rgba</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-94">SDL::PixelFormat#map_rgb</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-98">SDL::PixelFormat#map_rgba</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-35">Color, PixelFormat and Pixel value</a></p></li>
</ul></dd>
<dt><a name="label-104" id="label-104"><code>SDL::Surface#get_rgba(<var>pixel</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#get_rgba" -->
<dt><a name="label-105" id="label-105"><code>SDL::Surface#getRGBA(<var>pixel</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#getRGBA" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-106">SDL::PixelFormat#get_rgba</a> instead.</dd>
<dt><a name="label-106" id="label-106"><code>SDL::PixelFormat#get_rgba(<var>pixel</var>)</code></a></dt><!-- RDLabel: "SDL::PixelFormat#get_rgba" -->
<dt><a name="label-107" id="label-107"><code>SDL::PixelFormat#getRGBA(<var>pixel</var>)</code></a></dt><!-- RDLabel: "SDL::PixelFormat#getRGBA" -->
<dd>
<p>Get RGBA component values as array of four elements 
from a pixel stored in the specified
pixel format.</p>
<p>This function uses the entire 8-bit [0..255] range when
converting color components from pixel formats with less than
8-bits per RGB component (e.g., a completely white pixel in
16-bit RGB565 format would return [0xff, 0xff, 0xff] not [0xf8,
0xfc, 0xf8]).</p>
<p>If the surface has no alpha component, the alpha will be
returned as 0xff (100% opaque).</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-106">SDL::PixelFormat#get_rgba</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-94">SDL::PixelFormat#map_rgb</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-98">SDL::PixelFormat#map_rgba</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-35">Color, PixelFormat and Pixel value</a></p></li>
</ul></dd>
<dt><a name="label-108" id="label-108"><code>SDL::Surface.new(<var>flags</var>,<var>w</var>,<var>h</var>,<var>depth</var>,<var>Rmask</var>,<var>Gmask</var>,<var>Bmask</var>,<var>Amask</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.new" -->
<dt><a name="label-109" id="label-109"><code>SDL::Surface.new(<var>flags</var>,<var>w</var>,<var>h</var>,<var>format</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.new" -->
<dd>
<p>Allocate an empty surface 
(must be called after <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a>)</p>
<p>If depth is 8 bits an empty palette is allocated for the
surface, otherwise a 'packed-pixel' format is created
using the <var>RGBAmask</var>'s provided (see <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-34">SDL::PixelFormat</a>). 
The <var>flags</var>
specifies the type of surface that should be created, it is an
OR'd combination of the following possible values.</p>
<dl>
<dt><a name="label-110" id="label-110">SDL::SWSURFACE</a></dt><!-- RDLabel: "SDL::SWSURFACE" -->
<dd>
SDL will create the surface in system memory.
This improves the performance of pixel level
access, however you may not be able to take
advantage of some types of hardware blitting.
</dd>
<dt><a name="label-111" id="label-111">SDL::HWSURFACE</a></dt><!-- RDLabel: "SDL::HWSURFACE" -->
<dd>
SDL will attempt to create the surface in
video memory. This will allow SDL to take
advantage of Video-&gt;Video blits (which are
often accelerated).
</dd>
<dt><a name="label-112" id="label-112">SDL::SRCCOLORKEY</a></dt><!-- RDLabel: "SDL::SRCCOLORKEY" -->
<dd>
This flag turns on colourkeying for blits from
this surface. If SDL::HWSURFACE is also
specified and colourkeyed blits are
hardware-accelerated, then SDL will attempt to
place the surface in video memory. Use
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-127">SDL::Surface#set_color_key</a> to set or clear this flag
after surface creation.
</dd>
<dt><a name="label-113" id="label-113">SDL::SRCALPHA</a></dt><!-- RDLabel: "SDL::SRCALPHA" -->
<dd>
This flag turns on alpha-blending for blits
from this surface. If SDL::HWSURFACE is also
specified and alpha-blending blits are
hardware-accelerated, then the surface will be
placed in video memory if possible. Use
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-129">SDL::Surface#set_alpha</a> to set or clear this flag after
surface creation.
</dd>
</dl>
<p>Returns the instance of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a>.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>EXAMPLE</p>
<pre># Create a 32-bit surface with the bytes of 
# each pixel in R,G,B,A order,
# as expected by OpenGL for textures

big_endian = ([1].pack("N") == [1].pack("L"))

if big_endian
  rmask = 0xff000000
  gmask = 0x00ff0000
  bmask = 0x0000ff00
  amask = 0x000000ff
else
  rmask = 0x000000ff
  gmask = 0x0000ff00
  bmask = 0x00ff0000
  amask = 0xff000000
end

surface = SDL::Surface.new(SDL::SWSURFACE, width, height, 32,
                           rmask, gmask, bmask, amask);</pre>
<ul>
<li><p>NOTES</p>
<pre>Note: If an alpha-channel is specified (that is, if ((|Amask|)) is
nonzero), then the SDL::SRCALPHA flag is automatically set.
You may remove this flag by calling ((&lt;SDL::Surface#set_alpha&gt;)) after
surface creation.</pre></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-114">SDL::Surface.new_from</a>, <!-- Reference, RDLabel "SDL::Screen.oepn" doesn't exist --><em class="label-not-found">SDL::Screen.oepn</em><!-- Reference end -->, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">SDL::Surface#lock</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-129">SDL::Surface#set_alpha</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-127">SDL::Surface#set_color_key</a></p></li>
</ul></dd>
<dt><a name="label-114" id="label-114"><code>SDL::Surface.new_from(<var>pixels</var>,<var>w</var>,<var>h</var>,<var>depth</var>,<var>pitch</var>,<var>Rmask</var>,<var>Gmask</var>,<var>Bmask</var>,<var>Amask</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.new_from" -->
<dd>
<p>Creates an <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a> object from the provided pixel data.</p>
<p>The data stored in <var>pixels</var>(String object)</p>
<pre>is assumed to be of the depth</pre>
<p>specified in the parameter list. 
<var>pitch</var> is the length of each scanline in bytes.</p>
<p>See <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-108">SDL::Surface.new</a> for a more detailed description of the
other parameters.</p>
<p>Returns the created surface.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-108">SDL::Surface.new</a></p></li>
</ul></dd>
<dt><a name="label-115" id="label-115"><code>SDL::Surface#lock</code></a></dt><!-- RDLabel: "SDL::Surface#lock" -->
<dd>
<p>This method sets up a surface for directly accessing the pixels. Between calls to <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">SDL::Surface#lock</a> 
and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-116">SDL::Surface#unlock</a> you can write to and read from surface directly.
Once you are done accessing the surface, you should use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-116">SDL::Surface#unlock</a> to release it.</p>
<p>Not all surfaces require locking. If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-117">SDL::Surface#must_lock?</a> returns false, then you can read and write to
the surface at any time, and the pixel format of the surface will not change.</p>
<p>No operating system or library calls should be made between lock/unlock pairs, as critical system locks
may be held during this time.</p>
<p>It should be noted, that since SDL 1.1.8 surface locks are recursive. This means that you can lock a
surface multiple times, but each lock must have a match unlock.</p>
<pre>surface.lock
# Surface is locked
# Direct pixel access on surface here
surface.lock
# More direct pixel access on surface
surface.unlock
# Surface is still locked
# Note: Is versions &lt; 1.1.8, the surface would have been
# no longer locked at this stage
surface.unlock
# Surface is now unlocked</pre>
<p>You shoud lock before colling following methods:</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-167">SDL::Surface#pixels</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-190">SDL::Surface#put_pixel</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-193">SDL::Surface#get_pixel</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-225">SDL::Surface#draw_line</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-227">SDL::Surface#draw_aa_line</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-229">SDL::Surface#draw_line_alpha</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-231">SDL::Surface#draw_aa_line_alpha</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-233">SDL::Surface#draw_rect</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-235">SDL::Surface#draw_rect_alpha</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-237">SDL::Surface#draw_filled_rect_alpha</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-239">SDL::Surface#draw_circle</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-241">SDL::Surface#draw_filled_circle</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-243">SDL::Surface#draw_aa_circle</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-245">SDL::Surface#draw_aa_filled_circle</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-247">SDL::Surface#draw_circle_alpha</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-249">SDL::Surface#draw_filled_circle_alpha</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-251">SDL::Surface#draw_aa_circle_alpha</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-255">SDL::Surface#draw_filled_ellipse</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-257">SDL::Surface#draw_aa_ellipse</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-259">SDL::Surface#draw_aa_filled_ellipse</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-261">SDL::Surface#draw_ellipse_alpha</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-263">SDL::Surface#draw_filled_ellipse_alpha</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-265">SDL::Surface#draw_aa_ellipse_alpha</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-267">SDL::Surface#draw_bezier</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-269">SDL::Surface#draw_aa_bezier</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-271">SDL::Surface#draw_bezier_alpha</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-273">SDL::Surface#draw_aa_bezier_alpha</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-275">SDL::Surface#transform_surface</a></li>
</ul>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a>, if the surface couldn't be locked.</p>
<ul>
<li><p>NOTES</p>
<p>If <!-- Reference, RDLabel "SDL::Surface#auto_lock?" doesn't exist --><em class="label-not-found">SDL::Surface#auto_lock?</em><!-- Reference end --> returns true, you need not call this method
because Ruby/SDL automatically locks surface when you call methods that 
need locking.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-116">SDL::Surface#unlock</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-117">SDL::Surface#must_lock?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-205">SDL.auto_lock_on</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-209">SDL.auto_lock_off</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-213">SDL.auto_lock=</a></p></li>
</ul></dd>
<dt><a name="label-116" id="label-116"><code>SDL::Surface#unlock</code></a></dt><!-- RDLabel: "SDL::Surface#unlock" -->
<dd>
<p>Surfaces that were previously locked using <!-- Reference, RDLabel "SDL::Surfaces#lock" doesn't exist --><em class="label-not-found">SDL::Surfaces#lock</em><!-- Reference end --> must be unlocked with <!-- Reference, RDLabel "SDL::Surfaces#unlock" doesn't exist --><em class="label-not-found">SDL::Surfaces#unlock</em><!-- Reference end -->.
Surfaces should be unlocked as soon as possible.</p>
<p>It should be noted that since 1.1.8, surface locks are recursive.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">SDL::Surface#lock</a></p></li>
</ul></dd>
<dt><a name="label-117" id="label-117"><code>SDL::Surface#must_lock?</code></a></dt><!-- RDLabel: "SDL::Surface#must_lock?" -->
<dt><a name="label-118" id="label-118"><code>SDL::Surface#mustLock?</code></a></dt><!-- RDLabel: "SDL::Surface#mustLock?" -->
<dd>
Returns true if <var>self</var> require locking for direct access to the pixels, 
otherwise returns false.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">SDL::Surface#lock</a></p></li>
</ul></dd>
<dt><a name="label-119" id="label-119"><code>SDL::Surface.load_bmp(<var>filename</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.load_bmp" -->
<dt><a name="label-120" id="label-120"><code>SDL::Surface.loadBMP(<var>filename</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.loadBMP" -->
<dd>
<p>Loads a surface from a named Windows BMP file.</p>
<p>Returns the new <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a> object.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-123">SDL::Surface#save_bmp</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-187">SDL::Surface.load</a></p></li>
</ul></dd>
<dt><a name="label-121" id="label-121"><code>SDL::Surface.load_bmp_from_io(<var>io</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.load_bmp_from_io" -->
<dt><a name="label-122" id="label-122"><code>SDL::Surface.loadBMPFromIO(<var>io</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.loadBMPFromIO" -->
<dd>
<p>Loads a surface from a ruby's IO object.
IO object means the ruby object that has following methods:</p>
<ul>
<li>read</li>
<li>rewind</li>
<li>tell</li>
</ul>
<p>For example, instances of IO class, StringIO class and Zlib::GZipReader class
are IO object.</p>
<p>Returns the new <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a> object.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-119">SDL::Surface.load_bmp</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-188">SDL::Surface.load_from_io</a></p></li>
</ul></dd>
<dt><a name="label-123" id="label-123"><code>SDL::Surface#save_bmp(<var>filename</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#save_bmp" -->
<dt><a name="label-124" id="label-124"><code>SDL::Surface#saveBMP(<var>filename</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#saveBMP" -->
<dd>
<p>Saves the <var>self</var> surface as a Windows BMP file named <var>filename</var>.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-119">SDL::Surface.load_bmp</a></p></li>
</ul></dd>
<dt><a name="label-125" id="label-125"><code>SDL::Surface#destroy</code></a></dt><!-- RDLabel: "SDL::Surface#destroy" -->
<dd>
Frees the resource used by a Surface.
If a surface is destroyed, all operations are forbidden.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-108">SDL::Surface.new</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-114">SDL::Surface.new_from</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-126">SDL::Surface#destroyed?</a></p></li>
</ul></dd>
<dt><a name="label-126" id="label-126"><code>SDL::Surface#destroyed?</code></a></dt><!-- RDLabel: "SDL::Surface#destroyed?" -->
<dd>
Returns whether the surface is destroyed by
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-125">SDL::Surface#destroy</a>.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-125">SDL::Surface#destroy</a></p></li>
</ul></dd>
<dt><a name="label-127" id="label-127"><code>SDL::Surface#set_color_key(<var>flag</var>,<var>key</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#set_color_key" -->
<dt><a name="label-128" id="label-128"><code>SDL::Surface#setColorKey(<var>flag</var>,<var>key</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#setColorKey" -->
<dd>
<p>Sets the color key (transparent pixel) in a blittable <var>surface|Surface</var>
and enables or disables RLE blit acceleration.
<var>key</var> parameter should be pixel value or color array.</p>
<p>RLE acceleration can substantially speed up blitting 
of images with large horizontal runs of transparent
pixels (i.e., pixels that match the <var>key</var> value). 
The key must be of the same pixel format as the surface,
if pixel value is used.
In that case, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-94">SDL::PixelFormat#map_rgb</a>
is often useful for obtaining an acceptable value.</p>
<p>If <var>flag</var> is SDL_SRCCOLORKEY then <var>key</var> is the transparent pixel color in the source image of a blit.</p>
<p>If <var>flag</var> is OR'd with SDL::RLEACCEL then the surface will 
be draw using RLE acceleration when drawn with 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-142">SDL::Surface.blit</a>. The surface will actually be encoded 
for RLE acceleration the first time <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-142">SDL::Surface.blit</a>
or <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-145">SDL::Surface#display_format</a> is called on the surface.</p>
<p>If <var>flag</var> is 0, this function clears any current color key.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-142">SDL::Surface.blit</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-145">SDL::Surface#display_format</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-92">SDL::Surface#map_rgb</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-129">SDL::Surface#set_alpha</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-180">SDL::Surface#colorkey</a></p></li>
</ul></dd>
<dt><a name="label-129" id="label-129"><code>SDL::Surface#set_alpha(<var>flags</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#set_alpha" -->
<dt><a name="label-130" id="label-130"><code>SDL::Surface#setAlpha(<var>flags</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#setAlpha" -->
<dd>
<p>This method is used for setting the per-surface alpha value and/or enabling and disabling alpha
blending.</p>
<p>The surface parameter specifies which surface whose 
alpha attributes you wish to adjust. <var>flags</var> is used to
specify whether alpha blending should be used (SDL::SRCALPHA)</p>
<pre>and whether the surface should use RLE</pre>
<p>acceleration for blitting (SDL::RLEACCEL). <var>flags</var> 
can be an OR'd combination of these two options, one of
these options or 0. If SDL::SRCALPHA is not passed as a flag</p>
<pre>then all alpha information is ignored when</pre>
<p>blitting the surface. The alpha parameter is the 
per-surface alpha value; a surface need not have an
alpha channel to use per-surface alpha and blitting can still be accelerated with SDL::RLEACCEL.</p>
<p>Alpha effects surface blitting in the following ways:</p>
<dl>
<dt><a name="label-131" id="label-131">RGBA-&gt;RGB with SDL::SRCALPHA</a></dt><!-- RDLabel: "RGBA->RGB with SDL::SRCALPHA" -->
<dd>
The source is alpha-blended with the destination, using the alpha channel.
SDL_SRCCOLORKEY and the per-surface alpha are ignored.
</dd>
<dt><a name="label-132" id="label-132">RGBA-&gt;RGB without SDL::SRCALPHA</a></dt><!-- RDLabel: "RGBA->RGB without SDL::SRCALPHA" -->
<dd>
The RGB data is copied from the source. The source alpha channel and the per-surface
alpha value are ignored.
</dd>
<dt><a name="label-133" id="label-133">RGB-&gt;RGBA with SDL::SRCALPHA</a></dt><!-- RDLabel: "RGB->RGBA with SDL::SRCALPHA" -->
<dd>
The source is alpha-blended with the destination using the per-surface alpha value. If
SDL::SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied. The
alpha channel of the copied pixels is set to opaque.
</dd>
<dt><a name="label-134" id="label-134">RGB-&gt;RGBA without SDL::SRCALPHA</a></dt><!-- RDLabel: "RGB->RGBA without SDL::SRCALPHA" -->
<dd>
The RGB data is copied from the source and the alpha value of the copied pixels is set to
opaque. If SDL::SRCCOLORKEY is set, only the pixels not matching the colorkey value are
copied.   
</dd>
<dt><a name="label-135" id="label-135">RGBA-&gt;RGBA with  SDL::SRCALPHA</a></dt><!-- RDLabel: "RGBA->RGBA with  SDL::SRCALPHA" -->
<dd>
The source is alpha-blended with the destination using the source alpha channel. The     
alpha channel in the destination surface is left untouched. SDL::SRCCOLORKEY is ignored.  
</dd>
</dl>
<p>RGBA-&gt;RGBA witout SDL::SRCALPHA</p>
<pre>The RGBA data is copied to the destination surface. If SDL::SRCCOLORKEY is set, only the  
pixels not matching the colorkey value are copied.</pre>
<p>RGB-&gt;RGB with SDL_SRCALPHA</p>
<pre>The source is alpha-blended with the destination using the per-surface alpha value. If
SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.</pre>
<p>RGB-&gt;RGB witout SDL_SRCALPHA</p>
<pre>The RGB data is copied from the source. If SDL_SRCCOLORKEY is set, only the pixels not
matching the colorkey value are copied.</pre>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>NOTES</p>
<p>Note: This method and the semantics of SDL alpha blending have changed since version 1.1.4. Up
until version 1.1.5, an alpha value of 0 was considered opaque and a value of 255 was considered
transparent. This has now been inverted: 0 (SDL::ALPHA_TRANSPARENT) is now considered transparent and
255 (SDL::ALPHA_OPAQUE) is now considered opaque.
The per-surface alpha value of 128 is considered a special case and is optimised, so it's much
faster than other per-surface values.</p>
<p>Note that RGBA-&gt;RGBA blits (with SDL::SRCALPHA set) keep the alpha of the destination surface.
This means that you cannot compose two arbitrary RGBA surfaces this way and get the result you would
expect from "overlaying" them; the destination alpha will work as a mask.</p>
<p>Also note that per-pixel and per-surface alpha cannot be combined; the per-pixel alpha is always used
if available</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-96">SDL::Surface#map_rgba</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-104">SDL::Surface#get_rgba</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-145">SDL::Surface#display_format</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-142">SDL::Surface.blit</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-181">SDL::Surface#alpha</a></p></li>
</ul></dd>
<dt><a name="label-136" id="label-136"><code>SDL::Surface#set_clip_rect(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#set_clip_rect" -->
<dt><a name="label-137" id="label-137"><code>SDL::Surface#setClipRect(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#setClipRect" -->
<dd>
<p>Sets the clipping rectangle for a surface. 
When this surface is the destination of a blit, only the area
within the clip rectangle will be drawn into.</p>
<p>The rectangle pointed to by rect will be clipped to the edges of the surface so that the clip rectangle
for a surface can never fall outside the edges of the surface.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-138">SDL::Surface#get_clip_rect</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-142">SDL::Surface.blit</a></p></li>
</ul></dd>
<dt><a name="label-138" id="label-138"><code>SDL::Surface#get_clip_rect</code></a></dt><!-- RDLabel: "SDL::Surface#get_clip_rect" -->
<dt><a name="label-139" id="label-139"><code>SDL::Surface#getClipRect</code></a></dt><!-- RDLabel: "SDL::Surface#getClipRect" -->
<dd>
<p>Gets the clipping rectangle for a surface. When this surface is the destination of a blit, only the area
within the clip rectangle is drawn into.</p>
<p>Returns 4 element array as [x, y, w, h].</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-136">SDL::Surface#set_clip_rect</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-142">SDL::Surface.blit</a></p></li>
</ul></dd>
<dt><a name="label-140" id="label-140"><code>SDL.blit_surface(<var>src</var>,<var>srcX</var>,<var>srcY</var>,<var>srcW</var>,<var>srcH</var>,<var>dst</var>,<var>dstX</var>,<var>dstY</var>)</code></a></dt><!-- RDLabel: "SDL.blit_surface" -->
<dt><a name="label-141" id="label-141"><code>SDL.blitSurface(<var>src</var>,<var>srcX</var>,<var>srcY</var>,<var>srcW</var>,<var>srcH</var>,<var>dst</var>,<var>dstX</var>,<var>dstY</var>)</code></a></dt><!-- RDLabel: "SDL.blitSurface" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-142">SDL::Surface.blit</a> instead.</dd>
<dt><a name="label-142" id="label-142"><code>SDL::Surface.blit(<var>src</var>,<var>srcX</var>,<var>srcY</var>,<var>srcW</var>,<var>srcH</var>,<var>dst</var>,<var>dstX</var>,<var>dstY</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.blit" -->
<dd>
<p>This performs a fast blit from the source surface to the destination surface.</p>
<p><var>src</var> is source surface, <var>dst</var> is destination surface, 
<var>srcX</var>, <var>srcY</var>, <var>srcW</var>, <var>srcH</var> is source rectangle, 
and <var>dstX</var>, <var>dstY</var> is destination point.
If all of <var>srcX</var>, <var>srcY</var>, <var>srcW</var>, <var>srcH</var> is zero, the entire surface is copied.</p>
<p>The blit function should not be called on a locked surface.</p>
<p>The results of blitting operations vary greatly depending on whether SDL::SRCAPLHA is set or not. See 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-129">SDL::Surface#set_alpha</a> for an explaination of how this 
affects your results. Colorkeying and alpha attributes also
interact with surface blitting, as the following pseudo-code should hopefully explain.</p>
<pre>if source surface has SDL::SRCALPHA set 
  if source surface has alpha channel (that is, Amask != 0)
    blit using per-pixel alpha, ignoring any colour key
  elsif source surface has SDL::SRCCOLORKEY set
    blit using the colour key AND the per-surface alpha value
  else
    blit using the per-surface alpha value
  end
elsif source surface has SDL::SRCCOLORKEY se
  blit using the colour key
else
  ordinary opaque rectangular blit
end</pre>
<p>If the blit is successful, it returns 0.</p>
<p>If either of the surfaces were in video memory, 
and the blit raises SDL::Surface::VideoMemoryLost,
the video memory was lost, so it
should be reloaded with artwork and re-blitted.</p>
<p>This happens under DirectX 5.0 when the system switches away from your fullscreen application. Locking
the surface will also fail until you have access to the video memory again.</p></dd>
<dt><a name="label-143" id="label-143"><code>SDL::Surface#fill_rect(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#fill_rect" -->
<dt><a name="label-144" id="label-144"><code>SDL::Surface#fillRect(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#fillRect" -->
<dd>
<p>This method performs a fast fill of the given rectangle with <var>color</var>.</p>
<p>Please see <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-35">Color, PixelFormat and Pixel value</a> to specify <var>color</var>.
If the color value contains an alpha value then the destination is simply "filled"
with that alpha information, no blending takes place.</p>
<p>If there is a clip rectangle set on the destination (set via <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-136">SDL::Surface#set_clip_rect</a>)
then this function will clip based on the intersection of the clip rectangle 
and the dstrect rectangle and the dstrect rectangle
will be modified to represent the area actually filled.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-92">SDL::Surface#map_rgb</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-96">SDL::Surface#map_rgba</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-142">SDL::Surface.blit</a></p></li>
</ul></dd>
<dt><a name="label-145" id="label-145"><code>SDL::Surface#display_format</code></a></dt><!-- RDLabel: "SDL::Surface#display_format" -->
<dt><a name="label-146" id="label-146"><code>SDL::Surface#displayFormat</code></a></dt><!-- RDLabel: "SDL::Surface#displayFormat" -->
<dd>
<p>This method copies <var>self</var> to a new surface of the pixel format and colors of the video
framebuffer, suitable for fast blitting onto the display surface.</p>
<p>If you want to take advantage of hardware colorkey or alpha blit acceleration, you should set the
colorkey and alpha value before calling this function.</p>
<p>If you want an alpha channel, see <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-147">SDL::Surface#display_format_alpha</a>.</p>
<p>Returns converted surface object.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> if the conversion fails or runs out of memory.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-147">SDL::Surface#display_format_alpha</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-129">SDL::Surface#set_alpha</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-127">SDL::Surface#set_color_key</a></p></li>
</ul></dd>
<dt><a name="label-147" id="label-147"><code>SDL::Surface#display_format_alpha</code></a></dt><!-- RDLabel: "SDL::Surface#display_format_alpha" -->
<dt><a name="label-148" id="label-148"><code>SDL::Surface#displaFormatAlpha</code></a></dt><!-- RDLabel: "SDL::Surface#displaFormatAlpha" -->
<dd>
<p>This method copies <var>self</var> to a new surface of the pixel format and colors of the video
framebuffer plus an alpha channel, suitable for fast blitting onto the display surface.</p>
<p>If you want to take advantage of hardware colorkey or alpha blit acceleration, you should set the
colorkey and alpha value before calling this function.</p>
<p>This function can be used to convert a colourkey to an alpha channel, if the SDL::SRCCOLORKEY flag is set
on the surface. The generated surface will then be transparent (alpha=0) where the pixels match the
colourkey, and opaque (alpha=255) elsewhere.</p>
<p>Returns converted surface object.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> if the conversion fails or runs out of memory.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-145">SDL::Surface#display_format</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-129">SDL::Surface#set_alpha</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-127">SDL::Surface#set_color_key</a></p></li>
</ul></dd>
<dt><a name="label-149" id="label-149"><code>SDL::Surface#flags</code></a></dt><!-- RDLabel: "SDL::Surface#flags" -->
<dd>
<p>Returns the surface flags.
The following are supported:</p>
<dl>
<dt><a name="label-150" id="label-150">SDL::SWSURFACE</a></dt><!-- RDLabel: "SDL::SWSURFACE" -->
<dd>
Surface is stored in system memory
</dd>
<dt><a name="label-151" id="label-151">SDL::HWSURFACE</a></dt><!-- RDLabel: "SDL::HWSURFACE" -->
<dd>
Surface is stored in video memory
</dd>
<dt><a name="label-152" id="label-152">SDL::ASYNCBLIT</a></dt><!-- RDLabel: "SDL::ASYNCBLIT" -->
<dd>
Surface uses asynchronous blits if possible
</dd>
<dt><a name="label-153" id="label-153">SDL::ANYFORMAT</a></dt><!-- RDLabel: "SDL::ANYFORMAT" -->
<dd>
Allows any pixel-format (Display surface)
</dd>
<dt><a name="label-154" id="label-154">SDL::HWPALETTE</a></dt><!-- RDLabel: "SDL::HWPALETTE" -->
<dd>
Surface has exclusive palette
</dd>
<dt><a name="label-155" id="label-155">SDL::DOUBLEBUF</a></dt><!-- RDLabel: "SDL::DOUBLEBUF" -->
<dd>
Surface is double buffered (Display surface)
</dd>
<dt><a name="label-156" id="label-156">SDL::FULLSCREEN</a></dt><!-- RDLabel: "SDL::FULLSCREEN" -->
<dd>
Surface is full screen (Display Surface)
</dd>
<dt><a name="label-157" id="label-157">SDL::OPENGL</a></dt><!-- RDLabel: "SDL::OPENGL" -->
<dd>
Surface has an OpenGL context (Display Surface)
</dd>
<dt><a name="label-158" id="label-158">SDL::OPENGLBLIT</a></dt><!-- RDLabel: "SDL::OPENGLBLIT" -->
<dd>
Surface supports OpenGL blitting (Display Surface)
</dd>
<dt><a name="label-159" id="label-159">SDL::RESIZABLE</a></dt><!-- RDLabel: "SDL::RESIZABLE" -->
<dd>
Surface is resizable (Display Surface)
</dd>
<dt><a name="label-160" id="label-160">SDL::HWACCEL</a></dt><!-- RDLabel: "SDL::HWACCEL" -->
<dd>
Surface blit uses hardware acceleration
</dd>
<dt><a name="label-161" id="label-161">SDL::SRCCOLORKEY</a></dt><!-- RDLabel: "SDL::SRCCOLORKEY" -->
<dd>
Surface use colorkey blitting
</dd>
<dt><a name="label-162" id="label-162">SDL::RLEACCEL</a></dt><!-- RDLabel: "SDL::RLEACCEL" -->
<dd>
Colorkey blitting is accelerated with RLE
</dd>
<dt><a name="label-163" id="label-163">SDL::SRCALPHA</a></dt><!-- RDLabel: "SDL::SRCALPHA" -->
<dd>
Surface blit uses alpha blending
</dd>
</dl>
<p>Returns OR'd compination of above constants.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-21">SDL::Screen</a></p></li>
</ul></dd>
<dt><a name="label-164" id="label-164"><code>SDL::Surface#format</code></a></dt><!-- RDLabel: "SDL::Surface#format" -->
<dd>
Returns <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-34">SDL::PixelFormat</a> object.</dd>
<dt><a name="label-165" id="label-165"><code>SDL::Surface#w</code></a></dt><!-- RDLabel: "SDL::Surface#w" -->
<dd>
Returns width of the surface.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-166">SDL::Surface#h</a></p></li>
</ul></dd>
<dt><a name="label-166" id="label-166"><code>SDL::Surface#h</code></a></dt><!-- RDLabel: "SDL::Surface#h" -->
<dd>
Returns height of the surface
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-165">SDL::Surface#w</a></p></li>
</ul></dd>
<dt><a name="label-167" id="label-167"><code>SDL::Surface#pixels</code></a></dt><!-- RDLabel: "SDL::Surface#pixels" -->
<dd>
Returns pixel data as String object.
Examine <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-149">SDL::Surface#flags</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-186">SDL::Surface#pitch</a> and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-164">SDL::Surface#format</a>
to analyze pixel data.
<ul>
<li><p>NOTES</p>
<p>You must <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">lock</a> surface before calling this method.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-149">SDL::Surface#flags</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-186">SDL::Surface#pitch</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-164">SDL::Surface#format</a></p></li>
</ul></dd>
<dt><a name="label-168" id="label-168"><code>SDL::PixelFormat#Rmask</code></a></dt><!-- RDLabel: "SDL::PixelFormat#Rmask" -->
<dd>
Returns binary mask allowing us to isolate red component.</dd>
<dt><a name="label-169" id="label-169"><code>SDL::PixelFormat#Gmask</code></a></dt><!-- RDLabel: "SDL::PixelFormat#Gmask" -->
<dd>
Returns binary mask allowing us to isolate green component.</dd>
<dt><a name="label-170" id="label-170"><code>SDL::PixelFormat#Bmask</code></a></dt><!-- RDLabel: "SDL::PixelFormat#Bmask" -->
<dd>
Returns binary mask allowing us to isolate blue component.</dd>
<dt><a name="label-171" id="label-171"><code>SDL::PixelFormat#Amask</code></a></dt><!-- RDLabel: "SDL::PixelFormat#Amask" -->
<dd>
Returns binary mask allowing us to isolate alpha component.</dd>
<dt><a name="label-172" id="label-172"><code>SDL::PixelFormat#Rloss</code></a></dt><!-- RDLabel: "SDL::PixelFormat#Rloss" -->
<dd>
Returns the number of bits lost from red component when packing 8-bit color component in a pixel.</dd>
<dt><a name="label-173" id="label-173"><code>SDL::PixelFormat#Gloss</code></a></dt><!-- RDLabel: "SDL::PixelFormat#Gloss" -->
<dd>
Returns the number of bits lost from green component when packing 8-bit color component in a pixel.</dd>
<dt><a name="label-174" id="label-174"><code>SDL::PixelFormat#Bloss</code></a></dt><!-- RDLabel: "SDL::PixelFormat#Bloss" -->
<dd>
Returns the number of bits lost from blue component when packing 8-bit color component in a pixel.</dd>
<dt><a name="label-175" id="label-175"><code>SDL::PixelFormat#Aloss</code></a></dt><!-- RDLabel: "SDL::PixelFormat#Aloss" -->
<dd>
Returns the number of bits lost from alpha component when packing 8-bit color component in a pixel.</dd>
<dt><a name="label-176" id="label-176"><code>SDL::PixelFormat#Rshift</code></a></dt><!-- RDLabel: "SDL::PixelFormat#Rshift" -->
<dd>
Returns the number of bits to the right of red component in the pixel value.</dd>
<dt><a name="label-177" id="label-177"><code>SDL::PixelFormat#Gshift</code></a></dt><!-- RDLabel: "SDL::PixelFormat#Gshift" -->
<dd>
Returns the number of bits to the right of green component in the pixel value.</dd>
<dt><a name="label-178" id="label-178"><code>SDL::PixelFormat#Bshift</code></a></dt><!-- RDLabel: "SDL::PixelFormat#Bshift" -->
<dd>
Returns the number of bits to the right of blue component in the pixel value</dd>
<dt><a name="label-179" id="label-179"><code>SDL::PixelFormat#Ashift</code></a></dt><!-- RDLabel: "SDL::PixelFormat#Ashift" -->
<dd>
Returns the number of bits to the right of alpha component in the pixel value.</dd>
<dt><a name="label-180" id="label-180"><code>SDL::Surface#colorkey</code></a></dt><!-- RDLabel: "SDL::Surface#colorkey" -->
<dd>
Returns pixel value of transparent pixels.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-127">SDL::Surface#set_color_key</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-35">Color, PixelFormat and Pixel value</a></p></li>
</ul></dd>
<dt><a name="label-181" id="label-181"><code>SDL::Surface#alpha</code></a></dt><!-- RDLabel: "SDL::Surface#alpha" -->
<dd>
Returns surface alpha value from 0(transparent) to 255(opaque).
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-129">SDL::Surface#set_alpha</a></p></li>
</ul></dd>
<dt><a name="label-182" id="label-182"><code>SDL::PixelFormat#colorkey</code></a></dt><!-- RDLabel: "SDL::PixelFormat#colorkey" -->
<dd>
Returns pixel value of transparent pixels.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-127">SDL::Surface#set_color_key</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-35">Color, PixelFormat and Pixel value</a></p></li>
</ul></dd>
<dt><a name="label-183" id="label-183"><code>SDL::PixelFormat#alpha</code></a></dt><!-- RDLabel: "SDL::PixelFormat#alpha" -->
<dd>
Returns surface alpha value from 0(transparent) to 255(opaque).
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-129">SDL::Surface#set_alpha</a></p></li>
</ul></dd>
<dt><a name="label-184" id="label-184"><code>SDL::Surface#bpp</code></a></dt><!-- RDLabel: "SDL::Surface#bpp" -->
<dd>
This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-185">SDL::PixelFormat#bpp</a> instead.</dd>
<dt><a name="label-185" id="label-185"><code>SDL::PixelFormat#bpp</code></a></dt><!-- RDLabel: "SDL::PixelFormat#bpp" -->
<dd>
Returns the number of bits used to represent each pixel in a surface.
Usually 8, 16, 24 or 32.</dd>
<dt><a name="label-186" id="label-186"><code>SDL::Surface#pitch</code></a></dt><!-- RDLabel: "SDL::Surface#pitch" -->
<dd>
<p>Returns the number of bytes used for each scanline in a surface.</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-167">SDL::Surface#pixels</a> returns pitch*<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-166">SDL::Surface#h</a> bytes string.
Normally, this values is equal to <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-184">SDL::Surface#bpp</a>*<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-165">SDL::Surface#w</a>/8, but
in some case the value is more than bpp*w/8 because
some pudding bytes are used.</p></dd>
<dt><a name="label-187" id="label-187"><code>SDL::Surface.load(<var>filename</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.load" -->
<dd>
<p>Load image into an surface and returns <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">surface</a> object.
If image format supports transparent color, colorkey is set into new surfafe.</p>
<p>Supoorted formats are
BMP, PNM (PPM/PGM/PBM), XPM,
XCF, PCX, GIF, JPEG, TIFF, TGA, PNG and LBM.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>You need SDL_image to use this method.</p></dd>
<dt><a name="label-188" id="label-188"><code>SDL::Surface.load_from_io(<var>io</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.load_from_io" -->
<dt><a name="label-189" id="label-189"><code>SDL::Surface.loadFromIO(<var>io</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.loadFromIO" -->
<dd>
<p>Loads a surface from a ruby's IO object.
IO object means the ruby object that has following methods:</p>
<ul>
<li>read</li>
<li>rewind</li>
<li>tell</li>
</ul>
<p>If image format supports transparent color, colorkey is set into new surfafe.
Supoorted formats are
BMP, PNM (PPM/PGM/PBM), XPM,
XCF, PCX, GIF, JPEG, TIFF, TGA, PNG and LBM.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-187">SDL::Surface.load</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-121">SDL::Surface.load_bmp_from_io</a></p></li>
</ul></dd>
<dt><a name="label-190" id="label-190"><code>SDL::Surface#put_pixel(<var>x</var>, <var>y</var>, <var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#put_pixel" -->
<dt><a name="label-191" id="label-191"><code>SDL::Surface#putPixel(<var>x</var>, <var>y</var>, <var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#putPixel" -->
<dt><a name="label-192" id="label-192"><code>SDL::Surface#[<var>x</var>, <var>y</var>] = <var>color</var></code></a></dt><!-- RDLabel: "SDL::Surface#[]=" -->
<dd>
<p>Writes <var>color</var> pixel at (<var>x</var>, <var>y</var>).</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-193">SDL::Surface#get_pixel</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-35">Color, PixelFormat and Pixel value</a></p></li>
</ul></dd>
<dt><a name="label-193" id="label-193"><code>SDL::Surface#get_pixel(<var>x</var>, <var>y</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#get_pixel" -->
<dt><a name="label-194" id="label-194"><code>SDL::Surface#getPixel(<var>x</var>, <var>y</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#getPixel" -->
<dt><a name="label-195" id="label-195"><code>SDL::Surface#[<var>x</var>, <var>y</var>]</code></a></dt><!-- RDLabel: "SDL::Surface#[]" -->
<dd>
<p>Returns pixel value at (<var>x</var>, <var>y</var>).</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-190">SDL::Surface#put_pixel</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-35">Color, PixelFormat and Pixel value</a></p></li>
</ul></dd>
<dt><a name="label-196" id="label-196"><code>SDL::Surface#put(<var>src</var>, <var>x</var>, <var>y</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#put" -->
<dd>
<p>Performs a fast blit from entire <var>src</var> surface to <var>self</var> at (<var>x</var>, <var>y</var>).</p>
<p>This means:</p>
<pre>SDL::Surface.blit(src, 0, 0, src.w, src.h, self, x, y)</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-142">SDL::Surface.blit</a></p></li>
</ul></dd>
<dt><a name="label-197" id="label-197"><code>SDL::Surface#copy_rect(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#copy_rect" -->
<dt><a name="label-198" id="label-198"><code>SDL::Surface#copyRect(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#copyRect" -->
<dd>
<p>Copies a (<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>) rectangle from <var>self</var> and return new <var>surface|Surface</var> object.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>NOTES</p>
<p>This method call <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-142">SDL::Surface.blit</a> internally, therefore you must unlock surface before calling it.</p></li>
</ul></dd>
<dt><a name="label-199" id="label-199"><code>SDL.auto_lock?</code></a></dt><!-- RDLabel: "SDL.auto_lock?" -->
<dt><a name="label-200" id="label-200"><code>SDL.autoLock?</code></a></dt><!-- RDLabel: "SDL.autoLock?" -->
<dt><a name="label-201" id="label-201"><code>SDL.auto_lock</code></a></dt><!-- RDLabel: "SDL.auto_lock" -->
<dt><a name="label-202" id="label-202"><code>SDL.autoLock</code></a></dt><!-- RDLabel: "SDL.autoLock" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-203">SDL::Surface.auto_lock?</a> instead.</p>
<p>You need SGE to use this method.</p></dd>
<dt><a name="label-203" id="label-203"><code>SDL::Surface.auto_lock?</code></a></dt><!-- RDLabel: "SDL::Surface.auto_lock?" -->
<dt><a name="label-204" id="label-204"><code>SDL::Surface.autoLock?</code></a></dt><!-- RDLabel: "SDL::Surface.autoLock?" -->
<dd>
<p>Returns true if surface is automatically <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">locked</a>
when necessary, otherwise returns false.</p>
<p>Default is ON(true).</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">SDL::Surface#lock</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-116">SDL::Surface#unlock</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-207">SDL::Surface.auto_lock_on</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-211">SDL::Surface.auto_lock_off</a></p></li>
</ul></dd>
<dt><a name="label-205" id="label-205"><code>SDL.auto_lock_on</code></a></dt><!-- RDLabel: "SDL.auto_lock_on" -->
<dt><a name="label-206" id="label-206"><code>SDL.autoLockON</code></a></dt><!-- RDLabel: "SDL.autoLockON" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-207">SDL::Surface.auto_lock_on</a> instead.</p>
<p>You need SGE to use this method.</p></dd>
<dt><a name="label-207" id="label-207"><code>SDL::Surface.auto_lock_on</code></a></dt><!-- RDLabel: "SDL::Surface.auto_lock_on" -->
<dt><a name="label-208" id="label-208"><code>SDL::Surface.autoLockON</code></a></dt><!-- RDLabel: "SDL::Surface.autoLockON" -->
<dd>
<p>Enables auto surface locking. </p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">SDL::Surface#lock</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-203">SDL::Surface.auto_lock?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-211">SDL::Surface.auto_lock_off</a></p></li>
</ul></dd>
<dt><a name="label-209" id="label-209"><code>SDL.auto_lock_off</code></a></dt><!-- RDLabel: "SDL.auto_lock_off" -->
<dt><a name="label-210" id="label-210"><code>SDL.autoLockOFF</code></a></dt><!-- RDLabel: "SDL.autoLockOFF" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-211">SDL::Surface.auto_lock_off</a> instead.</p>
<p>You need SGE to use this method.</p></dd>
<dt><a name="label-211" id="label-211"><code>SDL::Surface.auto_lock_off</code></a></dt><!-- RDLabel: "SDL::Surface.auto_lock_off" -->
<dt><a name="label-212" id="label-212"><code>SDL::Surface.autoLockOFF</code></a></dt><!-- RDLabel: "SDL::Surface.autoLockOFF" -->
<dd>
<p>Disables auto surface locking. </p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">SDL::Surface#lock</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-203">SDL::Surface.auto_lock?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-207">SDL::Surface.auto_lock_on</a></p></li>
</ul></dd>
<dt><a name="label-213" id="label-213"><code>SDL.auto_lock=(<var>locking</var>)</code></a></dt><!-- RDLabel: "SDL.auto_lock=" -->
<dt><a name="label-214" id="label-214"><code>SDL.autoLock=(<var>locking</var>)</code></a></dt><!-- RDLabel: "SDL.autoLock=" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-207">SDL::Surface.auto_lock_on</a> instead.</p>
<p>Enables or disables auto surface locking.
'SDL.auto_lock = true' is same as <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-207">SDL::Surface.auto_lock_on</a>
and 'SDL.auto_lock = false' is same as 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-211">SDL::Surface.auto_lock_off</a>.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">SDL::Surface#lock</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-205">SDL.auto_lock_on</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-209">SDL.auto_lock_off</a></p></li>
</ul></dd>
<dt><a name="label-215" id="label-215"><code>SDL.transform(<var>src</var>,<var>dst</var>,<var>angle</var>,<var>xscale</var>,<var>yscale</var>,<var>px</var>,<var>py</var>,<var>qx</var>,<var>qy</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL.transform" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-216">SDL::Surface.transform_draw</a> instead.</p>
<p>You need SGE to use this method.</p></dd>
<dt><a name="label-216" id="label-216"><code>SDL::Surface.transform_draw(<var>src</var>,<var>dst</var>,<var>angle</var>,<var>xscale</var>,<var>yscale</var>,<var>px</var>,<var>py</var>,<var>qx</var>,<var>qy</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.transform_draw" -->
<dd>
<p>Draws a rotated and scaled version of <var>src</var> on <var>dest</var>.
<var>angle</var> the rotation angle in degrees, 
<var>xscale</var> and <var>yscale</var> are x and y scaling factor,
(<var>px</var>, <var>py</var>) is the pivot point to rotate around in the <var>src</var>,
and (<var>qx</var>, <var>qy</var>) is the destination point on <var>dst</var> surface.</p>
<p><var>flags</var> is OR'd combination of follwing values:</p>
<dl>
<dt><a name="label-217" id="label-217">0</a></dt><!-- RDLabel: "0" -->
<dd>
Default
</dd>
<dt><a name="label-218" id="label-218">SDL::Surface::TRANSFORM_SAFE</a></dt><!-- RDLabel: "SDL::Surface::TRANSFORM_SAFE" -->
<dd>
Don't asume that the <var>src</var> and <var>dst</var> surfaces has
the same pixel format. This is the default when the two
surfaces don't have the same BPP. This is slower but will
render wierd pixel formats right.
</dd>
<dt><a name="label-219" id="label-219">SDL::Surface::TRANSFORM_AA</a></dt><!-- RDLabel: "SDL::Surface::TRANSFORM_AA" -->
<dd>
Use the interpolating renderer. Much slower but
can look better.
</dd>
<dt><a name="label-220" id="label-220">SDL::Surface::TRANSFORM_TMAP</a></dt><!-- RDLabel: "SDL::Surface::TRANSFORM_TMAP" -->
<dd>
Use texture mapping. This is a bit faster but
the result isn't as nice as in the normal mode. This mode
will also ignore the px/py coordinates and the other flags.
</dd>
</dl>
<p>You need SGE to use this method.</p>
<ul>
<li><p>NOTES</p>
<p>To get optimal performance PLEASE make sure that the two
surfaces has the same pixel format (color depth) and doesn't use
24-bpp.</p>
<p>You can set source and destination clipping rectangles with
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-136">SDL::Surface#set_clip_rect</a>.</p>
<p>If you use the interpolated renderer the image will be
clipped 1 pixel in hight and width (to optimize the
performance).</p>
<p>If you want to transform a 32-bpp RGBA (alpha) surface with
the interpolated renderer, please use the 
SDL::TRANSFORM_SAFE flag.</p>
<p>This function will not do any alpha blending, but it will
try to preserve the alpha channel. If you want to rotate and
alpha blend the result, please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-223">SDL::Surface.transform_blit</a>
and then blit that surface to its destination.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-223">SDL::Surface.transform_blit</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-275">SDL::Surface#transform_surface</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-108">SDL::Surface.new</a></p></li>
</ul></dd>
<dt><a name="label-221" id="label-221"><code>SDL.transform_blit(<var>src</var>,<var>dst</var>,<var>angle</var>,<var>xscale</var>,<var>yscale</var>,<var>px</var>,<var>py</var>,<var>qx</var>,<var>qy</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL.transform_blit" -->
<dt><a name="label-222" id="label-222"><code>SDL.transformBlit(<var>src</var>,<var>dst</var>,<var>angle</var>,<var>xscale</var>,<var>yscale</var>,<var>px</var>,<var>py</var>,<var>qx</var>,<var>qy</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL.transformBlit" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-223">SDL::Surface.transform_blit</a> instead.</p>
<p>You need SGE to use this method.</p></dd>
<dt><a name="label-223" id="label-223"><code>SDL::Surface.transform_blit(<var>src</var>,<var>dst</var>,<var>angle</var>,<var>xscale</var>,<var>yscale</var>,<var>px</var>,<var>py</var>,<var>qx</var>,<var>qy</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.transform_blit" -->
<dt><a name="label-224" id="label-224"><code>SDL::Surface.transformBlit(<var>src</var>,<var>dst</var>,<var>angle</var>,<var>xscale</var>,<var>yscale</var>,<var>px</var>,<var>py</var>,<var>qx</var>,<var>qy</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL::Surface.transformBlit" -->
<dd>
<p>Draw a rotated and scaled image. 
This method is same as <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-216">SDL::Surface.transform_draw</a> except
colorkey and blending are enabled. </p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-216">SDL::Surface.transform_draw</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-275">SDL::Surface#transform_surface</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-127">SDL::Surface#set_color_key</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-129">SDL::Surface#set_alpha</a></p></li>
</ul></dd>
<dt><a name="label-225" id="label-225"><code>SDL::Surface#draw_line(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>color</var>, <var>aa</var>=<var>false</var>, <var>alpha</var>=<var>nil</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_line" -->
<dt><a name="label-226" id="label-226"><code>SDL::Surface#drawLine(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>color</var>, <var>aa</var>=<var>false</var>, <var>alpha</var>=<var>nil</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawLine" -->
<dd>
<p>Draws a <var>color</var> line from (<var>x1</var>, <var>y1</var>) to (<var>x2</var>, <var>y2</var>).
If <var>aa</var> is true, draws an antialiased line.
If <var>alpha</var> is integer, draws blended line with alpha value
is <var>alpha</var>. 
If <var>alpha</var> is nil, draws a normal line.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-233">SDL::Surface#draw_rect</a></p></li>
</ul></dd>
<dt><a name="label-227" id="label-227"><code>SDL::Surface#draw_aa_line(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_aa_line" -->
<dt><a name="label-228" id="label-228"><code>SDL::Surface#drawAALine(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawAALine" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-225">SDL::Surface#draw_line</a> instead.</p>
<p>Draws a <var>color</var> antialiased line from (<var>x1</var>, <var>y1</var>) to (<var>x2</var>, <var>y2</var>).</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-225">SDL::Surface#draw_line</a></p></li>
</ul></dd>
<dt><a name="label-229" id="label-229"><code>SDL::Surface#draw_line_alpha(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_line_alpha" -->
<dt><a name="label-230" id="label-230"><code>SDL::Surface#drawLineAlpha(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawLineAlpha" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-225">SDL::Surface#draw_line</a> instead.</p>
<p>Draws a <var>color</var> line from (<var>x1</var>, <var>y1</var>) to (<var>x2</var>, <var>y2</var>)
with blending.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-225">SDL::Surface#draw_line</a></p></li>
</ul></dd>
<dt><a name="label-231" id="label-231"><code>SDL::Surface#draw_aa_line_alpha(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_aa_line_alpha" -->
<dt><a name="label-232" id="label-232"><code>SDL::Surface#drawAALineAlpha(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawAALineAlpha" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-225">SDL::Surface#draw_line</a> instead.</p>
<p>Draws a antialiased <var>color</var> line from 
(<var>x1</var>, <var>y1</var>) to (<var>x2</var>, <var>y2</var>) with blending.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-225">SDL::Surface#draw_line</a></p></li>
</ul></dd>
<dt><a name="label-233" id="label-233"><code>SDL::Surface#draw_rect(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>,<var>color</var>, <var>fill</var>=<var>false</var>, <var>alpha</var>=<var>nil</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_rect" -->
<dt><a name="label-234" id="label-234"><code>SDL::Surface#drawRect(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>,<var>color</var>, <var>fill</var>=<var>false</var>, <var>alpha</var>=<var>nil</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawRect" -->
<dd>
<p>Draws a rectangle with color <var>color</var>. 
Draw a filled rectangle if <var>fill</var> is true,
and a blended rectangle if <var>alpha</var> is integer.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-143">SDL::Surface#fill_rect</a></p></li>
</ul></dd>
<dt><a name="label-235" id="label-235"><code>SDL::Surface#draw_rect_alpha(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_rect_alpha" -->
<dt><a name="label-236" id="label-236"><code>SDL::Surface#drawRectAlpha(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawRectAlpha" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-233">SDL::Surface#draw_rect</a> instead.</p>
<p>Draws a blended rectangle.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-143">SDL::Surface#fill_rect</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-233">SDL::Surface#draw_rect</a></p></li>
</ul></dd>
<dt><a name="label-237" id="label-237"><code>SDL::Surface#draw_filled_rect_alpha(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_filled_rect_alpha" -->
<dt><a name="label-238" id="label-238"><code>SDL::Surface#drawFilledRectAlpha(<var>x</var>,<var>y</var>,<var>w</var>,<var>h</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawFilledRectAlpha" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-233">SDL::Surface#draw_rect</a> instead.</p>
<p>Draws a filled blended rectangle.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-143">SDL::Surface#fill_rect</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-233">SDL::Surface#draw_rect</a></p></li>
</ul></dd>
<dt><a name="label-239" id="label-239"><code>SDL::Surface#draw_circle(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>,<var>fill</var>=<var>false</var>,<var>aa</var>=<var>false</var>,<var>alpha</var>=<var>0</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_circle" -->
<dt><a name="label-240" id="label-240"><code>SDL::Surface#drawCircle(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>,<var>fill</var>=<var>false</var>,<var>aa</var>=<var>false</var>,<var>alpha</var>=<var>0</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawCircle" -->
<dd>
<p>Draws a circle. (<var>x</var>,<var>y</var>) is center, 
<var>r</var> is radius and <var>color</var> is drawing color.
If <var>fill</var> is true, draws a filled circle.
If <var>aa</var> is true, draws an antialiased circle.
If <var>alpha</var> is integer, draws a blended circle.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>NOTES</p>
<p>You cannot draw a filled antialiased blended circle.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a></p></li>
</ul></dd>
<dt><a name="label-241" id="label-241"><code>SDL::Surface#draw_filled_circle(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_filled_circle" -->
<dt><a name="label-242" id="label-242"><code>SDL::Surface#drawFilledCircle(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawFilledCircle" -->
<dd>
<p>This method is obsolete. Please use <!-- Reference, RDLabel "SDL.draw_circle" doesn't exist --><em class="label-not-found">SDL.draw_circle</em><!-- Reference end --> instead.</p>
<p>Draws a filled circle.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-239">SDL::Surface#draw_circle</a></p></li>
</ul></dd>
<dt><a name="label-243" id="label-243"><code>SDL::Surface#draw_aa_circle(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_aa_circle" -->
<dt><a name="label-244" id="label-244"><code>SDL::Surface#drawAACircle(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawAACircle" -->
<dd>
<p>This method is obsolete. Please use <!-- Reference, RDLabel "SDL.draw_circle" doesn't exist --><em class="label-not-found">SDL.draw_circle</em><!-- Reference end --> instead.</p>
<p>Draws an antialiased circle.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-239">SDL::Surface#draw_circle</a></p></li>
</ul></dd>
<dt><a name="label-245" id="label-245"><code>SDL::Surface#draw_aa_filled_circle(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_aa_filled_circle" -->
<dt><a name="label-246" id="label-246"><code>SDL::Surface#drawAAFilledCircle(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawAAFilledCircle" -->
<dd>
<p>This method is obsolete. Please use <!-- Reference, RDLabel "SDL.draw_circle" doesn't exist --><em class="label-not-found">SDL.draw_circle</em><!-- Reference end --> instead.</p>
<p>Draws a filled antialiased circle.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-239">SDL::Surface#draw_circle</a></p></li>
</ul></dd>
<dt><a name="label-247" id="label-247"><code>SDL::Surface#draw_circle_alpha(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_circle_alpha" -->
<dt><a name="label-248" id="label-248"><code>SDL::Surface#drawCircleAlpha(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawCircleAlpha" -->
<dd>
<p>This method is obsolete. Please use <!-- Reference, RDLabel "SDL.draw_circle" doesn't exist --><em class="label-not-found">SDL.draw_circle</em><!-- Reference end --> instead.</p>
<p>Draws blended circle.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-239">SDL::Surface#draw_circle</a></p></li>
</ul></dd>
<dt><a name="label-249" id="label-249"><code>SDL::Surface#draw_filled_circle_alpha(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_filled_circle_alpha" -->
<dt><a name="label-250" id="label-250"><code>SDL::Surface#drawFilledCircleAlpha(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawFilledCircleAlpha" -->
<dd>
<p>This method is obsolete. Please use <!-- Reference, RDLabel "SDL.draw_circle" doesn't exist --><em class="label-not-found">SDL.draw_circle</em><!-- Reference end --> instead.</p>
<p>Draws a filled blended circle.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-239">SDL::Surface#draw_circle</a></p></li>
</ul></dd>
<dt><a name="label-251" id="label-251"><code>SDL::Surface#draw_aa_circle_alpha(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_aa_circle_alpha" -->
<dt><a name="label-252" id="label-252"><code>SDL::Surface#drawAACircleAlpha(<var>x</var>,<var>y</var>,<var>r</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawAACircleAlpha" -->
<dd>
<p>This method is obsolete. Please use <!-- Reference, RDLabel "SDL.draw_circle" doesn't exist --><em class="label-not-found">SDL.draw_circle</em><!-- Reference end --> instead.</p>
<p>Draws an antialiased blended circle</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-239">SDL::Surface#draw_circle</a></p></li>
</ul></dd>
<dt><a name="label-253" id="label-253"><code>SDL::Surface#draw_ellipse(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>, <var>fill</var>=<var>false</var>, <var>aa</var>=<var>false</var>, <var>alpha</var>=<var>nil</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_ellipse" -->
<dt><a name="label-254" id="label-254"><code>SDL::Surface#drawEllipse(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>, <var>fill</var>=<var>false</var>, <var>aa</var>=<var>false</var>, <var>alpha</var>=<var>nil</var>) )</code></a></dt><!-- RDLabel: "SDL::Surface#drawEllipse" -->
<dd>
<p>Draws an ellipse. (<var>x</var>,<var>y</var>) is center, 
<var>rx</var> is x-radius, <var>ry</var> is y-radius
and <var>color</var> is drawing color.
If <var>fill</var> is true, draws a filled ellipse.
If <var>aa</var> is true, draws an antialiased ellipse.
If <var>alpha</var> is integer, draws a blended ellipse.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>NOTES</p>
<p>You cannot draw a filled antialiased blended ellipse.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-239">SDL::Surface#draw_circle</a></p></li>
</ul></dd>
<dt><a name="label-255" id="label-255"><code>SDL::Surface#draw_filled_ellipse(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_filled_ellipse" -->
<dt><a name="label-256" id="label-256"><code>SDL::Surface#drawFilledEllipse(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawFilledEllipse" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a> instead.</p>
<p>Draws a filled ellipse.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a></p></li>
</ul></dd>
<dt><a name="label-257" id="label-257"><code>SDL::Surface#draw_aa_ellipse(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_aa_ellipse" -->
<dt><a name="label-258" id="label-258"><code>SDL::Surface#drawAAEllipse(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawAAEllipse" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a> instead.</p>
<p>Draws an antialiased ellipse.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a></p></li>
</ul></dd>
<dt><a name="label-259" id="label-259"><code>SDL::Surface#draw_aa_filled_ellipse(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_aa_filled_ellipse" -->
<dt><a name="label-260" id="label-260"><code>SDL::Surface#drawAAFilledEllipse(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawAAFilledEllipse" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a> instead.</p>
<p>Draws a filled antialiased ellipse.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a></p></li>
</ul></dd>
<dt><a name="label-261" id="label-261"><code>SDL::Surface#draw_ellipse_alpha(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_ellipse_alpha" -->
<dt><a name="label-262" id="label-262"><code>SDL::Surface#drawEllipseAlpha(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawEllipseAlpha" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a> instead.</p>
<p>Draws a blended ellipse.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a></p></li>
</ul></dd>
<dt><a name="label-263" id="label-263"><code>SDL::Surface#draw_filled_ellipse_alpha(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_filled_ellipse_alpha" -->
<dt><a name="label-264" id="label-264"><code>SDL::Surface#drawFilledEllipseAlpha(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawFilledEllipseAlpha" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a> instead.</p>
<p>Draws a filled blended ellipse</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a></p></li>
</ul></dd>
<dt><a name="label-265" id="label-265"><code>SDL::Surface#draw_aa_ellipse_alpha(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_aa_ellipse_alpha" -->
<dt><a name="label-266" id="label-266"><code>SDL::Surface#drawAAEllipseAlpha(<var>x</var>,<var>y</var>,<var>rx</var>,<var>ry</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawAAEllipseAlpha" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a> instead.</p>
<p>Draws an antialiased blended ellipse.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-253">SDL::Surface#draw_ellipse</a></p></li>
</ul></dd>
<dt><a name="label-267" id="label-267"><code>SDL::Surface#draw_bezier(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>x3</var>,<var>y3</var>,<var>x4</var>,<var>y4</var>,<var>level</var>,<var>color</var>,<var>aa</var>=<var>false</var>,<var>alpha</var>=<var>nil</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_bezier" -->
<dt><a name="label-268" id="label-268"><code>SDL::Surface#drawBezier(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>x3</var>,<var>y3</var>,<var>x4</var>,<var>y4</var>,<var>level</var>,<var>color</var>,<var>aa</var>=<var>false</var>,<var>alpha</var>=<var>nil</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawBezier" -->
<dd>
<p>Draws a bezier curve from (<var>x1</var>, <var>y1</var>) to (<var>x4</var>, <var>y4</var>)
with the control points (<var>x2</var>, <var>y2</var>) and (<var>x3</var>, <var>y3</var>).
<var>level</var> indicates how
good precision the function should use, 4-7 is normal.
If <var>aa</var> is true, draws an antialiased curve.
If <var>alpha</var> is integer, draws blended curve.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p></dd>
<dt><a name="label-269" id="label-269"><code>SDL::Surface#draw_aa_bezier(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>x3</var>,<var>y3</var>,<var>x4</var>,<var>y4</var>,<var>level</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_aa_bezier" -->
<dt><a name="label-270" id="label-270"><code>SDL::Surface#drawAABezier(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>x3</var>,<var>y3</var>,<var>x4</var>,<var>y4</var>,<var>level</var>,<var>color</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawAABezier" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-267">SDL::Surface#draw_bezier</a> instead.</p>
<p>Draws an antialiased bezier curve.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-267">SDL::Surface#draw_bezier</a></p></li>
</ul></dd>
<dt><a name="label-271" id="label-271"><code>SDL::Surface#draw_bezier_alpha(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>x3</var>,<var>y3</var>,<var>x4</var>,<var>y4</var>,<var>level</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_bezier_alpha" -->
<dt><a name="label-272" id="label-272"><code>SDL::Surface#drawBezierAlpha(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>x3</var>,<var>y3</var>,<var>x4</var>,<var>y4</var>,<var>level</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawBezierAlpha" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-267">SDL::Surface#draw_bezier</a> instead.</p>
<p>Draws a blended bezier curve.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-267">SDL::Surface#draw_bezier</a></p></li>
</ul></dd>
<dt><a name="label-273" id="label-273"><code>SDL::Surface#draw_aa_bezier_alpha(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>x3</var>,<var>y3</var>,<var>x4</var>,<var>y4</var>,<var>level</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#draw_aa_bezier_alpha" -->
<dt><a name="label-274" id="label-274"><code>SDL::Surface#drawAABezierAlpha(<var>x1</var>,<var>y1</var>,<var>x2</var>,<var>y2</var>,<var>x3</var>,<var>y3</var>,<var>x4</var>,<var>y4</var>,<var>level</var>,<var>color</var>,<var>alpha</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#drawAABezierAlpha" -->
<dd>
<p>This method is obsolete. Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-267">SDL::Surface#draw_bezier</a> instead.</p>
<p>Draws an antialiased blended bezier curve.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-267">SDL::Surface#draw_bezier</a></p></li>
</ul></dd>
<dt><a name="label-275" id="label-275"><code>SDL::Surface#transform_surface(<var>bgcolor</var>,<var>angle</var>,<var>xscale</var>,<var>yscale</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#transform_surface" -->
<dt><a name="label-276" id="label-276"><code>SDL::Surface#transformSurface(<var>bgcolor</var>,<var>angle</var>,<var>xscale</var>,<var>yscale</var>,<var>flags</var>)</code></a></dt><!-- RDLabel: "SDL::Surface#transformSurface" -->
<dd>
<p>Returns a rotated and scaled version of <var>self</var>.
See <var>Surface.transform_draw</var> for more information.
<var>bgcolor</var> is background color that new surface have.</p>
<p>The new surface object will have the same depth 
and pixel format as <var>self</var>.</p>
<p>This method needs <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-115">Locking</a>.
If <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-199">SDL.auto_lock?</a> is true, Ruby/SDL automatically locks/unlocks the surface.
Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-216">SDL::Surface.transform_draw</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-223">SDL::Surface.transform_blit</a></p></li>
</ul></dd>
</dl>
<h1><a name="label-277" id="label-277">OpenGL</a></h1><!-- RDLabel: "OpenGL" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-278">OpenGL outline</a></li>
<li>OpenGL related methods
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-283">SDL::GL.get_attr</a> -- Get the value of a special SDL/OpenGL attribute</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-285">SDL::GL.set_attr</a> -- Set a special SDL/OpenGL attribute</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-287">SDL::GL.swap_buffers</a> -- Swap OpenGL framebuffers/Update Display</li>
</ul></li>
</ul>
<h2><a name="label-278" id="label-278">OpenGL outline</a></h2><!-- RDLabel: "OpenGL outline" -->
<p>Ruby/SDL has the ability to create and use OpenGL
contexts on several platforms(Linux/
X11, Win32, Mac OS X, etc).
This allows you to use SDL's audio, event handling and times in your
OpenGL applications (a function often performed by GLUT).</p>
<p>Ruby/SDL has no OpenGL methods, please use
<a href="http://ruby-opengl.rubyforge.org/">ruby-opengl</a> or
<a href="http://www.kumaryu.net/?(Ruby)+Riko">riko</a>
with Ruby/SDL.</p>
<h3><a name="label-279" id="label-279">Initialisation</a></h3><!-- RDLabel: "Initialisation" -->
<p>Initialising Ruby/SDL to use OpenGL is not very
different to initialising Ruby/SDL normally.
There are three differences; you must pass
SDL::OPENGL to <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a>, you
must specify several GL attributes (depth buffer size, framebuffer sizes) using 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-285">SDL::GL.set_attr</a> and finally, if you wish to use double buffering you must
specify it as a GL attribute, <em>not</em> by passing the SDL::DOUBLEBUF flag to
SDL::DOUBLEBUF.</p>
<p>EXAMPLE</p>
<pre># First, initialize SDL's video subsystem.
SDL.init(SDL::INIT_VIDEO)
# Let's get some video information.
info = SDL::Screen.info
# Set our width/height to 640/480 (you would
# of course let the user decide this in a normal
# app).
width = 640
height = 480
# We get the bpp we will request from the display.
bpp = info.bpp
# Now, we want to setup our requested
# window attributes for our OpenGL window.
# We want *at least* 5 bits of red, green
# and blue. We also want at least a 16-bit
# depth buffer.
#
# The last thing we do is request a double
# buffered window. '1' turns on double
# buffering, '0' turns it off.
#
# Note that we do not use SDL::DOUBLEBUF in
# the flags to SDL::Screen.open. That does
# not affect the GL attribute state, only
# the standard 2D blitting setup.
SDL::GL.set_attr(SDL::GL::RED_SIZE, 5)
SDL::GL.set_attr(SDL::GL::GREEN_SIZE, 5)
SDL::GL.set_attr(SDL::GL::BLUE_SIZE, 5)
SDL::GL.set_attr(SDL::GL::DEPTH_SIZE, 16)
SDL::GL.set_attr(SDL::GL::DOUBLEBUFFER, 1)

# We want to request that SDL provide us
# with an OpenGL window, in a fullscreen
# video mode.
flags = SDL:;OPENGL | SDL::FULLSCREEN

# Set the video mode
SDL::Screen.open(width, height, bpp, flags)</pre>
<h3><a name="label-280" id="label-280">GL attribute</a></h3><!-- RDLabel: "GL attribute" -->
<p>You can use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-283">SDL::GL.get_attr</a> and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-285">SDL::GL.set_attr</a> with following attributes:</p>
<ul>
<li>SDL::GL::RED_SIZE         Size of the framebuffer red component, in bits</li>
<li>SDL::GL::GREEN_SIZE       Size of the framebuffer green component, in bits</li>
<li>SDL::GL::BLUE_SIZE        Size of the framebuffer blue component, in bits</li>
<li>SDL::GL::ALPHA_SIZE       Size of the framebuffer alpha component, in bits</li>
<li>SDL::GL::DOUBLEBUFFER     0 or 1, enable or disable double buffering</li>
<li>SDL::GL::BUFFER_SIZE      Size of the framebuffer, in bits</li>
<li>SDL::GL::DEPTH_SIZE       Size of the depth buffer, in bits</li>
<li>SDL::GL::STENCIL_SIZE     Size of the stencil buffer, in bits</li>
<li>SDL::GL::ACCUM_RED_SIZE   Size of the accumulation buffer red component, in bits</li>
<li>SDL::GL::ACCUM_GREEN_SIZE Size of the accumulation buffer green component, in bits</li>
<li>SDL::GL::ACCUM_BLUE_SIZE  Size of the accumulation buffer blue component, in bits</li>
<li>SDL::GL::ACCUM_ALPHA_SIZE Size of the accumulation buffer alpha component, in bits</li>
</ul>
<h3><a name="label-281" id="label-281">Drawing</a></h3><!-- RDLabel: "Drawing" -->
<p>Apart from initialisation, using OpenGL within Ruby/SDL
is the same as using OpenGL
with any other API, e.g. GLUT. You still use all the same function calls and data
types. However if you are using a double-buffered display, then you must use 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-287">SDL::GL.swap_buffers</a> to swap the buffers and update the display. To request
double-buffering with OpenGL, use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-285">SDL::GL.set_attr</a> with SDL::GL::DOUBLEBUFFER,
and use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-283">SDL::GL.get_attr</a> to see if you actually got it.</p>
<h2><a name="label-282" id="label-282">Methods</a></h2><!-- RDLabel: "Methods" -->
<dl>
<dt><a name="label-283" id="label-283"><code>SDL::GL.get_attr(<var>attr</var>)</code></a></dt><!-- RDLabel: "SDL::GL.get_attr" -->
<dt><a name="label-284" id="label-284"><code>SDL::GL.getAttr(<var>attr</var>)</code></a></dt><!-- RDLabel: "SDL::GL.getAttr" -->
<dd>
<p>Returns the value of the SDL/OpenGL <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-280">attribute</a> <var>attr</var>.
This is useful after
a call to <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a> to check whether your attributes have been set as you
expected.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-285">SDL::GL.set_attr</a></p></li>
</ul></dd>
<dt><a name="label-285" id="label-285"><code>SDL::GL.set_attr(<var>attr</var>, <var>val</var>)</code></a></dt><!-- RDLabel: "SDL::GL.set_attr" -->
<dt><a name="label-286" id="label-286"><code>SDL::GL.setAttr(<var>attr</var>, <var>val</var>)</code></a></dt><!-- RDLabel: "SDL::GL.setAttr" -->
<dd>
<p>Sets the OpenGL <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-280">attribute</a> <var>attr</var> to <var>value</var>.
The attributes you set don't take effect
until after a call to <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a>. You should use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-283">SDL::GL.get_attr</a> to
check the values after a <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a> call.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>NOTES</p>
<p>The SDL::DOUBLEBUF flag is not required to enable double buffering when
setting an OpenGL video mode. Double buffering is enabled or disabled using
the SDL::GL::DOUBLEBUFFER attribute.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-283">SDL::GL.get_attr</a></p></li>
</ul></dd>
<dt><a name="label-287" id="label-287"><code>SDL::GL.swap_buffers()</code></a></dt><!-- RDLabel: "SDL::GL.swap_buffers" -->
<dt><a name="label-288" id="label-288"><code>SDL::GL.swapBuffers()</code></a></dt><!-- RDLabel: "SDL::GL.swapBuffers" -->
<dd>
Swap the OpenGL buffers, if double-buffering is supported.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-285">SDL::GL.set_attr</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a></p></li>
</ul></dd>
</dl>
<h1><a name="label-289" id="label-289">Window Management</a></h1><!-- RDLabel: "Window Management" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-290">Window Management Overview</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-291">Methods for Window Management</a>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-292">SDL::WM.caption</a> -- Gets the window title and icon name.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-293">SDL::WM.set_caption</a> -- Sets the window tile and icon name.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-295">SDL::WM.icon=</a> -- Sets the icon for the display window.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-296">SDL::WM.iconify</a> -- Iconify/Minimise the window</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-297">SDL::WM.grab_input</a> -- Grabs mouse and keyboard input.</li>
</ul></li>
</ul>
<h2><a name="label-290" id="label-290">Window Management Overview</a></h2><!-- RDLabel: "Window Management Overview" -->
<p>SDL provides a small set of window management functions
which allow applications to change their title and toggle
from windowed mode to fullscreen (if available)</p>
<h2><a name="label-291" id="label-291">Methods for Window Management</a></h2><!-- RDLabel: "Methods for Window Management" -->
<dl>
<dt><a name="label-292" id="label-292"><code>SDL::WM.caption</code></a></dt><!-- RDLabel: "SDL::WM.caption" -->
<dd>
Returns the window title and icon name as an array with two element.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-293">SDL::WM.set_caption</a></p></li>
</ul></dd>
<dt><a name="label-293" id="label-293"><code>SDL::WM.set_caption(<var>title</var>, <var>icon</var>)</code></a></dt><!-- RDLabel: "SDL::WM.set_caption" -->
<dt><a name="label-294" id="label-294"><code>SDL::WM.setCaption(<var>title</var>, <var>icon</var>)</code></a></dt><!-- RDLabel: "SDL::WM.setCaption" -->
<dd>
Sets the title-bar and icon name of the display window.
<ul>
<li><p>NOTES</p>
<p><var>title</var> and <var>icon</var> must be UTF8 or ASCII string.</p>
<p>If Ruby/SDL m17n support is enabled, 
<var>title</var> and <var>icon</var> are converted to UTF8 automatically.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-292">SDL::WM.caption</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-295">SDL::WM.icon=</a></p></li>
</ul></dd>
<dt><a name="label-295" id="label-295"><code>SDL::WM.icon=(<var>icon_image</var>)</code></a></dt><!-- RDLabel: "SDL::WM.icon=" -->
<dd>
<p>Sets the icon for the display window. Win32 icons must be 32x32.</p>
<p>This function must be called before the first call to 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a>.
<var>icon_image</var> should be an instance of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a></p>
<p>EXAMPLE</p>
<pre>SDL::WM.icon = SDL::Surface.load_bmp("icon.bmp")</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-58">SDL.set_video_mode</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-292">SDL::WM.caption</a></p></li>
</ul></dd>
<dt><a name="label-296" id="label-296"><code>SDL::WM.iconify</code></a></dt><!-- RDLabel: "SDL::WM.iconify" -->
<dd>
<p>If the application is running in a window managed environment
SDL attempts to iconify/minimise
it. If this method is successful,
the application will receive a <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-329">SDL::Event::APPACTIVE</a>
loss event.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p></dd>
<dt><a name="label-297" id="label-297"><code>SDL::WM.grab_input(<var>mode</var>)</code></a></dt><!-- RDLabel: "SDL::WM.grab_input" -->
<dt><a name="label-298" id="label-298"><code>SDL::WM.grabInput(<var>mode</var>)</code></a></dt><!-- RDLabel: "SDL::WM.grabInput" -->
<dd>
<p>Grabbing means that the mouse is confined to the application window,
and nearly all keyboard input is passed directly to the application,
and not interpreted by a window manager, if any.</p>
<p>You can use following three constants as <var>mode</var>.</p>
<ul>
<li>SDL::WM::GRAB_QUERY</li>
<li>SDL::WM::GRAB_OFF</li>
<li>SDL::WM::GRAB_ON</li>
</ul>
<p>When <var>mode</var> is SDL::WM::GRAB_QUERY, 
the grab mode is not changed, but the current grab mode is returned.</p>
<p>Returns the current/new mode.</p></dd>
</dl>
<h1><a name="label-299" id="label-299">Event</a></h1><!-- RDLabel: "Event" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-300">Event system Overview</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-301">SDL::Event</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-303">SDL::Event::Active</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-304">SDL::Event::KeyDown</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-305">SDL::Event::KeyUp</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-306">SDL::Event::MouseMotion</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-307">SDL::Event::MouseButtonDown</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-308">SDL::Event::MouseButtonUp</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-309">SDL::Event::JoyAxis</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-310">SDL::Event::JoyBall</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-311">SDL::Event::JoyHat</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-312">SDL::Event::JoyButtonDown</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-313">SDL::Event::JoyButtonUp</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-314">SDL::Event::Quit</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-315">SDL::Event::SysWM</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-316">SDL::Event::VideoResize</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-317">SDL::Event::VideoExpose</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-318">SDL::Key</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-320">SDL::Mouse</a></li>
<li>Methdos for Event
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-322">SDL::Event.poll</a> -- Polls for currently pending events.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-323">SDL::Event.wait</a> -- Waits indefinitely for the next available event.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-324">SDL::Event.push</a> -- Pushes an event onto the event queue.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-325">SDL::Event.app_state</a> -- Get the state of the application.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-330">SDL::Event.enable_unicode</a> -- Enable UNICODE translation</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-332">SDL::Event.disable_unicode</a> -- Disable UNICODE translation</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-334">SDL::Event.enable_unicode?</a> -- Get whether UNICODE translation is enabled.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-336">SDL::Event::Active#gain</a> -- Returns whether gaining visibility or not</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-337">SDL::Event::Active#state</a> -- Gets the type of visibility event.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-338">SDL::Event::KeyDown#press</a> -- Returns true.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-339">SDL::Event::KeyDown#sym</a> -- Get the key symbol of pressed key</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-340">SDL::Event::KeyDown#mod</a> -- Current key modifier</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-341">SDL::Event::KeyDown#unicode</a> -- Translated character</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-342">SDL::Event::KeyUp#press</a> -- Whether key is pressed</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-343">SDL::Event::KeyUp#sym</a> -- Get the key symbol of released key</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-344">SDL::Event::KeyUp#mod</a> -- Current key modifier</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-345">SDL::Event::MouseMotion#state</a> -- The current button state</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-349">SDL::Event::MouseMotion#x</a> -- The X coordinate of the mouse</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-350">SDL::Event::MouseMotion#y</a> -- the X coordinate of the mouse.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-351">SDL::Event::MouseMotion#xrel</a> -- Relative motion in the X direction</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-352">SDL::Event::MouseMotion#yrel</a> -- Relative motion in the Y direction</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-353">SDL::Event::MouseButtonDown#button</a> -- The mouse button index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-354">SDL::Event::MouseButtonDown#press</a> -- Whether mouse button is pressed or not</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-355">SDL::Event::MouseButtonDown#x</a> -- The X coordinate of the mouse at press time.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-356">SDL::Event::MouseButtonDown#y</a> -- The Y coordinate of the mouse at press time</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-357">SDL::Event::MouseButtonUp#button</a> -- The mouse button index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-358">SDL::Event::MouseButtonUp#press</a> -- Whether mouse button is pressed or not</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-359">SDL::Event::MouseButtonUp#x</a> -- The X coordinate of the mouse at release time</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-360">SDL::Event::MouseButtonUp#y</a> -- The Y coordinate of the mouse at release time.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-361">SDL::Event::JoyAxis#which</a> -- Joystick device index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-362">SDL::Event::JoyAxis#axis</a> -- JoyAxis axis index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-363">SDL::Event::JoyAxis#value</a> -- Axis value</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-364">SDL::Event::JoyBall#which</a> -- Joystick device index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-365">SDL::Event::JoyBall#ball</a> -- Joystick trackball index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-366">SDL::Event::JoyBall#xrel</a> -- The relative motion in the X direction</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-367">SDL::Event::JoyBall#yrel</a> -- The relative motion in the Y direction.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-368">SDL::Event::JoyHat#which</a> -- Joystick device index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-369">SDL::Event::JoyHat#hat</a> -- Joystick hat index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-370">SDL::Event::JoyHat#value</a> -- Hat position</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-371">SDL::Event::JoyButtonDown#which</a> -- Joystick device index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-372">SDL::Event::JoyButtonDown#button</a> -- Joystick button index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-373">SDL::Event::JoyButtonDown#press</a> -- Joystick button is pressed or released</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-374">SDL::Event::JoyButtonUp#which</a> -- Joystick device index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-375">SDL::Event::JoyButtonUp#button</a> -- Joystick button index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-376">SDL::Event::JoyButtonUp#press</a> -- Joystick button is pressed or released</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-377">SDL::Event::VideoResize#w</a> -- New width of the window.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-378">SDL::Event::VideoResize#h</a> -- New height of the window </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-379">SDL::Key.scan</a> -- Get a snapshot of the current keyboard state</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-380">SDL::Key.press?</a> -- Get the current keyboard state.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-381">SDL::Key.mod_state</a> -- Get the state of modifier keys.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-395">SDL::Key.get_key_name</a> -- Get the name of an SDL virtual keysym</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-397">SDL::Key.enable_key_repeat</a> -- Set keyboard repeat rate.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-399">SDL::Key.disable_key_repeat</a> -- Disable key repeat.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-401">SDL::Mouse.state</a> -- Retrieve the current state of the mouse</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-402">SDL::Mouse.warp</a> -- Set the position of the mouse cursor.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-403">SDL::Mouse.show</a> -- Toggle the cursor is shown on the screen.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-404">SDL::Mouse.hide</a> -- Hide cursor.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-405">SDL::Mouse.show?</a> -- Get the state of mouse cursor.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-406">SDL::Mouse.set_cursor</a> -- Set the currently active mouse cursor.</li>
</ul></li>
</ul>
<h2><a name="label-300" id="label-300">Event system Overview</a></h2><!-- RDLabel: "Event system Overview" -->
<p>Event handling allows your application to receive input from the user.
Event handling is initalised (along with video) with a call to:</p>
<pre>SDL_Init(SDL_INIT_VIDEO);</pre>
<p>Internally, SDL stores all the events waiting to be handled in an event queue.
Using functions like <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-322">SDL::Event.poll</a> and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-323">SDL::Event.wait</a>
you can observe and handle waiting input events.</p>
<p>The key to event handling in SDL is the subclasses of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-301">SDL::Event</a>.
The event queue itself is composed of a series of 
instance of (subclasses of) <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-301">SDL::Event</a>, one for each waiting event.
Those objects are read from queue with the <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-322">SDL::Event.poll</a> and it is
then up to the application to process the information stored with them.</p>
<p>Subclasses of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-301">SDL::Event</a> is following:</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-303">SDL::Event::Active</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-304">SDL::Event::KeyDown</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-305">SDL::Event::KeyUp</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-306">SDL::Event::MouseMotion</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-307">SDL::Event::MouseButtonDown</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-308">SDL::Event::MouseButtonUp</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-309">SDL::Event::JoyAxis</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-310">SDL::Event::JoyBall</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-311">SDL::Event::JoyHat</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-312">SDL::Event::JoyButtonDown</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-313">SDL::Event::JoyButtonUp</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-314">SDL::Event::Quit</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-315">SDL::Event::SysWM</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-316">SDL::Event::VideoResize</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-317">SDL::Event::VideoExpose</a></li>
</ul>
<p>Those classes have two uses.</p>
<ul>
<li>Reading events on the event queue.</li>
<li>Placing events on the event queue.</li>
</ul>
<p>Reading events from the event queue is done with <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-322">SDL::Event.poll</a>.
We'll use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-322">SDL::Event.poll</a> and step through an example.
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-322">SDL::Event.poll</a> removes the next event from the event queue, 
if there are no events on the queue it returns nil
otherwise it returns event object. 
We use a while loop to process each event in turn.</p>
<pre>while event = SDL::Event.poll</pre>
<p>We know that if <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-322">SDL::Event.poll</a> removes an event from the queue then the event information will
be placed in returned object, but we also know that the class of that object will represent
the type of event. So we handle each event type seperately we use a switch statement.</p>
<pre>case event</pre>
<p>We need to know what kind of events we're looking for <em>and</em> the event type's of those events.
So lets assume we want to detect where the user is moving the mouse pointer within our application.
We look through our event types and notice that <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-306">SDL::Event::MouseMotion</a> is, more than likely,
the event we're looking for. A little more research tells use that
mouse motion events are handled within the <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-306">SDL::Event::MouseMotion</a>.
We can check for the mouse motion event type within our switch statement like so:</p>
<pre>when SDL::Event::MouseMotion</pre>
<p>All we need do now is read the information out of this object as instance 
of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-306">SDL::Event::MouseMotion</a>.</p>
<pre>puts "We got a motion event"
puts "Current mouse position is: (#{event.x}, #{event.y})"</pre>
<pre>else
  puts "Unhandled Event!"
end
end
puts "Event queue is empty."</pre>
<p>It is also possible to push events onto the event queue.
[Event.push]  allows you to place events onto the event queue.
You can use it to post fake input events if you wished.</p>
<h2><a name="label-301" id="label-301">SDL::Event</a></h2><!-- RDLabel: "SDL::Event" -->
<p>This class handle events. All objects returned by <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-322">SDL::Event.poll</a> are
instances of subclasses of SDL::Event.</p>
<h2><a name="label-302" id="label-302">Compatiblity</a></h2><!-- RDLabel: "Compatiblity" -->
<p>The class that used to be known as SDL::Event is remove.
The class now called SDL::Event was called SDL::Event2 before.
A constant SDL::Event2 remains as alias of SDL::Event because of compatiblity with older version.</p>
<h2><a name="label-303" id="label-303">SDL::Event::Active</a></h2><!-- RDLabel: "SDL::Event::Active" -->
<p>Class for Application visibility event.</p>
<p>This event raises when the mouse leaves or enters the window area,
the application loses or gains keyboard focus,
or the application is either minimised/iconified or restored.</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-337">SDL::Event::Active#state</a> returns which event occurs.</p>
<ul>
<li><p>NOTES</p>
<p>This event does not occur when an application window is first created.</p></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-336">SDL::Event::Active#gain</a> -- Returns whether gaining visibility or not</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-337">SDL::Event::Active#state</a> -- Gets the type of visibility event.</li>
</ul>
<h2><a name="label-304" id="label-304">SDL::Event::KeyDown</a></h2><!-- RDLabel: "SDL::Event::KeyDown" -->
<p>Class for keyboard down event.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-338">SDL::Event::KeyDown#press</a> -- Returns true.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-339">SDL::Event::KeyDown#sym</a> -- Get the key symbol of pressed key</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-340">SDL::Event::KeyDown#mod</a> -- Current key modifier</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-341">SDL::Event::KeyDown#unicode</a> -- Translated character</li>
</ul>
<h2><a name="label-305" id="label-305">SDL::Event::KeyUp</a></h2><!-- RDLabel: "SDL::Event::KeyUp" -->
<p>Class for key up event.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-342">SDL::Event::KeyUp#press</a> -- Whether key is pressed</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-343">SDL::Event::KeyUp#sym</a> -- Get the key symbol of released key</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-344">SDL::Event::KeyUp#mod</a> -- Current key modifier</li>
</ul>
<h2><a name="label-306" id="label-306">SDL::Event::MouseMotion</a></h2><!-- RDLabel: "SDL::Event::MouseMotion" -->
<p>Class for mouse motion event.</p>
<p>Simply put, a event of this type occurs 
when a user moves the mouse within the application window or when [Mouse.warp] is called.
Both the absolute coordinate (<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-349">SDL::Event::MouseMotion#x</a> and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-350">SDL::Event::MouseMotion#y</a>) and
relative coordinate (<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-351">SDL::Event::MouseMotion#xrel</a> and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-352">SDL::Event::MouseMotion#yrel</a>) 
are reported along with the current button states (<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-345">SDL::Event::MouseMotion#state</a>).</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-345">SDL::Event::MouseMotion#state</a> -- The current button state</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-349">SDL::Event::MouseMotion#x</a> -- The X coordinate of the mouse</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-350">SDL::Event::MouseMotion#y</a> -- the X coordinate of the mouse.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-351">SDL::Event::MouseMotion#xrel</a> -- Relative motion in the X direction</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-352">SDL::Event::MouseMotion#yrel</a> -- Relative motion in the Y direction</li>
</ul>
<h2><a name="label-307" id="label-307">SDL::Event::MouseButtonDown</a></h2><!-- RDLabel: "SDL::Event::MouseButtonDown" -->
<p>Class for mouse button press event.</p>
<p>This type of event occurs when a mouse button press is detected.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-353">SDL::Event::MouseButtonDown#button</a> -- The mouse button index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-354">SDL::Event::MouseButtonDown#press</a> -- Whether mouse button is pressed or not</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-355">SDL::Event::MouseButtonDown#x</a> -- The X coordinate of the mouse at press time.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-356">SDL::Event::MouseButtonDown#y</a> -- The Y coordinate of the mouse at press time</li>
</ul>
<h2><a name="label-308" id="label-308">SDL::Event::MouseButtonUp</a></h2><!-- RDLabel: "SDL::Event::MouseButtonUp" -->
<p>Class for mouse button release event.</p>
<p>This type of event occurs when a mouse button release is detected.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-357">SDL::Event::MouseButtonUp#button</a> -- The mouse button index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-358">SDL::Event::MouseButtonUp#press</a> -- Whether mouse button is pressed or not</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-359">SDL::Event::MouseButtonUp#x</a> -- The X coordinate of the mouse at release time</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-360">SDL::Event::MouseButtonUp#y</a> -- The Y coordinate of the mouse at release time.</li>
</ul>
<h2><a name="label-309" id="label-309">SDL::Event::JoyAxis</a></h2><!-- RDLabel: "SDL::Event::JoyAxis" -->
<p>Class for joystick axis motion event. </p>
<p>This event occurs when ever a user moves an axis on the joystick. </p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-361">SDL::Event::JoyAxis#which</a> -- Joystick device index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-362">SDL::Event::JoyAxis#axis</a> -- JoyAxis axis index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-363">SDL::Event::JoyAxis#value</a> -- Axis value</li>
<li>SEEALSO
  <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-418">SDL::Joystick#num_axes</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-430">SDL::Joystick#axis</a></li>
</ul>
<h2><a name="label-310" id="label-310">SDL::Event::JoyBall</a></h2><!-- RDLabel: "SDL::Event::JoyBall" -->
<p>Class for joystick ball motion event.</p>
<p>This type of event occurs when a user moves a trackball on the joystick.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-364">SDL::Event::JoyBall#which</a> -- Joystick device index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-365">SDL::Event::JoyBall#ball</a> -- Joystick trackball index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-366">SDL::Event::JoyBall#xrel</a> -- The relative motion in the X direction</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-367">SDL::Event::JoyBall#yrel</a> -- The relative motion in the Y direction.</li>
<li><p>SEEALSO</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-420">SDL::Joystick#num_balls</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-433">SDL::Joystick#ball</a></p></li>
</ul>
<h2><a name="label-311" id="label-311">SDL::Event::JoyHat</a></h2><!-- RDLabel: "SDL::Event::JoyHat" -->
<p>Class for joystick hat position change event.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-368">SDL::Event::JoyHat#which</a> -- Joystick device index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-369">SDL::Event::JoyHat#hat</a> -- Joystick hat index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-370">SDL::Event::JoyHat#value</a> -- Hat position</li>
<li><p>SEEALSO</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-422">SDL::Joystick#num_hats</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-431">SDL::Joystick#hat</a></p></li>
</ul>
<h2><a name="label-312" id="label-312">SDL::Event::JoyButtonDown</a></h2><!-- RDLabel: "SDL::Event::JoyButtonDown" -->
<p>Class for joystick button press event.</p>
<p>This event occurs when a user presses a button on a joystick.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-371">SDL::Event::JoyButtonDown#which</a> -- Joystick device index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-372">SDL::Event::JoyButtonDown#button</a> -- Joystick button index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-373">SDL::Event::JoyButtonDown#press</a> -- Joystick button is pressed or released</li>
<li><p>SEEALSO</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-424">SDL::Joystick#num_buttons</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-432">SDL::Joystick#button</a></p></li>
</ul>
<h2><a name="label-313" id="label-313">SDL::Event::JoyButtonUp</a></h2><!-- RDLabel: "SDL::Event::JoyButtonUp" -->
<p>Class for joystick button release event.</p>
<p>This event occurs when a user releases a button on a joystick.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-374">SDL::Event::JoyButtonUp#which</a> -- Joystick device index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-375">SDL::Event::JoyButtonUp#button</a> -- Joystick button index</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-376">SDL::Event::JoyButtonUp#press</a> -- Joystick button is pressed or released</li>
<li><p>SEEALSO</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-424">SDL::Joystick#num_buttons</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-432">SDL::Joystick#button</a></p></li>
</ul>
<h2><a name="label-314" id="label-314">SDL::Event::Quit</a></h2><!-- RDLabel: "SDL::Event::Quit" -->
<p>Class for quit reqested event.</p>
<p>This event is very important.
If you filter out or ignore a quit event then it is impossible for the user to
close the window. On the other hand, if you do accept a quit event then the application window will be
closed, and screen updates will still report success event though the application will no longer be
visible.</p>
<h2><a name="label-315" id="label-315">SDL::Event::SysWM</a></h2><!-- RDLabel: "SDL::Event::SysWM" -->
<p>Class for platform-dependent window manager event.</p>
<p>Event of this type occurs when unknown window manager event happens.
You can never know the detail of this event.
Only you can to do is to ignore this event.</p>
<h2><a name="label-316" id="label-316">SDL::Event::VideoResize</a></h2><!-- RDLabel: "SDL::Event::VideoResize" -->
<p>Class for window resize event.</p>
<p>When SDL::RESIZABLE is passed as a <var>flag</var> to 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a> the user is allowed to resize the applications
window. When the window is resized an event of this type is report,
with the new window width and height values stored in <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-377">SDL::Event::VideoResize#w</a> and</p>
<pre>((&lt;SDL::Event::VideoResize#h&gt;)) respectively.</pre>
<p>When this event is recieved the window should be resized
to the new dimensions using <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-59">SDL::Screen.open</a>.</p>
<h2><a name="label-317" id="label-317">SDL::Event::VideoExpose</a></h2><!-- RDLabel: "SDL::Event::VideoExpose" -->
<p>Class for video expose event.</p>
<p>This event is triggered when the screen has been modified outside of the application, usually by
the window manager and needs to be redrawn.</p>
<h2><a name="label-318" id="label-318">SDL::Key</a></h2><!-- RDLabel: "SDL::Key" -->
<p>Module for keyboard input.</p>
<p>This module defines some keyboard-related constants and 
module functions.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-379">SDL::Key.scan</a> -- Get a snapshot of the current keyboard state</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-380">SDL::Key.press?</a> -- Get the current keyboard state.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-381">SDL::Key.mod_state</a> -- Get the state of modifier keys.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-395">SDL::Key.get_key_name</a> -- Get the name of an SDL virtual keysym</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-397">SDL::Key.enable_key_repeat</a> -- Set keyboard repeat rate.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-399">SDL::Key.disable_key_repeat</a> -- Disable key repeat.</li>
</ul>
<h3><a name="label-319" id="label-319">Key symbol</a></h3><!-- RDLabel: "Key symbol" -->
<p>Key symbol constants definitions.</p>
<ul>
<li>SDL::Key::BACKSPACE  '\b'  backspace  </li>
<li>SDL::Key::TAB  '\t' tab  </li>
<li>SDL::Key::CLEAR     clear</li>
<li>SDL::Key::RETURN  '\r'  return</li>
<li>SDL::Key::PAUSE    pause</li>
<li>SDL::Key::ESCAPE  '^['  escape</li>
<li>SDL::Key::SPACE  ' '   space</li>
<li>SDL::Key::EXCLAIM  '!'   exclaim</li>
<li>SDL::Key::QUOTEDBL  '"'   quotedbl</li>
<li>SDL::Key::HASH  '#'   hash</li>
<li>SDL::Key::DOLLAR  '$'   dollar</li>
<li>SDL::Key::AMPERSAND  '&amp;'  ampersand</li>
<li>SDL::Key::QUOTE  '''  quote</li>
<li>SDL::Key::LEFTPAREN  '('   left parenthesis</li>
<li>SDL::Key::RIGHTPAREN  ')'  right parenthesis</li>
<li>SDL::Key::ASTERISK  '*'  asterisk</li>
<li>SDL::Key::PLUS  '+'  plus sign</li>
<li>SDL::Key::COMMA  ','  comma</li>
<li>SDL::Key::MINUS  '-'  minus sign</li>
<li>SDL::Key::PERIOD  '.'  period</li>
<li>SDL::Key::SLASH  '/'  forward slash</li>
<li>SDL::Key::K0  '0'  0</li>
<li>SDL::Key::K1  '1'  1</li>
<li>SDL::Key::K2  '2'  2</li>
<li>SDL::Key::K3  '3'  3</li>
<li>SDL::Key::K4  '4'  4</li>
<li>SDL::Key::K5  '5'  5</li>
<li>SDL::Key::K6  '6'  6</li>
<li>SDL::Key::K7  '7'  7</li>
<li>SDL::Key::K8  '8'  8</li>
<li>SDL::Key::K9  '9'  9</li>
<li>SDL::Key::COLON  ':'  colon</li>
<li>SDL::Key::SEMICOLON  ';'  semicolon</li>
<li>SDL::Key::LESS  '&amp;lt;'  less-than sign</li>
<li>SDL::Key::EQUALS  '='   equals sign</li>
<li>SDL::Key::GREATER  '&amp;gt;'   greater-than sign</li>
<li>SDL::Key::QUESTION  '?'   question mark</li>
<li>SDL::Key::AT  '@'   at</li>
<li>SDL::Key::LEFTBRACKET  '['   left bracket</li>
<li>SDL::Key::BACKSLASH  '\'   backslash</li>
<li>SDL::Key::RIGHTBRACKET  ']'   right bracket</li>
<li>SDL::Key::CARET  '^'   caret</li>
<li>SDL::Key::UNDERSCORE  '_'   underscore</li>
<li>SDL::Key::BACKQUOTE  '`'   grave</li>
<li>SDL::Key::A  'a'  a  </li>
<li>SDL::Key::B  'b'  b  </li>
<li>SDL::Key::C  'c'  c  </li>
<li>SDL::Key::D  'd'  d  </li>
<li>SDL::Key::E  'e'  e  </li>
<li>SDL::Key::F  'f'  f  </li>
<li>SDL::Key::G  'g'  g  </li>
<li>SDL::Key::H  'h'  h  </li>
<li>SDL::Key::I  'i'  i  </li>
<li>SDL::Key::J  'j'  j  </li>
<li>SDL::Key::K  'k'  k  </li>
<li>SDL::Key::L  'l'  l  </li>
<li>SDL::Key::M  'm'  m  </li>
<li>SDL::Key::N  'n'  n  </li>
<li>SDL::Key::O  'o'  o  </li>
<li>SDL::Key::P  'p'  p  </li>
<li>SDL::Key::Q  'q'  q  </li>
<li>SDL::Key::R  'r'  r  </li>
<li>SDL::Key::S  's'  s  </li>
<li>SDL::Key::T  't'  t  </li>
<li>SDL::Key::U  'u'  u  </li>
<li>SDL::Key::V  'v'  v  </li>
<li>SDL::Key::W  'w'  w  </li>
<li>SDL::Key::X  'x'  x  </li>
<li>SDL::Key::Y  'y'  y  </li>
<li>SDL::Key::Z  'z'  z  </li>
<li>SDL::Key::DELETE  '^?'  delete  </li>
<li>SDL::Key::KP0     keypad 0</li>
<li>SDL::Key::KP1     keypad 1</li>
<li>SDL::Key::KP2     keypad 2</li>
<li>SDL::Key::KP3     keypad 3</li>
<li>SDL::Key::KP4     keypad 4</li>
<li>SDL::Key::KP5     keypad 5</li>
<li>SDL::Key::KP6     keypad 6</li>
<li>SDL::Key::KP7     keypad 7</li>
<li>SDL::Key::KP8     keypad 8</li>
<li>SDL::Key::KP9     keypad 9</li>
<li>SDL::Key::KP_PERIOD  '.'   keypad period</li>
<li>SDL::Key::KP_DIVIDE  '/'   keypad divide</li>
<li>SDL::Key::KP_MULTIPLY  '*'   keypad multiply</li>
<li>SDL::Key::KP_MINUS  '-'   keypad minus</li>
<li>SDL::Key::KP_PLUS  '+'   keypad plus</li>
<li>SDL::Key::KP_ENTER  '\r'   keypad enter</li>
<li>SDL::Key::KP_EQUALS  '='   keypad equals</li>
<li>SDL::Key::UP     up arrow</li>
<li>SDL::Key::DOWN     down arrow</li>
<li>SDL::Key::RIGHT     right arrow</li>
<li>SDL::Key::LEFT     left arrow</li>
<li>SDL::Key::INSERT    insert  </li>
<li>SDL::Key::HOME    home  </li>
<li>SDL::Key::END    end  </li>
<li>SDL::Key::PAGEUP    page up  </li>
<li>SDL::Key::PAGEDOWN    page down  </li>
<li>SDL::Key::F1    F1  </li>
<li>SDL::Key::F2    F2  </li>
<li>SDL::Key::F3    F3  </li>
<li>SDL::Key::F4    F4  </li>
<li>SDL::Key::F5    F5  </li>
<li>SDL::Key::F6    F6  </li>
<li>SDL::Key::F7    F7  </li>
<li>SDL::Key::F8    F8  </li>
<li>SDL::Key::F9    F9  </li>
<li>SDL::Key::F10    F10  </li>
<li>SDL::Key::F11    F11  </li>
<li>SDL::Key::F12    F12  </li>
<li>SDL::Key::F13    F13  </li>
<li>SDL::Key::F14    F14  </li>
<li>SDL::Key::F15    F15  </li>
<li>SDL::Key::NUMLOCK    numlock  </li>
<li>SDL::Key::CAPSLOCK    capslock  </li>
<li>SDL::Key::SCROLLOCK    scrollock  </li>
<li>SDL::Key::RSHIFT     right shift</li>
<li>SDL::Key::LSHIFT     left shift</li>
<li>SDL::Key::RCTRL     right ctrl</li>
<li>SDL::Key::LCTRL     left ctrl</li>
<li>SDL::Key::RALT     right alt</li>
<li>SDL::Key::LALT     left alt</li>
<li>SDL::Key::RMETA     right meta</li>
<li>SDL::Key::LMETA     left meta</li>
<li>SDL::Key::LSUPER     left windows key</li>
<li>SDL::Key::RSUPER     right windows key</li>
<li>SDL::Key::MODE     mode shift</li>
<li>SDL::Key::HELP    help  </li>
<li>SDL::Key::PRINT    print-screen  </li>
<li>SDL::Key::SYSREQ    SysRq  </li>
<li>SDL::Key::BREAK    break  </li>
<li>SDL::Key::MENU    menu  </li>
<li>SDL::Key::POWER    power  </li>
<li>SDL::Key::EURO     euro</li>
</ul>
<h2><a name="label-320" id="label-320">SDL::Mouse</a></h2><!-- RDLabel: "SDL::Mouse" -->
<p>Module for mouse input.</p>
<p>This module defines some mouse constants and module functions.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-401">SDL::Mouse.state</a> -- Retrieve the current state of the mouse</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-402">SDL::Mouse.warp</a> -- Set the position of the mouse cursor.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-403">SDL::Mouse.show</a> -- Toggle the cursor is shown on the screen.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-404">SDL::Mouse.hide</a> -- Hide cursor.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-405">SDL::Mouse.show?</a> -- Get the state of mouse cursor.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-406">SDL::Mouse.set_cursor</a> -- Set the currently active mouse cursor.</li>
</ul>
<h2><a name="label-321" id="label-321">Methods</a></h2><!-- RDLabel: "Methods" -->
<dl>
<dt><a name="label-322" id="label-322"><code>SDL::Event.poll</code></a></dt><!-- RDLabel: "SDL::Event.poll" -->
<dd>
<p>Polls for currently pending events, and returns event object if there
are any pending events, or nil if there are none
available.</p>
<p>If event object is returned, the next event is removed from 
the queue and stored in that area.</p>
<p>EXAMPLE</p>
<pre>while event = SDL::Event.poll # Loop until there are no events left on the queue
  case event # Process the appropiate event type
  when SDL::Event::KeyDown # Handle a KEYDOWN event
    puts "Oh! Key press"
  when SDL::Event::MouseMotion
    .
    .
    .
  else # Report an unhandled event
    puts "I don't know what this event is!"
  end
end</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-301">SDL::Event</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-323">SDL::Event.wait</a></p></li>
</ul></dd>
<dt><a name="label-323" id="label-323"><code>SDL::Event.wait</code></a></dt><!-- RDLabel: "SDL::Event.wait" -->
<dd>
<p>Waits indefinitely for the next available event and return that event.</p>
<p>If event object is returned, the next event is removed
from the queue and stored in that area.</p>
<p>Raise <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> if there was an error while waiting
for events.</p>
<ul>
<li><p>NOTES</p>
<p>In Ruby 1.9 and above, this method releases the global VM lock (GVL) prior to
calling the underlying SDL_WaitEvent function.  This allows other Ruby threads to
continue executing while waiting for an event.</p>
<p>In Ruby 1.8 and below, there is no way to release the GVL, so all Ruby threads
suspend execution until this method finishes.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-322">SDL::Event.poll</a></p></li>
</ul></dd>
<dt><a name="label-324" id="label-324"><code>SDL::Event.push(<var>event</var>)</code></a></dt><!-- RDLabel: "SDL::Event.push" -->
<dd>
<p>Push <var>event</var> onto event queue.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>NOTES</p>
<p>Pushing device input events onto the queue doesn't modify the 
state of the device within SDL.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-322">SDL::Event.poll</a></p></li>
</ul></dd>
<dt><a name="label-325" id="label-325"><code>SDL::Event.app_state</code></a></dt><!-- RDLabel: "SDL::Event.app_state" -->
<dt><a name="label-326" id="label-326"><code>SDL::Event.appState</code></a></dt><!-- RDLabel: "SDL::Event.appState" -->
<dd>
This method returns the current state of the application. 
The value returned is a bitwise combination of:
<dl>
<dt><a name="label-327" id="label-327">SDL::Event::APPMOUSEFOCUS</a></dt><!-- RDLabel: "SDL::Event::APPMOUSEFOCUS" -->
<dd>
The application has mouse focus. 
</dd>
<dt><a name="label-328" id="label-328">SDL::Event::APPINPUTFOCUS</a></dt><!-- RDLabel: "SDL::Event::APPINPUTFOCUS" -->
<dd>
The application has keyboard focus.
</dd>
<dt><a name="label-329" id="label-329">SDL::Event::APPACTIVE</a></dt><!-- RDLabel: "SDL::Event::APPACTIVE" -->
<dd>
The application is visible.
</dd>
</dl>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-303">SDL::Event::Active</a></p></li>
</ul></dd>
<dt><a name="label-330" id="label-330"><code>SDL::Event.enable_unicode</code></a></dt><!-- RDLabel: "SDL::Event.enable_unicode" -->
<dt><a name="label-331" id="label-331"><code>SDL::Event.enableUNICODE</code></a></dt><!-- RDLabel: "SDL::Event.enableUNICODE" -->
<dd>
To obtain the character codes corresponding to received keyboard events, Unicode translation must first
be turned on using this function. The translation incurs a slight overhead for each keyboard event and is
therefore disabled by default. For each subsequently received key down event, 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-341">SDL::Event::KeyDown#unicode</a> will then contain the corresponding character code, 
or zero for keysyms that do not correspond to any character code.
<ul>
<li><p>NOTES</p>
<p>Note that only key press events will be translated, not release events.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-332">SDL::Event.disable_unicode</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-334">SDL::Event.enable_unicode?</a></p></li>
</ul></dd>
<dt><a name="label-332" id="label-332"><code>SDL::Event.disable_unicode</code></a></dt><!-- RDLabel: "SDL::Event.disable_unicode" -->
<dt><a name="label-333" id="label-333"><code>SDL::Event.disableUNICODE</code></a></dt><!-- RDLabel: "SDL::Event.disableUNICODE" -->
<dd>
Disables Unicode keyboard translation. Please see <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-330">SDL::Event.enable_unicode</a>
in detail.</dd>
<dt><a name="label-334" id="label-334"><code>SDL::Event.enable_unicode?</code></a></dt><!-- RDLabel: "SDL::Event.enable_unicode?" -->
<dt><a name="label-335" id="label-335"><code>SDL::Event.enableUNICODE?</code></a></dt><!-- RDLabel: "SDL::Event.enableUNICODE?" -->
<dd>
Returns true if Unicode keyboard translation is enabled, otherwise
returns false. Please see <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-330">SDL::Event.enable_unicode</a> in detail.</dd>
<dt><a name="label-336" id="label-336"><code>SDL::Event::Active#gain</code></a></dt><!-- RDLabel: "SDL::Event::Active#gain" -->
<dd>
Returns true if the mouse enters the window, the application gains keyboard focus, or
minimized/iconcified window is restored.
Otherwise returns false.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-303">SDL::Event::Active</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-337">SDL::Event::Active#state</a></p></li>
</ul></dd>
<dt><a name="label-337" id="label-337"><code>SDL::Event::Active#state</code></a></dt><!-- RDLabel: "SDL::Event::Active#state" -->
<dd>
Returns one of following three constants:
<ul>
<li><p>SDL::Event::APPMOUSEFOCUS</p>
<p>This event occurs when the mouse leaves or enters the window area.</p></li>
<li><p>SDL::Event::APPINPUTFOCUS</p>
<p>THis event occurs when the application loses or gains input focus.</p></li>
<li><p>SDL::Event::APPACTIVE</p>
<p>This event occurs when the application is either minimized/iconcified or restored.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-303">SDL::Event::Active</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-336">SDL::Event::Active#gain</a></p></li>
</ul></dd>
<dt><a name="label-338" id="label-338"><code>SDL::Event::KeyDown#press</code></a></dt><!-- RDLabel: "SDL::Event::KeyDown#press" -->
<dd>
Always returns true.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-342">SDL::Event::KeyUp#press</a></p></li>
</ul></dd>
<dt><a name="label-339" id="label-339"><code>SDL::Event::KeyDown#sym</code></a></dt><!-- RDLabel: "SDL::Event::KeyDown#sym" -->
<dd>
Returns pressed <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-319">Key symbol</a>.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-341">SDL::Event::KeyDown#unicode</a></p></li>
</ul></dd>
<dt><a name="label-340" id="label-340"><code>SDL::Event::KeyDown#mod</code></a></dt><!-- RDLabel: "SDL::Event::KeyDown#mod" -->
<dd>
Returns the current state of keyboard modifiers as explained in <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-381">SDL::Key.mod_state</a>.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-381">SDL::Key.mod_state</a></p></li>
</ul></dd>
<dt><a name="label-341" id="label-341"><code>SDL::Event::KeyDown#unicode</code></a></dt><!-- RDLabel: "SDL::Event::KeyDown#unicode" -->
<dd>
<p>Returns the UNICODE character corresponding to the keypress if Unicode translation
is enabled with <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-330">SDL::Event.enable_unicode</a>. 
If the high 9 bits of the character are 0, then this
maps to the equivalent ASCII character:</p>
<p>Returns zero if unicode translation is disabled.</p></dd>
<dt><a name="label-342" id="label-342"><code>SDL::Event::KeyUp#press</code></a></dt><!-- RDLabel: "SDL::Event::KeyUp#press" -->
<dd>
Always returns false.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-338">SDL::Event::KeyDown#press</a></p></li>
</ul></dd>
<dt><a name="label-343" id="label-343"><code>SDL::Event::KeyUp#sym</code></a></dt><!-- RDLabel: "SDL::Event::KeyUp#sym" -->
<dd>
Returns the released <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-319">Key symbol</a></dd>
<dt><a name="label-344" id="label-344"><code>SDL::Event::KeyUp#mod</code></a></dt><!-- RDLabel: "SDL::Event::KeyUp#mod" -->
<dd>
Returns the current state of keyboard modifiers as explained in <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-381">SDL::Key.mod_state</a>.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-381">SDL::Key.mod_state</a></p></li>
</ul></dd>
<dt><a name="label-345" id="label-345"><code>SDL::Event::MouseMotion#state</code></a></dt><!-- RDLabel: "SDL::Event::MouseMotion#state" -->
<dd>
Returns the current button state.
The value returned is a bitwise combination of:
<dl>
<dt><a name="label-346" id="label-346">SDL::Mouse::BUTTON_LMASK</a></dt><!-- RDLabel: "SDL::Mouse::BUTTON_LMASK" -->
<dd>
Left button
</dd>
<dt><a name="label-347" id="label-347">SDL::Mouse::BUTTON_MMASK</a></dt><!-- RDLabel: "SDL::Mouse::BUTTON_MMASK" -->
<dd>
Middle button
</dd>
<dt><a name="label-348" id="label-348">SDL::Mouse::BUTTON_RMASK</a></dt><!-- RDLabel: "SDL::Mouse::BUTTON_RMASK" -->
<dd>
Right button
</dd>
</dl>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-401">SDL::Mouse.state</a></p></li>
</ul></dd>
<dt><a name="label-349" id="label-349"><code>SDL::Event::MouseMotion#x</code></a></dt><!-- RDLabel: "SDL::Event::MouseMotion#x" -->
<dd>
Returns the X coordinate of the mouse.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-401">SDL::Mouse.state</a></p></li>
</ul></dd>
<dt><a name="label-350" id="label-350"><code>SDL::Event::MouseMotion#y</code></a></dt><!-- RDLabel: "SDL::Event::MouseMotion#y" -->
<dd>
Returns the Y coordinate of the mouse.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-401">SDL::Mouse.state</a></p></li>
</ul></dd>
<dt><a name="label-351" id="label-351"><code>SDL::Event::MouseMotion#xrel</code></a></dt><!-- RDLabel: "SDL::Event::MouseMotion#xrel" -->
<dd>
Returns relative motion in the X direction.</dd>
<dt><a name="label-352" id="label-352"><code>SDL::Event::MouseMotion#yrel</code></a></dt><!-- RDLabel: "SDL::Event::MouseMotion#yrel" -->
<dd>
Returns relative motion in the Y direction.</dd>
<dt><a name="label-353" id="label-353"><code>SDL::Event::MouseButtonDown#button</code></a></dt><!-- RDLabel: "SDL::Event::MouseButtonDown#button" -->
<dd>
Returns number of the button pressed:
<ul>
<li>SDL::Mouse::BUTTON_LEFT</li>
<li>SDL::Mouse::BUTTON_MIDDLE</li>
<li>SDL::Mouse::BUTTON_RIGHT</li>
</ul></dd>
<dt><a name="label-354" id="label-354"><code>SDL::Event::MouseButtonDown#press</code></a></dt><!-- RDLabel: "SDL::Event::MouseButtonDown#press" -->
<dd>
Always returns true.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-358">SDL::Event::MouseButtonUp#press</a></p></li>
</ul></dd>
<dt><a name="label-355" id="label-355"><code>SDL::Event::MouseButtonDown#x</code></a></dt><!-- RDLabel: "SDL::Event::MouseButtonDown#x" -->
<dd>
Returns the X coordinate of the mouse.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-401">SDL::Mouse.state</a></p></li>
</ul></dd>
<dt><a name="label-356" id="label-356"><code>SDL::Event::MouseButtonDown#y</code></a></dt><!-- RDLabel: "SDL::Event::MouseButtonDown#y" -->
<dd>
Returns the Y coordinate of the mouse at press time.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-401">SDL::Mouse.state</a></p></li>
</ul></dd>
<dt><a name="label-357" id="label-357"><code>SDL::Event::MouseButtonUp#button</code></a></dt><!-- RDLabel: "SDL::Event::MouseButtonUp#button" -->
<dd>
Returns number of the button released:
<ul>
<li>SDL::Mouse::BUTTON_LEFT</li>
<li>SDL::Mouse::BUTTON_MIDDLE</li>
<li>SDL::Mouse::BUTTON_RIGHT</li>
</ul></dd>
<dt><a name="label-358" id="label-358"><code>SDL::Event::MouseButtonUp#press</code></a></dt><!-- RDLabel: "SDL::Event::MouseButtonUp#press" -->
<dd>
Always returns false.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-354">SDL::Event::MouseButtonDown#press</a></p></li>
</ul></dd>
<dt><a name="label-359" id="label-359"><code>SDL::Event::MouseButtonUp#x</code></a></dt><!-- RDLabel: "SDL::Event::MouseButtonUp#x" -->
<dd>
Returns the X coordinate of the mouse at release time.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-401">SDL::Mouse.state</a></p></li>
</ul></dd>
<dt><a name="label-360" id="label-360"><code>SDL::Event::MouseButtonUp#y</code></a></dt><!-- RDLabel: "SDL::Event::MouseButtonUp#y" -->
<dd>
Returns the Y coordinate of the mouse at release time.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-401">SDL::Mouse.state</a></p></li>
</ul></dd>
<dt><a name="label-361" id="label-361"><code>SDL::Event::JoyAxis#which</code></a></dt><!-- RDLabel: "SDL::Event::JoyAxis#which" -->
<dd>
Returns the index of the joystick that reported the event.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-418">SDL::Joystick#num_axes</a></p></li>
</ul></dd>
<dt><a name="label-362" id="label-362"><code>SDL::Event::JoyAxis#axis</code></a></dt><!-- RDLabel: "SDL::Event::JoyAxis#axis" -->
<dd>
Returns the index of the axis that reported the event.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a></p></li>
</ul></dd>
<dt><a name="label-363" id="label-363"><code>SDL::Event::JoyAxis#value</code></a></dt><!-- RDLabel: "SDL::Event::JoyAxis#value" -->
<dd>
Returns the position of the axis in -32767 .. 32767.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-430">SDL::Joystick#axis</a></p></li>
</ul></dd>
<dt><a name="label-364" id="label-364"><code>SDL::Event::JoyBall#which</code></a></dt><!-- RDLabel: "SDL::Event::JoyBall#which" -->
<dd>
Returns the index of the joystick that reported the event.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a></p></li>
</ul></dd>
<dt><a name="label-365" id="label-365"><code>SDL::Event::JoyBall#ball</code></a></dt><!-- RDLabel: "SDL::Event::JoyBall#ball" -->
<dd>
Returns the index of the trackball that reported the event.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-420">SDL::Joystick#num_balls</a></p></li>
</ul></dd>
<dt><a name="label-366" id="label-366"><code>SDL::Event::JoyBall#xrel</code></a></dt><!-- RDLabel: "SDL::Event::JoyBall#xrel" -->
<dd>
Returns the relative motion in the X direction as Integer.
This value is the change in position on the ball since it was last polled.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-433">SDL::Joystick#ball</a></p></li>
</ul></dd>
<dt><a name="label-367" id="label-367"><code>SDL::Event::JoyBall#yrel</code></a></dt><!-- RDLabel: "SDL::Event::JoyBall#yrel" -->
<dd>
Returns the relative motion in the Y direction as Integer.
This value is the change in position on the ball since it was last polled.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-433">SDL::Joystick#ball</a></p></li>
</ul></dd>
<dt><a name="label-368" id="label-368"><code>SDL::Event::JoyHat#which</code></a></dt><!-- RDLabel: "SDL::Event::JoyHat#which" -->
<dd>
Returns the index of the joystick that reported the event.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a></p></li>
</ul></dd>
<dt><a name="label-369" id="label-369"><code>SDL::Event::JoyHat#hat</code></a></dt><!-- RDLabel: "SDL::Event::JoyHat#hat" -->
<dd>
Returns the index of the hat that reported the event.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-422">SDL::Joystick#num_hats</a></p></li>
</ul></dd>
<dt><a name="label-370" id="label-370"><code>SDL::Event::JoyHat#value</code></a></dt><!-- RDLabel: "SDL::Event::JoyHat#value" -->
<dd>
<p>Returns the current position of the hat. It is a logically OR'd
combination of the following values (whose meanings should be pretty obvious:) :</p>
<ul>
<li>SDL::Joystick::HAT_CENTERED</li>
<li>SDL::Joystick::HAT_UP</li>
<li>SDL::Joystick::HAT_RIGHT</li>
<li>SDL::Joystick::HAT_DOWN</li>
<li>SDL::Joystick::HAT_LEFT</li>
</ul>
<p>The following defines are also provided:</p>
<ul>
<li>SDL::Joystick::HAT_RIGHTUP</li>
<li>SDL::Joystick::HAT_RIGHTDOWN</li>
<li>SDL::Joystick::HAT_LEFTUP</li>
<li>SDL::Joystick::HAT_LEFTDOWN</li>
</ul></dd>
<dt><a name="label-371" id="label-371"><code>SDL::Event::JoyButtonDown#which</code></a></dt><!-- RDLabel: "SDL::Event::JoyButtonDown#which" -->
<dd>
Returns the index of the joystick that reported the event.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a></p></li>
</ul></dd>
<dt><a name="label-372" id="label-372"><code>SDL::Event::JoyButtonDown#button</code></a></dt><!-- RDLabel: "SDL::Event::JoyButtonDown#button" -->
<dd>
Returns the index of the button that reported the event.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-424">SDL::Joystick#num_buttons</a></p></li>
</ul></dd>
<dt><a name="label-373" id="label-373"><code>SDL::Event::JoyButtonDown#press</code></a></dt><!-- RDLabel: "SDL::Event::JoyButtonDown#press" -->
<dd>
Returns whether this event is button press event.
Always returns true.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-376">SDL::Event::JoyButtonUp#press</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-432">SDL::Joystick#button</a></p></li>
</ul></dd>
<dt><a name="label-374" id="label-374"><code>SDL::Event::JoyButtonUp#which</code></a></dt><!-- RDLabel: "SDL::Event::JoyButtonUp#which" -->
<dd>
Returns the index of the joystick that reported the event.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a></p></li>
</ul></dd>
<dt><a name="label-375" id="label-375"><code>SDL::Event::JoyButtonUp#button</code></a></dt><!-- RDLabel: "SDL::Event::JoyButtonUp#button" -->
<dd>
Returns the index of the button that reported the event.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-424">SDL::Joystick#num_buttons</a></p></li>
</ul></dd>
<dt><a name="label-376" id="label-376"><code>SDL::Event::JoyButtonUp#press</code></a></dt><!-- RDLabel: "SDL::Event::JoyButtonUp#press" -->
<dd>
Returns whether this event is button press event.
Always returns false.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-373">SDL::Event::JoyButtonDown#press</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-432">SDL::Joystick#button</a></p></li>
</ul></dd>
<dt><a name="label-377" id="label-377"><code>SDL::Event::VideoResize#w</code></a></dt><!-- RDLabel: "SDL::Event::VideoResize#w" -->
<dd>
Returns the new width of the window when window is resized.</dd>
<dt><a name="label-378" id="label-378"><code>SDL::Event::VideoResize#h</code></a></dt><!-- RDLabel: "SDL::Event::VideoResize#h" -->
<dd>
Returns the new width of the window when window is resized.</dd>
<dt><a name="label-379" id="label-379"><code>SDL::Key.scan</code></a></dt><!-- RDLabel: "SDL::Key.scan" -->
<dd>
<p>Gets a snapshot of the current keyboard state.
You can check this state with <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-380">SDL::Key.press?</a>.</p>
<p>NOTE
Call <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-322">SDL::Event.poll</a> or <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-323">SDL::Event.wait</a> to update the state.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-380">SDL::Key.press?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-304">SDL::Event::KeyDown</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-305">SDL::Event::KeyUp</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-322">SDL::Event.poll</a></p></li>
</ul></dd>
<dt><a name="label-380" id="label-380"><code>SDL::Key.press?(<var>key</var>)</code></a></dt><!-- RDLabel: "SDL::Key.press?" -->
<dd>
Returns true if <var>key</var> is pressed, otherwise returns false.
Please use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-319">Key symbol</a> as parameter.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-379">SDL::Key.scan</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-304">SDL::Event::KeyDown</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-305">SDL::Event::KeyUp</a></p></li>
</ul></dd>
<dt><a name="label-381" id="label-381"><code>SDL::Key.mod_state</code></a></dt><!-- RDLabel: "SDL::Key.mod_state" -->
<dt><a name="label-382" id="label-382"><code>SDL::Key.modState</code></a></dt><!-- RDLabel: "SDL::Key.modState" -->
<dd>
<p>Returns the current state of the modifier keys (CTRL, ALT, etc.).
The return value can be an OR'd combination of:</p>
<dl>
<dt><a name="label-383" id="label-383">SDL::Key::MOD_NONE</a></dt><!-- RDLabel: "SDL::Key::MOD_NONE" -->
<dt><a name="label-384" id="label-384">SDL::Key::MOD_LSHIFT</a></dt><!-- RDLabel: "SDL::Key::MOD_LSHIFT" -->
<dt><a name="label-385" id="label-385">SDL::Key::MOD_RSHIFT</a></dt><!-- RDLabel: "SDL::Key::MOD_RSHIFT" -->
<dt><a name="label-386" id="label-386">SDL::Key::MOD_LCTRL</a></dt><!-- RDLabel: "SDL::Key::MOD_LCTRL" -->
<dt><a name="label-387" id="label-387">SDL::Key::MOD_RCTRL</a></dt><!-- RDLabel: "SDL::Key::MOD_RCTRL" -->
<dt><a name="label-388" id="label-388">SDL::Key::MOD_LALT</a></dt><!-- RDLabel: "SDL::Key::MOD_LALT" -->
<dt><a name="label-389" id="label-389">SDL::Key::MOD_RALT</a></dt><!-- RDLabel: "SDL::Key::MOD_RALT" -->
<dt><a name="label-390" id="label-390">SDL::Key::MOD_LMETA</a></dt><!-- RDLabel: "SDL::Key::MOD_LMETA" -->
<dt><a name="label-391" id="label-391">SDL::Key::MOD_RMETA</a></dt><!-- RDLabel: "SDL::Key::MOD_RMETA" -->
<dt><a name="label-392" id="label-392">SDL::Key::MOD_NUM</a></dt><!-- RDLabel: "SDL::Key::MOD_NUM" -->
<dt><a name="label-393" id="label-393">SDL::Key::MOD_CAPS</a></dt><!-- RDLabel: "SDL::Key::MOD_CAPS" -->
<dt><a name="label-394" id="label-394">SDL::Key::MOD_MODE</a></dt><!-- RDLabel: "SDL::Key::MOD_MODE" -->
</dl>
<p>SDL also defines the following symbols for convenience:</p>
<ul>
<li>SDL::Key::MOD_CTRL = SDL::Key::MOD_LCTRL|SDL::Key::MOD_RCTRL</li>
<li>SDL::Key::MOD_SHIFT = SDL::Key::MOD_LSHIFT|SDL::Key::MOD_RSHIFT</li>
<li>SDL::Key::MOD_ALT = SDL::Key::MOD_LALT|SDL::Key::MOD_RALT</li>
<li>SDL::Key::MOD_META = SDL::Key::MOD_LMETA|SDL::Key::MOD_RMETA</li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-379">SDL::Key.scan</a></p></li>
</ul></dd>
<dt><a name="label-395" id="label-395"><code>SDL::Key.get_key_name(<var>key</var>)</code></a></dt><!-- RDLabel: "SDL::Key.get_key_name" -->
<dt><a name="label-396" id="label-396"><code>SDL::Key.getKeyName(<var>key</var>)</code></a></dt><!-- RDLabel: "SDL::Key.getKeyName" -->
<dd>
Returns the SDL-defined name of the <var>key</var> <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-319">key symbol</a>.</dd>
<dt><a name="label-397" id="label-397"><code>SDL::Key.enable_key_repeat(<var>delay</var>,<var>interval</var>)</code></a></dt><!-- RDLabel: "SDL::Key.enable_key_repeat" -->
<dt><a name="label-398" id="label-398"><code>SDL::Key.enableKeyRepeat(<var>delay</var>,<var>interval</var>)</code></a></dt><!-- RDLabel: "SDL::Key.enableKeyRepeat" -->
<dd>
<p>Enables the keyboard repeat rate. <var>delay</var> specifies how long the key must be pressed before it
begins repeating, it then repeats at the speed specified by <var>interval</var>. Both delay and interval are
expressed in milliseconds.</p>
<p>Good default values are SDL::Key::DEFAULT_REPEAT_DELAY and 
SDL::Key::DEFAULT_REPEAT_INTERVAL.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-399">SDL::Key.disable_key_repeat</a></p></li>
</ul></dd>
<dt><a name="label-399" id="label-399"><code>SDL::Key.disable_key_repeat</code></a></dt><!-- RDLabel: "SDL::Key.disable_key_repeat" -->
<dt><a name="label-400" id="label-400"><code>SDL::Key.disableKeyRepeat</code></a></dt><!-- RDLabel: "SDL::Key.disableKeyRepeat" -->
<dd>
<p>Disables key repeat.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-397">SDL::Key.enable_key_repeat</a></p></li>
</ul></dd>
<dt><a name="label-401" id="label-401"><code>SDL::Mouse.state</code></a></dt><!-- RDLabel: "SDL::Mouse.state" -->
<dd>
<p>Returns an array of five element:</p>
<pre>[ X coordinate, Y coordinate, left button is pressed?, middle button is pressed?, right button is pressed?]</pre>
<p>EXAMPLE</p>
<pre>x, y, lbutton, * = SDL::Mouse.state
if lbutton
  print "Left Mouse Button is pressed \n"
end</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-306">SDL::Event::MouseMotion</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-307">SDL::Event::MouseButtonDown</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-308">SDL::Event::MouseButtonUp</a></p></li>
</ul></dd>
<dt><a name="label-402" id="label-402"><code>SDL::Mouse.warp(<var>x</var>,<var>y</var>)</code></a></dt><!-- RDLabel: "SDL::Mouse.warp" -->
<dd>
Set the position of the mouse cursor (generates a mouse motion event).
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-306">SDL::Event::MouseMotion</a></p></li>
</ul></dd>
<dt><a name="label-403" id="label-403"><code>SDL::Mouse.show</code></a></dt><!-- RDLabel: "SDL::Mouse.show" -->
<dd>
<p>Shows cursor.</p>
<p>The cursor starts off displayed, but can be turned off.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-404">SDL::Mouse.hide</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-405">SDL::Mouse.show?</a></p></li>
</ul></dd>
<dt><a name="label-404" id="label-404"><code>SDL::Mouse.hide</code></a></dt><!-- RDLabel: "SDL::Mouse.hide" -->
<dd>
Hide cursor.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-403">SDL::Mouse.show</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-405">SDL::Mouse.show?</a></p></li>
</ul></dd>
<dt><a name="label-405" id="label-405"><code>SDL::Mouse.show?</code></a></dt><!-- RDLabel: "SDL::Mouse.show?" -->
<dd>
Returns true if mouse cursor is shown, otherwise returns false.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-403">SDL::Mouse.show</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-404">SDL::Mouse.hide</a></p></li>
</ul></dd>
<dt><a name="label-406" id="label-406"><code>SDL::Mouse.set_cursor(<var>bitmap</var>,<var>white</var>,<var>black</var>,<var>transparent</var>,<var>inverted</var>,<var>hot_x</var>=<var>0</var>,<var>hot_y</var>=<var>0</var>)</code></a></dt><!-- RDLabel: "SDL::Mouse.set_cursor" -->
<dt><a name="label-407" id="label-407"><code>SDL::Mouse.setCursor(<var>bitmap</var>,<var>white</var>,<var>black</var>,<var>transparent</var>,<var>inverted</var>,<var>hot_x</var>=<var>0</var>,<var>hot_y</var>=<var>0</var>)</code></a></dt><!-- RDLabel: "SDL::Mouse.setCursor" -->
<dd>
<p>Sets the currently active cursor to the specified one. If the cursor is currently visible, the change
will be immediately represented on the display.</p>
<p><var>bitmap</var> is shape of cursor, given by the instance of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a>.
<var>white</var> is white color pixel value in <var>bitmap</var>, 
<var>black</var> is black color pixel value in <var>bitmap</var>, 
<var>transparent</var> is transparent pixel value in <var>bitmap</var>, 
<var>inverted</var> is inverted pixel value in <var>bitmap</var>.
The cursor width must be a multiple of 8 bits.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a></p></li>
</ul></dd>
</dl>
<h1><a name="label-408" id="label-408">Joystick</a></h1><!-- RDLabel: "Joystick" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-409">Joystick Overview</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a></li>
<li>Methods for Joystick 
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-412">SDL::Joystick.num</a> -- Count available joysticks.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-413">SDL::Joystick.index_name</a> -- Get joystick name.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-415">SDL::Joystick.open</a> -- Opens a joystick for use.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-416">SDL::Joystick.open?</a> -- Determine if a joystick has been opened</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-417">SDL::Joystick#index</a> -- Get the index of an joystick.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-418">SDL::Joystick#num_axes</a> -- Get the number of joystick axes</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-420">SDL::Joystick#num_balls</a> -- Get the number of joystick trackballs</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-422">SDL::Joystick#num_hats</a> -- Get the number of joystick hats</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-424">SDL::Joystick#num_buttons</a> -- Get the number of joystick buttons</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-426">SDL::Joystick.poll=</a> -- Enable/disable joystick event polling</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-427">SDL::Joystick.poll</a> -- Gets the current state of joysick event polling</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-428">SDL::Joystick.update_all</a> -- Updates the state of all joysticks</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-430">SDL::Joystick#axis</a> -- Get the current state of an axis</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-431">SDL::Joystick#hat</a> -- Get the current state of a joystick hat</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-432">SDL::Joystick#button</a> -- Get the current state of a given button</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-433">SDL::Joystick#ball</a> -- Get relative trackball motion</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-434">SDL::Joystick#close</a> -- Closes a previously opened joystick</li>
</ul></li>
</ul>
<h2><a name="label-409" id="label-409">Joystick Overview</a></h2><!-- RDLabel: "Joystick Overview" -->
<p>Joysticks, and other similar input devices, have a very 
strong role
in game playing and SDL provides comprehensive support for them.
Axes, Buttons, POV Hats and trackballs are all supported.</p>
<p>Joystick support is initialized
by passed the SDL::INIT_JOYSTICK flag
to <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a>. Once initilized joysticks must be opened
using <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-415">SDL::Joystick.open</a>.</p>
<p>While using the functions describe in this secton 
may seem like the best way
to access and read from joysticks, in most cases they aren't.
Ideally joysticks should be read
using the <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-301">SDL::Event</a> system.
To enable this, you must set the joystick event processing state
with <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-426">SDL::Joystick.poll=</a>.
Joysticks must be <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-415">opened</a>
before they can be used of course.</p>
<ul>
<li><p>NOTES</p>
<p>If you are <em>not</em> handling the joystick
via the event queue then you must explicitly 
request a joystick update by calling <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-428">SDL::Joystick.update_all</a>.</p>
<p>Force Feedback is not yet support.</p></li>
</ul>
<h2><a name="label-410" id="label-410">SDL::Joystick</a></h2><!-- RDLabel: "SDL::Joystick" -->
<p>The class represents one joystick.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-412">SDL::Joystick.num</a> -- Count available joysticks.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-413">SDL::Joystick.index_name</a> -- Get joystick name.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-415">SDL::Joystick.open</a> -- Opens a joystick for use.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-416">SDL::Joystick.open?</a> -- Determine if a joystick has been opened</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-417">SDL::Joystick#index</a> -- Get the index of an joystick.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-418">SDL::Joystick#num_axes</a> -- Get the number of joystick axes</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-420">SDL::Joystick#num_balls</a> -- Get the number of joystick trackballs</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-422">SDL::Joystick#num_hats</a> -- Get the number of joystick hats</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-424">SDL::Joystick#num_buttons</a> -- Get the number of joystick buttons</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-426">SDL::Joystick.poll=</a> -- Enable/disable joystick event polling</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-427">SDL::Joystick.poll</a> -- Gets the current state of joysick event polling</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-428">SDL::Joystick.update_all</a> -- Updates the state of all joysticks</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-430">SDL::Joystick#axis</a> -- Get the current state of an axis</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-431">SDL::Joystick#hat</a> -- Get the current state of a joystick hat</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-432">SDL::Joystick#button</a> -- Get the current state of a given button</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-433">SDL::Joystick#ball</a> -- Get relative trackball motion</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-434">SDL::Joystick#close</a> -- Closes a previously opened joystick</li>
</ul>
<h2><a name="label-411" id="label-411">Methods</a></h2><!-- RDLabel: "Methods" -->
<dl>
<dt><a name="label-412" id="label-412"><code>SDL::Joystick.num</code></a></dt><!-- RDLabel: "SDL::Joystick.num" -->
<dd>
Counts the number of joysticks attached to the system.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-413">SDL::Joystick.index_name</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-415">SDL::Joystick.open</a></p></li>
</ul></dd>
<dt><a name="label-413" id="label-413"><code>SDL::Joystick.index_name(<var>index</var>)</code></a></dt><!-- RDLabel: "SDL::Joystick.index_name" -->
<dt><a name="label-414" id="label-414"><code>SDL::Joystick.indexName(<var>index</var>)</code></a></dt><!-- RDLabel: "SDL::Joystick.indexName" -->
<dd>
<p>Get the implementation dependent name of joystick. 
The <var>index</var> parameter
refers to the N'th joystick on the system.</p>
<p>EXAMPLE</p>
<pre># Print the names of all attached joysticks
num_joy = SDL::Joystick.num
printf("%d joysticks found\n", num_joy)
num_joy.times do |i|
  puts SDL::Joystick.index_name(i)
end</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-415">SDL::Joystick.open</a></p></li>
</ul></dd>
<dt><a name="label-415" id="label-415"><code>SDL::Joystick.open(<var>index</var>)</code></a></dt><!-- RDLabel: "SDL::Joystick.open" -->
<dd>
<p>Opens a joystick for use within SDL. The <var>index</var> refers to the N'th
joystick in the system. A joystick must be opened before it can be
used.</p>
<p>Returns a <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-410">SDL::Joystick</a> instance on success.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>EXAMPLE</p>
<pre># Check for joystick
if SDL::Joystick.num &gt; 0
  # Open joystick
  joy = SDL::Joystick.open(0)

  printf("Opened Joystick 0\n");
  printf("Name: %s\n", SDL::Joystick.name(0))
  printf("Number of Axes: %d\n", joy.num_axes)
  printf("Number of Buttons: %d\n", joy.num_buttons)
  printf("Number of Balls: %d\n", joy.num_balls)
end  </pre></dd>
<dt><a name="label-416" id="label-416"><code>SDL::Joystick.open?(<var>index</var>)</code></a></dt><!-- RDLabel: "SDL::Joystick.open?" -->
<dd>
<p>Determines whether a joystick has already been opened within the
application. <var>index</var> refers to the N'th joystick on the system.</p>
<p>Returns true if the joystick has been opened, or false if it has not.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-415">SDL::Joystick.open</a></p></li>
</ul></dd>
<dt><a name="label-417" id="label-417"><code>SDL::Joystick#index</code></a></dt><!-- RDLabel: "SDL::Joystick#index" -->
<dd>
Returns the index of <var>self</var>.</dd>
<dt><a name="label-418" id="label-418"><code>SDL::Joystick#num_axes</code></a></dt><!-- RDLabel: "SDL::Joystick#num_axes" -->
<dt><a name="label-419" id="label-419"><code>SDL::Joystick#numAxes</code></a></dt><!-- RDLabel: "SDL::Joystick#numAxes" -->
<dd>
Return the number of axes available.
<ul>
<li><p>NOTES</p>
<p>This method counts two dimensional axes as two axes.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-430">SDL::Joystick#axis</a></p></li>
</ul></dd>
<dt><a name="label-420" id="label-420"><code>SDL::Joystick#num_balls</code></a></dt><!-- RDLabel: "SDL::Joystick#num_balls" -->
<dt><a name="label-421" id="label-421"><code>SDL::Joystick#numBalls</code></a></dt><!-- RDLabel: "SDL::Joystick#numBalls" -->
<dd>
Return the number of trackballs available.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-433">SDL::Joystick#ball</a></p></li>
</ul></dd>
<dt><a name="label-422" id="label-422"><code>SDL::Joystick#num_hats</code></a></dt><!-- RDLabel: "SDL::Joystick#num_hats" -->
<dt><a name="label-423" id="label-423"><code>SDL::Joystick#numHats</code></a></dt><!-- RDLabel: "SDL::Joystick#numHats" -->
<dd>
Return the number of hats available.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-431">SDL::Joystick#hat</a></p></li>
</ul></dd>
<dt><a name="label-424" id="label-424"><code>SDL::Joystick#num_buttons</code></a></dt><!-- RDLabel: "SDL::Joystick#num_buttons" -->
<dt><a name="label-425" id="label-425"><code>SDL::Joystick#numButtons</code></a></dt><!-- RDLabel: "SDL::Joystick#numButtons" -->
<dd>
Return the number of buttons available.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-432">SDL::Joystick#button</a></p></li>
</ul></dd>
<dt><a name="label-426" id="label-426"><code>SDL::Joystick.poll=(<var>enable</var>)</code></a></dt><!-- RDLabel: "SDL::Joystick.poll=" -->
<dd>
<p>This function is used to enable or disable joystick event
processing. With joystick event processing disabled you will have
to update joystick states with <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-428">SDL::Joystick.update_all</a> and read the
joystick information manually.</p>
<p>Joystick event polling is enabled by default.</p>
<p>NOTE
Joystick event handling is preferred.</p>
<p>Even if joystick event processing is enabled,
individual joysticks must be opened before they generate
events.</p>
<p>Calling this method may delete all events
currently in SDL's event queue.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-428">SDL::Joystick.update_all</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-427">SDL::Joystick.poll</a>, <!-- Reference, RDLabel "SDL::Event2::JoyAxis" doesn't exist --><em class="label-not-found">SDL::Event2::JoyAxis</em><!-- Reference end -->, <!-- Reference, RDLabel "SDL::Event2::JoyBall" doesn't exist --><em class="label-not-found">SDL::Event2::JoyBall</em><!-- Reference end -->, <!-- Reference, RDLabel "SDL::Event2::JoyButtonDown" doesn't exist --><em class="label-not-found">SDL::Event2::JoyButtonDown</em><!-- Reference end -->, <!-- Reference, RDLabel "SDL::Event2::JoyButtonUp" doesn't exist --><em class="label-not-found">SDL::Event2::JoyButtonUp</em><!-- Reference end -->, <!-- Reference, RDLabel "SDL::Event2::JoyHat" doesn't exist --><em class="label-not-found">SDL::Event2::JoyHat</em><!-- Reference end --></p></li>
</ul></dd>
<dt><a name="label-427" id="label-427"><code>SDL::Joystick.poll</code></a></dt><!-- RDLabel: "SDL::Joystick.poll" -->
<dd>
Returns true if joysick event polling is enabled, otherwise 
returns false. You will also read <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-426">SDL::Joystick.poll=</a>.</dd>
<dt><a name="label-428" id="label-428"><code>SDL::Joystick.update_all</code></a></dt><!-- RDLabel: "SDL::Joystick.update_all" -->
<dt><a name="label-429" id="label-429"><code>SDL::Joystick.updateAll</code></a></dt><!-- RDLabel: "SDL::Joystick.updateAll" -->
<dd>
Updates the state(position, buttons, etc.) of all open joysticks.
If joystick events have been enabled with <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-426">SDL::Joystick.poll=</a>
then this is called automatically in the event loop.</dd>
<dt><a name="label-430" id="label-430"><code>SDL::Joystick#axis(<var>axis_index</var>)</code></a></dt><!-- RDLabel: "SDL::Joystick#axis" -->
<dd>
<p>Returns the current state of given <var>axis_index</var> on <var>self</var>.</p>
<p>On most modern joysticks the X axis is usually represented by
axis 0 and the Y axis by axis 1. The value returned by
this method is a signed integer (-32768 to 32767)
representing the current position of the axis, it may be
necessary to impose certain tolerances on these values to account
for jitter.</p>
<p>EXAMPLE</p>
<pre>joy = SDL::Joystick.open(0)
  .
  .
x_move = joy.axis(0)
y_move = joy.axis(1)</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-418">SDL::Joystick#num_axes</a></p></li>
</ul></dd>
<dt><a name="label-431" id="label-431"><code>SDL::Joystick#hat(<var>hat_index</var>)</code></a></dt><!-- RDLabel: "SDL::Joystick#hat" -->
<dd>
<p>Returns the current state of the given <var>hat_index</var>.</p>
<p>The current state is returned as a unsinged integer
which is an OR'd combination of one or more of the following</p>
<ul>
<li>SDL::Joystick::HAT_CENTERED</li>
<li>SDL::Joystick::HAT_UP</li>
<li>SDL::Joystick::HAT_RIGHT</li>
<li>SDL::Joystick::HAT_DOWN</li>
<li>SDL::Joystick::HAT_LEFT</li>
<li>SDL::Joystick::HAT_RIGHTUP</li>
<li>SDL::Joystick::HAT_RIGHTDOWN</li>
<li>SDL::Joystick::HAT_LEFTUP</li>
<li>SDL::Joystick::HAT_LEFTDOWN</li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-422">SDL::Joystick#num_hats</a></p></li>
</ul></dd>
<dt><a name="label-432" id="label-432"><code>SDL::Joystick#button(<var>button_index</var>)</code></a></dt><!-- RDLabel: "SDL::Joystick#button" -->
<dd>
returns the current state of the given <var>button_index</var>.
Returns true if the button is pressed, otherwise returns false.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-424">SDL::Joystick#num_buttons</a></p></li>
</ul></dd>
<dt><a name="label-433" id="label-433"><code>SDL::Joystick#ball(<var>ball_index</var>)</code></a></dt><!-- RDLabel: "SDL::Joystick#ball" -->
<dd>
<p>Get the ball axis change.
Trackballs can only return relative motion since the last call to
this method, these motion deltas are returned as 
an array of two elements, [dx, dy].</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>EXAMPLE</p>
<pre>delta_x, delta_y = joy.ball(0)
printf("Trackball Delta- X:%d, Y:%d\n", delta_x, delta_y)</pre></dd>
<dt><a name="label-434" id="label-434"><code>SDL::Joystick#close</code></a></dt><!-- RDLabel: "SDL::Joystick#close" -->
<dd>
Close a joystick that was previously opened with <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-415">SDL::Joystick.open</a>.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-415">SDL::Joystick.open</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-416">SDL::Joystick.open?</a></p></li>
</ul></dd>
</dl>
<h1><a name="label-435" id="label-435">CD-ROM</a></h1><!-- RDLabel: "CD-ROM" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-436">CD-ROM outline</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-437">SDL::CD</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-438">CD-ROM methods</a>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-439">SDL::CD.num_drives</a> -- Returns the number of CD-ROM drives on the system.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-441">SDL::CD.index_name</a> -- Returns a human-readable, system-dependent identifier for the CD-ROM.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-443">SDL::CD.open</a> -- Opens a CD-ROM drive for access.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-444">SDL::CD#status</a> -- Returns the current status of the given drive.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-445">SDL::CD#play</a> -- Play a CD</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-446">SDL::CD#play_tracks</a> -- Play the given CD track(s)</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-447">SDL::CD#pause</a> -- Pauses a CDROM</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-448">SDL::CD#resume</a> -- Resumes a CDROM</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-449">SDL::CD#stop</a> -- Stops a CDROM</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-450">SDL::CD#eject</a> -- Ejects a CDROM</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-451">SDL::CD#num_tracks</a> -- Gets number of tracks on the CD.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-453">SDL::CD#current_track</a> -- Gets current track.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-455">SDL::CD#current_frame</a> -- Gets current frame offset within the track</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-457">SDL::CD#track_type</a> -- Gets track type.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-459">SDL::CD#track_length</a> -- Gets length of track.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-461">SDL::CD#in_drive?</a> -- Check disc in drive</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-462">SDL::CD.frames_to_msf</a> -- Convert frames into minitus/seconds/frames</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-464">SDL::CD.msf_to_frames</a> -- Convert minitus/seconds/frames into frames</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-466">SDL::CD#close</a> -- Closes a CD handle</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-467">SDL::CD#closed?</a> -- Returns whether CD is closed</li>
</ul></li>
</ul>
<h2><a name="label-436" id="label-436">CD-ROM outline</a></h2><!-- RDLabel: "CD-ROM outline" -->
<p>SDL supports audio control of up to 32 local CD-ROM drives at once.</p>
<p>You use this API to perform all the basic functions of a CD player, including
listing the tracks, playing, stopping, and ejecting the CD-ROM. (Currently,
multi-changer CD drives are not supported.)</p>
<p>Before you call any of the SDL CD-ROM functions, you must first call
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a>(SDL::INIT_CDROM),
which scans the system for CD-ROM drives, and sets the program
up for audio control.</p>
<p>After you have initialized the library, you can find out how many drives are
available using the <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-439">SDL::CD.num_drives</a>. The first drive listed is the
system default CD-ROM drive. After you have chosen a drive, and have opened it
with <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-443">SDL::CD.open</a>, you can check the status and start playing if there's a CD in
the drive.</p>
<p>A CD-ROM is organized into one or more tracks, each consisting of a certain number
of "frames". Each frame is ~2K in size, and at normal playing speed,
a CD plays 75(SDL::CD::FPS)
frames per second. SDL works with the number of frames on a CD, but this can
easily be converted to the more familiar minutes/seconds format by using
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-462">SDL::CD.frames_to_msf</a>.</p>
<h2><a name="label-437" id="label-437">SDL::CD</a></h2><!-- RDLabel: "SDL::CD" -->
<p>This class represents opened CDROM device and stores information on the
layout of the tracks on the disc.</p>
<h2><a name="label-438" id="label-438">CD-ROM methods</a></h2><!-- RDLabel: "CD-ROM methods" -->
<dl>
<dt><a name="label-439" id="label-439"><code>SDL::CD.num_drives</code></a></dt><!-- RDLabel: "SDL::CD.num_drives" -->
<dt><a name="label-440" id="label-440"><code>SDL::CD.numDrives</code></a></dt><!-- RDLabel: "SDL::CD.numDrives" -->
<dd>
Returns the number of CD-ROM drives on the system.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-443">SDL::CD.open</a></p></li>
</ul></dd>
<dt><a name="label-441" id="label-441"><code>SDL::CD.index_name(<var>drive</var>)</code></a></dt><!-- RDLabel: "SDL::CD.index_name" -->
<dt><a name="label-442" id="label-442"><code>SDL::CD.indexName(<var>drive</var>)</code></a></dt><!-- RDLabel: "SDL::CD.indexName" -->
<dd>
<p>Returns a human-readable, system-dependent identifier for the CD-ROM. <var>drive</var>
is the index of the drive.
Drive indices start to 0 and end at <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-439">SDL::CD.num_drives</a>-1.</p>
<p>Examples of return strings.</p>
<ul>
<li>"/dev/cdrom"</li>
<li>"E:"</li>
<li>"/dev/disk/ide/1/master"</li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-439">SDL::CD.num_drives</a></p></li>
</ul></dd>
<dt><a name="label-443" id="label-443"><code>SDL::CD.open(<var>drive</var>)</code></a></dt><!-- RDLabel: "SDL::CD.open" -->
<dd>
<p>Opens a CD-ROM drive for access. It returns <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-437">SDL::CD</a> object on success.</p>
<p>Drives are numbered starting with 0. Drive 0 is the system default CD-ROM.</p>
<p>Raise <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> if the drive was invalid or busy.</p>
<p>EXAMPLE</p>
<pre>SDL.init SDL::INIT_CDROM

# Check for CD drives
if SDL::CD.num_drives == 0
  # None found
  STDERR.print "No CDROM devices available\n"
  exit 255
end

begin
  # Open the default drive
  cdrom = SDL::CD.open(0)
rescue SDL::Error
  STDERR.puts "Couldn't open drive"
  exit 255
end

# Print volume info
printf "Name: %s\n", SDL::CD.index_name(0)
printf "Tracks: %d\n", cdrom.num_tracks
num_tracks.times do |cur_track|
  min, sec, frame = SDL::CD.frames_to_msf(cdrom.track_length(cur_track))
  printf "\tTrack %d: Length %d:%d\n", cur_track, min, sec
end</pre></dd>
<dt><a name="label-444" id="label-444"><code>SDL::CD#status</code></a></dt><!-- RDLabel: "SDL::CD#status" -->
<dd>
<p>This method returns the current status of the given drive. Status is described
like so:</p>
<ul>
<li>SDL::CD::TRAYEMPTY</li>
<li>SDL::CD::STOPPED</li>
<li>SDL::CD::PLAYING</li>
<li>SDL::CD::PAUSED</li>
<li>SDL::CD::ERROR</li>
</ul>
<p>If the drive has a CD in it,
<!-- Reference, RDLabel "SDL.current_track" doesn't exist --><em class="label-not-found">SDL.current_track</em><!-- Reference end -->, <!-- Reference, RDLabel "SDL.current_frame" doesn't exist --><em class="label-not-found">SDL.current_frame</em><!-- Reference end -->, <!-- Reference, RDLabel "SDL.num_tracks" doesn't exist --><em class="label-not-found">SDL.num_tracks</em><!-- Reference end -->, <!-- Reference, RDLabel "SDL.track_type" doesn't exist --><em class="label-not-found">SDL.track_type</em><!-- Reference end -->,
and <!-- Reference, RDLabel "SDL.track_length" doesn't exist --><em class="label-not-found">SDL.track_length</em><!-- Reference end --> are updated.</p>
<p>EXAMPLE</p>
<pre>def play_track(track)
  raise "not cd in drive" unless $cdrom.in_drive?

  # clamp to the actual number of tracks on the CD
  track = $cdrom.num_tracks-1 if track &gt;= $cdrom.num_tracks
  $cdrom.play_tracks(track, 0, 1, 0)
end</pre></dd>
<dt><a name="label-445" id="label-445"><code>SDL::CD#play(<var>start</var>, <var>length</var>)</code></a></dt><!-- RDLabel: "SDL::CD#play" -->
<dd>
<p>Plays the given cdrom, starting a frame <var>start</var> for length <var>frames</var>.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-446">SDL::CD#play_tracks</a></p></li>
</ul></dd>
<dt><a name="label-446" id="label-446"><code>SDL::CD#play_tracks(<var>start_track</var>, <var>start_frame</var>, <var>ntracks</var>, <var>nframes</var>)</code></a></dt><!-- RDLabel: "SDL::CD#play_tracks" -->
<dd>
<p>This method plays the given CD starting at track <var>start_track</var>, for <var>ntracks</var>
tracks.</p>
<p><var>start_frame</var> is the frame offset, from the beginning of the <var>start_track</var>,
at which to start. $nframes] is the frame offset, from the beginning
of the last track
(<var>start_track</var>+<var>ntracks</var>), at which to end playing.</p>
<p>THis methods should only be called after calling <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-444">SDL::CD#status</a> to get track
information about the CD.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>EXAMPLE</p>
<pre># assuming cdrom is a previously opened device
# Play the entire CD
if cdrom.in_drive?
  cdrom.play_tracks 0, 0, 0, 0
end
# Play the first track
if cdrom.in_drive?
  cdrom.play_tracks 0, 0, 1, 0
end
# 2 Play first 15 seconds of the 2nd track
if cdrom.in_drive?
  cdrom.play_tracks 1, 0, 0, SDL::CD::FPS*15
end</pre>
<ul>
<li><p>NOTES</p>
<p>Data tracks are ignored.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-445">SDL::CD#play</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-444">SDL::CD#status</a></p></li>
</ul></dd>
<dt><a name="label-447" id="label-447"><code>SDL::CD#pause</code></a></dt><!-- RDLabel: "SDL::CD#pause" -->
<dd>
<p>Pauses play on the given cdrom.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-445">SDL::CD#play</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-448">SDL::CD#resume</a></p></li>
</ul></dd>
<dt><a name="label-448" id="label-448"><code>SDL::CD#resume</code></a></dt><!-- RDLabel: "SDL::CD#resume" -->
<dd>
<p>Resumes play on the given cdrom.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-445">SDL::CD#play</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-447">SDL::CD#pause</a></p></li>
</ul></dd>
<dt><a name="label-449" id="label-449"><code>SDL::CD#stop</code></a></dt><!-- RDLabel: "SDL::CD#stop" -->
<dd>
<p>Stops play on the given cdrom.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-445">SDL::CD#play</a></p></li>
</ul></dd>
<dt><a name="label-450" id="label-450"><code>SDL::CD#eject</code></a></dt><!-- RDLabel: "SDL::CD#eject" -->
<dd>
<p>Ejects the given cdrom.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p></dd>
<dt><a name="label-451" id="label-451"><code>SDL::CD#num_tracks</code></a></dt><!-- RDLabel: "SDL::CD#num_tracks" -->
<dt><a name="label-452" id="label-452"><code>SDL::CD#numTracks</code></a></dt><!-- RDLabel: "SDL::CD#numTracks" -->
<dd>
Returns the number of tracks on the given cdrom.
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-444">SDL::CD#status</a> updates this value.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-444">SDL::CD#status</a></p></li>
</ul></dd>
<dt><a name="label-453" id="label-453"><code>SDL::CD#current_track</code></a></dt><!-- RDLabel: "SDL::CD#current_track" -->
<dt><a name="label-454" id="label-454"><code>SDL::CD#currentTrack</code></a></dt><!-- RDLabel: "SDL::CD#currentTrack" -->
<dd>
Returns the currently playing track.
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-444">SDL::CD#status</a> updates this value.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-444">SDL::CD#status</a></p></li>
</ul></dd>
<dt><a name="label-455" id="label-455"><code>SDL::CD#current_frame</code></a></dt><!-- RDLabel: "SDL::CD#current_frame" -->
<dt><a name="label-456" id="label-456"><code>SDL::CD#currentFrame</code></a></dt><!-- RDLabel: "SDL::CD#currentFrame" -->
<dd>
Returns the current frame offset with the playing track.
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-444">SDL::CD#status</a> updates this value.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-444">SDL::CD#status</a></p></li>
</ul></dd>
<dt><a name="label-457" id="label-457"><code>SDL::CD#track_type(<var>track</var>)</code></a></dt><!-- RDLabel: "SDL::CD#track_type" -->
<dt><a name="label-458" id="label-458"><code>SDL::CD#trackType(<var>track</var>)</code></a></dt><!-- RDLabel: "SDL::CD#trackType" -->
<dd>
Returns the track type in <var>track</var>.
SDL::CD::AUDIO_TRACK or SDL::CD::DATA_TRACK is returned.</dd>
<dt><a name="label-459" id="label-459"><code>SDL::CD#track_length(<var>track</var>)</code></a></dt><!-- RDLabel: "SDL::CD#track_length" -->
<dt><a name="label-460" id="label-460"><code>SDL::CD#trackLength(<var>track</var>)</code></a></dt><!-- RDLabel: "SDL::CD#trackLength" -->
<dd>
Returns length, in frame, of <var>track</var>.</dd>
<dt><a name="label-461" id="label-461"><code>SDL::CD#in_drive?</code></a></dt><!-- RDLabel: "SDL::CD#in_drive?" -->
<dd>
Returns true if drive is not empty, otherwise returns false.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-444">SDL::CD#status</a></p></li>
</ul></dd>
<dt><a name="label-462" id="label-462"><code>SDL::CD.frames_to_msf(<var>frames</var>)</code></a></dt><!-- RDLabel: "SDL::CD.frames_to_msf" -->
<dt><a name="label-463" id="label-463"><code>SDL::CD.framesToMSF(<var>frames</var>)</code></a></dt><!-- RDLabel: "SDL::CD.framesToMSF" -->
<dd>
Converts frames into minitus/seconds/frames, and returns an array like
[min, sec, frames].
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-464">SDL::CD.msf_to_frames</a></p></li>
</ul></dd>
<dt><a name="label-464" id="label-464"><code>SDL::CD.msf_to_frames(<var>min</var>, <var>sec</var>, <var>frames</var>)</code></a></dt><!-- RDLabel: "SDL::CD.msf_to_frames" -->
<dt><a name="label-465" id="label-465"><code>SDL::CD.MSFToFrames(<var>min</var>, <var>sec</var>, <var>frames</var>)</code></a></dt><!-- RDLabel: "SDL::CD.MSFToFrames" -->
<dd>
Convert minitus/seconds/frames into frames and returns frames.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-462">SDL::CD.frames_to_msf</a></p></li>
</ul></dd>
<dt><a name="label-466" id="label-466"><code>SDL::CD#close</code></a></dt><!-- RDLabel: "SDL::CD#close" -->
<dd>
Closes <var>self</var>.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-443">SDL::CD.open</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-467">SDL::CD#closed?</a></p></li>
</ul></dd>
<dt><a name="label-467" id="label-467"><code>SDL::CD#closed?</code></a></dt><!-- RDLabel: "SDL::CD#closed?" -->
<dd>
Returns whether CD handle is closed by
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-466">SDL::CD#close</a>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-466">SDL::CD#close</a></p></li>
</ul></dd>
</dl>
<h1><a name="label-468" id="label-468">Audio</a></h1><!-- RDLabel: "Audio" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-469">Audio subsystem outline</a></li>
<li><!-- Reference, RDLabel "Audio Format" doesn't exist --><em class="label-not-found">Audio Format</em><!-- Reference end --></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-471">SDL::Mixer</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-472">SDL::Mixer::Wave</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-473">SDL::Mixer::Music</a></li>
<li>Audio methods
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-475">SDL::Mixer.open</a> -- Initialize the mixer API.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-486">SDL::Mixer.spec</a> -- Get the actual audio format in use by the opened audio device</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-487">SDL::Mixer.driver_name</a> -- Gets the audio device name</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-489">SDL::Mixer::Wave.load</a> -- Load file for use as a sample.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-490">SDL::Mixer::Wave.load_from_io</a> -- Read IO object for use as a sample.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-492">SDL::Mixer::Wave#destroy</a> -- Frees an audio chunk.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-493">SDL::Mixer::Wave#destroyed?</a> -- Returns whether an audio chunk is destroyed.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-494">SDL::Mixer::Music.load</a> -- Load music file.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-495">SDL::Mixer::Music.load_from_string</a> -- Convert string into music data.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-497">SDL::Mixer::Music#destroy</a> -- Frees an music data.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-498">SDL::Mixer::Music#destroyed?</a> -- Returns whether an music data is destroyed.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-499">SDL::Mixer::Wave#set_volume</a> -- Set volume </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-501">SDL::Mixer.allocate_channels</a> -- Set the number of channels to mix</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-503">SDL::Mixer.set_volume</a> -- Set the mix volume of a channel</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-505">SDL::Mixer.play_channel</a> -- Play loop</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-507">SDL::Mixer.play_channel_timed</a> -- Play loop and limit by time</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-509">SDL::Mixer.fade_in_channel</a> -- Play loop with fade in</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-511">SDL::Mixer.fade_in_channel_timed</a> -- Play loop with fade in and limit by time</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-513">SDL::Mixer.pause</a> -- Pause the channel</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-514">SDL::Mixer.resume</a> -- Resume a paused channel</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-515">SDL::Mixer.halt</a> -- Stop playing on a channel</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-516">SDL::Mixer.expire</a> -- Change the timed stoppage of a channel</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-517">SDL::Mixer.fade_out</a> -- Stop playing channel after timed fade out</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-519">SDL::Mixer.play?</a> -- Get the active playing status of a channel</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-520">SDL::Mixer.playing_channels</a> -- Get the number of active playing channels</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-522">SDL::Mixer.pause?</a> -- Get the pause status of a channel</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-523">SDL::Mixer.fading</a> -- Get the fade status of a channel</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-524">SDL::Mixer.play_music</a> -- Play music, with looping</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-526">SDL.fade_in_music</a> -- Play music, with looping, and fade in</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-528">SDL::Mixer.set_volume_music</a> -- Set music volume</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-530">SDL::Mixer.pause_music</a> -- Pause music</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-532">SDL::Mixer.resume_music</a> -- Resume paused music</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-534">SDL::Mixer.rewind_music</a> -- Rewind music to beginning</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-536">SDL::Mixer.halt_music</a> -- Stop music playback</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-538">SDL::Mixer.fade_out_music</a> -- Stop music, with fade out</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-540">SDL::Mixer.play_music?</a> -- Test whether music is playing</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-542">SDL::Mixer.pause_music?</a> -- Test whether music is paused</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-544">SDL::Mixer.fading_music</a> -- Get status of current music fade activity</li>
</ul></li>
</ul>
<h2><a name="label-469" id="label-469">Audio subsystem outline</a></h2><!-- RDLabel: "Audio subsystem outline" -->
<p>SDL has portable and low-level audio playback system. 
Because this system is too low-level to use from Ruby,
you can use only SDL_mixer functions from Ruby.
So you should install SDL_mixer before using audio playback.</p>
<p>Due to popular demand, here is a simple multi-channel audio mixer. It supports 8 channels of 16 bit
stereo audio, plus a single channel of music, mixed by the popular MikMod MOD, Timidity MIDI and SMPEG
MP3 libraries.</p>
<p>The process of mixing MIDI files to wave output is very CPU intensive, so if playing regular WAVE files
sound great, but playing MIDI files sound choppy, try using 8-bit audio, mono audio, or lower
frequencies.</p>
<p>To play MIDI files, you'll need to get a complete set of GUS patches from:
<a href="http://www.libsdl.org/projects/mixer/timidity/timidity.tar.gz">Timidity GUS Patches</a>
and unpack them in /usr/local/lib under UNIX, and C:\ under Win32.</p>
<h2><a name="label-470" id="label-470">Available audio formats</a></h2><!-- RDLabel: "Available audio formats" -->
<p>Ruby/SDL supports playing music and sound samples from the following formats:
- WAVE/RIFF (.wav)
- AIFF (.aiff)
- VOC (.voc)
- MOD (.mod .xm .s3m .669 .it .med and more) using included mikmod
- MIDI (.mid) using timidity or native midi hardware
- OggVorbis (.ogg) requiring ogg/vorbis libraries on system
- MP3 (.mp3) requiring SMPEG library on system</p>
<p>Some reports from Windows users say that programs playing
MP3 sometimes hung up, so please don't play MP3 on Ruby/SDL.</p>
<h2><a name="label-471" id="label-471">SDL::Mixer</a></h2><!-- RDLabel: "SDL::Mixer" -->
<p>Module for audio playback subsystem.</p>
<h2><a name="label-472" id="label-472">SDL::Mixer::Wave</a></h2><!-- RDLabel: "SDL::Mixer::Wave" -->
<p>Class for sound samples. Ruby/SDL can play those samples with multi-channel.
Support formats are WAVE, AIFF, RIFF, OGG, VOC.</p>
<h2><a name="label-473" id="label-473">SDL::Mixer::Music</a></h2><!-- RDLabel: "SDL::Mixer::Music" -->
<p>Class for audio data.
Suppor formats are WAVE, MOD, MIDI, OGG, MP3.</p>
<h2><a name="label-474" id="label-474">Audio methods</a></h2><!-- RDLabel: "Audio methods" -->
<dl>
<dt><a name="label-475" id="label-475"><code>SDL::Mixer.open(<var>frequency</var>=<var>Mixer</var>::<var>DEFAULT_FREQUENCY</var>,<var>format</var>=<var>Mixer</var>::<var>DEFAULT_FORMAT</var>,<var>cannels</var>=<var>Mixer</var>::<var>DEFAULT_CHANNELS</var>,<var>chunksize</var>=<var>4096</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.open" -->
<dd>
<p>Initialize the mixer API.
This must be called before using other functions in this library.
SDL must be initialized with SDL::INIT_AUDIO before this call. <var>frequency</var></p>
<pre>would be 44100 for 44.1KHz, which is CD audio rate. Most games use 22050, </pre>
<p>because 44100 requires too much CPU power on older computers.
<var>chunksize</var> is the size of each mixed sample. The smaller this is the more your hooks will be called. If
make this too small on a slow system, sound may skip. If made to large, sound effects will lag behind the
action more. You want a happy medium for your target computer. You also may make this 4096, or larger, if
you are just playing music. SDL::Mixer::CHANNELS(8)</p>
<pre>mixing channels will be allocated by default. </pre>
<p><var>format</var> are the values listed there:</p>
<dl>
<dt><a name="label-476" id="label-476">SDL::Mixer::FORMAT_U8</a></dt><!-- RDLabel: "SDL::Mixer::FORMAT_U8" -->
<dd>
Unsigned 8-bit samples
</dd>
<dt><a name="label-477" id="label-477">SDL::Mixer::FORMAT_S8</a></dt><!-- RDLabel: "SDL::Mixer::FORMAT_S8" -->
<dd>
Signed 8-bit samples
</dd>
<dt><a name="label-478" id="label-478">SDL::Mixer::FORMAT_U16LSB</a></dt><!-- RDLabel: "SDL::Mixer::FORMAT_U16LSB" -->
<dd>
Unsigned 16-bit samples, in little-endian byte order
</dd>
<dt><a name="label-479" id="label-479">SDL::Mixer::FORMAT_S16LSB</a></dt><!-- RDLabel: "SDL::Mixer::FORMAT_S16LSB" -->
<dd>
Signed 16-bit samples, in little-endian byte order
</dd>
<dt><a name="label-480" id="label-480">SDL::Mixer::FORMAT_U16MSB</a></dt><!-- RDLabel: "SDL::Mixer::FORMAT_U16MSB" -->
<dd>
Unsigned 16-bit samples, in big-endian byte order
</dd>
<dt><a name="label-481" id="label-481">SDL::Mixer::FORMAT_S16MSB</a></dt><!-- RDLabel: "SDL::Mixer::FORMAT_S16MSB" -->
<dd>
Signed 16-bit samples, in big-endian byte order
</dd>
<dt><a name="label-482" id="label-482">SDL::Mixer::FORMAT_U16</a></dt><!-- RDLabel: "SDL::Mixer::FORMAT_U16" -->
<dd>
same as FORMAT_U16LSB (for backwards compatability probably)
</dd>
<dt><a name="label-483" id="label-483">SDL::Mixer::FORMAT_S16</a></dt><!-- RDLabel: "SDL::Mixer::FORMAT_S16" -->
<dd>
same as FORMAT_S16LSB (for backwards compatability probably)
</dd>
<dt><a name="label-484" id="label-484">SDL::Mixer::FORMAT_U16SYS</a></dt><!-- RDLabel: "SDL::Mixer::FORMAT_U16SYS" -->
<dd>
Unsigned 16-bit samples, in system byte order
</dd>
<dt><a name="label-485" id="label-485">SDL::Mixer::FORMAT_S16SYS</a></dt><!-- RDLabel: "SDL::Mixer::FORMAT_S16SYS" -->
<dd>
Signed 16-bit samples, in system byte order
</dd>
</dl>
<p>SDL::DEFAULT_FORMAT is SDL::Mixer::FORMAT_S16SYS.</p>
<p><var>channels</var> is number of sound channels in output.
Set to 2 for stereo, 1 for mono. This has nothing to do with mixing channels.
Mixer::DEFAULT_CHANNELS is 2.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>EXAMPLE</p>
<pre># start SDL with audio support
SDL.init(SDL::INIT_AUDIO)
# 44.1KHz, signed 16bit, system byte order, stereo audio
# using 1024 byte chunksize
SDL::Mixer.open(44100, SDL::Mixer::DEFAULT_FORMAT, 2, 1024)</pre>
<ul>
<li><p>NOTES</p>
<p>If you observe sound skipping and delaying, you may change some parameters to
resolve such problems. 
Please try to change <var>frequency</var>, <var>chunksize</var> and <var>format</var> parameter.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-486">SDL::Mixer.spec</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-501">SDL::Mixer.allocate_channels</a></p></li>
</ul></dd>
<dt><a name="label-486" id="label-486"><code>SDL::Mixer.spec</code></a></dt><!-- RDLabel: "SDL::Mixer.spec" -->
<dd>
<p>Returns the actual audio format in use by the opened audio device.
This may or may not match the parameters you passed to <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-475">SDL::Mixer.open</a>.
Return value is array of three elements: [frequency, format, channels].</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>EXAMPLE</p>
<pre>frequency, format, channels = SDL::Mixer.spec
format_str = case format
when SDL::Mixer::AUDIO_U8 then "U8"
when SDL::Mixer::AUDIO_S8 then "S8"
when SDL::Mixer::AUDIO_U16LSB then "U16LSB"
when SDL::Mixer::AUDIO_S16LSB then "S16LSB"
when SDL::Mixer::AUDIO_U16MSB then "U16MSB"
when SDL::Mixer::AUDIO_S16MSB then "S16MSB"
end

printf "frequency=%dHz format=%s channels=%d", frequency, format_str, channels</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-475">SDL::Mixer.open</a></p></li>
</ul></dd>
<dt><a name="label-487" id="label-487"><code>SDL::Mixer.driver_name</code></a></dt><!-- RDLabel: "SDL::Mixer.driver_name" -->
<dt><a name="label-488" id="label-488"><code>SDL::Mixer.driverName</code></a></dt><!-- RDLabel: "SDL::Mixer.driverName" -->
<dd>
<p>Returns the opened audio device name as String.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-475">Error] if audio playback system is not @[opened</a> yet.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-475">SDL::Mixer.open</a></p></li>
</ul></dd>
<dt><a name="label-489" id="label-489"><code>SDL::Mixer::Wave.load(<var>filename</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer::Wave.load" -->
<dd>
<p>Load file for use as a sample and returns the instance of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-472">SDL::Mixer::Wave</a>.
<var>filename</var> is name of wave file to use.
This can load WAVE, AIFF, RIFF, OGG, and VOC files.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>NOTES</p>
<p>You must call <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-475">SDL::Mixer.open</a> before calling this method.
It must know the output characteristics so it can convert the sample for playback, it does
this conversion at load time. Therefore you should pay attention to memory consumption.</p></li>
</ul></dd>
<dt><a name="label-490" id="label-490"><code>SDL::Mixer::Wave.load_from_io(<var>io</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer::Wave.load_from_io" -->
<dt><a name="label-491" id="label-491"><code>SDL::Mixer::Wave.loadFromIO(<var>io</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer::Wave.loadFromIO" -->
<dd>
<p>Read from Ruby's IO object (IO, StringIO or other objects with read, tell, rewind)
and returns the instance of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-472">SDL::Mixer::Wave</a>.
This can read WAVE, AIFF, RIFF, OGG, and VOC files.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>NOTES</p>
<p>You must call <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-475">SDL::Mixer.open</a> before calling this method.
It must know the output characteristics so it can convert the sample for playback, it does
this conversion at load time. Therefore you should pay attention to memory consumption.</p></li>
</ul></dd>
<dt><a name="label-492" id="label-492"><code>SDL::Mixer::Wave#destroy</code></a></dt><!-- RDLabel: "SDL::Mixer::Wave#destroy" -->
<dd>
Frees an audio chunk previously loaded.
If this method is called, all operations are forbidden.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-493">SDL::Mixer::Wave#destroyed?</a></p></li>
</ul></dd>
<dt><a name="label-493" id="label-493"><code>SDL::Mixer::Wave#destroyed?</code></a></dt><!-- RDLabel: "SDL::Mixer::Wave#destroyed?" -->
<dd>
Returns whether au audio chunk is destroyed by
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-492">SDL::Mixer::Wave#destroy</a>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-492">SDL::Mixer::Wave#destroy</a></p></li>
</ul></dd>
<dt><a name="label-494" id="label-494"><code>SDL::Mixer::Music.load(<var>filename</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer::Music.load" -->
<dd>
<p>Load music file to use and returns a instance of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-473">SDL::Mixer::Music</a>.
<var>filename</var> is a name of music file to use.
This can load WAVE, MOD, MIDI, OGG, MP3, and any file that you use a command to
play with.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>NOTES</p>
<p>Need SMPEG library to load MP3.</p></li>
</ul></dd>
<dt><a name="label-495" id="label-495"><code>SDL::Mixer::Music.load_from_string(<var>str</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer::Music.load_from_string" -->
<dt><a name="label-496" id="label-496"><code>SDL::Mixer::Music.loadFromString(<var>str</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer::Music.loadFromString" -->
<dd>
<p>Convert <var>str</var> string into music data and returns a instance of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-473">SDL::Mixer::Music</a>.
This can load WAVE, MOD and OGG.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>NOTES</p>
<p>In this method, copy <var>str</var> and store it in returned object.
Therefore this method may cause the large memory consumption.</p>
<p>On Windows, it may be impossible to use this method.</p></li>
</ul></dd>
<dt><a name="label-497" id="label-497"><code>SDL::Mixer::Music#destroy</code></a></dt><!-- RDLabel: "SDL::Mixer::Music#destroy" -->
<dd>
Frees an music data previously loaded.
If this method is called, all operations are forbidden.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-498">SDL::Mixer::Music#destroyed?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-492">SDL::Mixer::Wave#destroy</a></p></li>
</ul></dd>
<dt><a name="label-498" id="label-498"><code>SDL::Mixer::Music#destroyed?</code></a></dt><!-- RDLabel: "SDL::Mixer::Music#destroyed?" -->
<dd>
Returns whether a music data is destroyed by
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-497">SDL::Mixer::Music#destroy</a>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-497">SDL::Mixer::Music#destroy</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-493">SDL::Mixer::Wave#destroyed?</a></p></li>
</ul></dd>
<dt><a name="label-499" id="label-499"><code>SDL::Mixer::Wave#set_volume(<var>volume</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer::Wave#set_volume" -->
<dt><a name="label-500" id="label-500"><code>SDL::Mixer::Wave#setVolume(<var>volume</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer::Wave#setVolume" -->
<dd>
Set wave volume to <var>volume</var>. <var>volume</var> should be in 0..128.</dd>
<dt><a name="label-501" id="label-501"><code>SDL::Mixer.allocate_channels(<var>num_channels</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.allocate_channels" -->
<dt><a name="label-502" id="label-502"><code>SDL::Mixer.allocateChannels(<var>num_channels</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.allocateChannels" -->
<dd>
<p>Set the number of channels being mixed. This can be called
multiple times, even with sounds playing. If numchans is less
than the current number of channels, then the higher channels
will be stopped, freed, and therefore not mixed any longer. It's
probably not a good idea to change the size 1000 times a second
though.</p>
<p>Returns the number of channels allocated.</p>
<p>EXAMPLE</p>
<pre># allocate 16 mixing channels
SDL::Mixer.allocate_channels(16)</pre>
<ul>
<li><p>NOTES</p>
<p>passing in zero <em>will</em> free all mixing
channels, however music will still play.</p></li>
</ul></dd>
<dt><a name="label-503" id="label-503"><code>SDL::Mixer.set_volume(<var>channel</var>, <var>volume</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.set_volume" -->
<dt><a name="label-504" id="label-504"><code>SDL::Mixer.setVolume(<var>channel</var>, <var>volume</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.setVolume" -->
<dd>
<p>Set the <var>volume</var> for any allocated <var>channel</var>. 
If <var>channel</var> is -1 then
all channels at are set at once. The volume is applied during
the final mix, along with the sample volume. So setting this
volume to 64 will halve the output of all samples played on the
specified channel. All channels default to a volume of 128,
which is the max. Newly allocated channels will have the max
volume set, so setting all channels volumes does not affect
subsequent channel allocations.</p>
<p>Returns current volume of the channel. If channel is -1, the
average volume is returned.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-499">SDL::Mixer::Wave#set_volume</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-528">SDL::Mixer.set_volume_music</a></p></li>
</ul></dd>
<dt><a name="label-505" id="label-505"><code>SDL::Mixer.play_channel(<var>channel</var>, <var>wave</var>, <var>loops</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.play_channel" -->
<dt><a name="label-506" id="label-506"><code>SDL::Mixer.playChannel(<var>channel</var>, <var>wave</var>, <var>loops</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.playChannel" -->
<dd>
<p>Play <var>wave</var>(instance of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-472">SDL::Mixer::Wave</a>  on <var>channel</var>, or 
if <var>channel</var> is -1, pick the first free
unreserved channel. The sample will play 
for <var>loops</var>+1 number of
times, unless stopped by halt, or fade out, or setting a new
expiration time of less time than it would have originally taken
to play the loops, or closing the mixer.
if <var>loops</var> is -1, loops infinitely.</p>
<p>the channel the sample is played on.</p>
<p>EXAMPLE</p>
<pre># play sample on first free unreserved channel
# play it exactly once through
SDL::Mixer.play_channel(-1, sample, 0)</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-507">SDL::Mixer.play_channel_timed</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-509">SDL::Mixer.fade_in_channel</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-515">SDL::Mixer.halt</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-516">SDL::Mixer.expire</a></p></li>
</ul></dd>
<dt><a name="label-507" id="label-507"><code>SDL::Mixer.play_channel_timed(<var>channel</var>, <var>wave</var>, <var>loops</var>, <var>ticks</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.play_channel_timed" -->
<dt><a name="label-508" id="label-508"><code>SDL::Mixer.playChannelTimed(<var>channel</var>, <var>wave</var>, <var>loops</var>, <var>ticks</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.playChannelTimed" -->
<dd>
<p>If the <var>wave</var> is long enough and has enough <var>loops</var> then the
sample will stop after <var>ticks</var> milliseconds. Otherwise this
function is the same as <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-505">SDL::Mixer.play_channel</a>.</p>
<p>EXAMPLE</p>
<pre># play sample on first free unreserved channel
# play it for half a second
SDL::Mixer.play_channel(-1, sample, -1, 500)</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-505">SDL::Mixer.play_channel</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-511">SDL::Mixer.fade_in_channel_timed</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-517">SDL::Mixer.fade_out</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-515">SDL::Mixer.halt</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-516">SDL::Mixer.expire</a></p></li>
</ul></dd>
<dt><a name="label-509" id="label-509"><code>SDL::Mixer.fade_in_channel(<var>channel</var>, <var>wave</var>, <var>loops</var>, <var>ms</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.fade_in_channel" -->
<dt><a name="label-510" id="label-510"><code>SDL::Mixer.fadeInChannel(<var>channel</var>, <var>wave</var>, <var>loops</var>, <var>ms</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.fadeInChannel" -->
<dd>
<p>Play <var>wave</var> on <var>channel</var> with fade in.
The channel volume starts at 0 and fades up to full volume over
<var>ms</var> milliseconds of time. The sample may end before the fade-in
is complete if it is too short or doesn't have enough loops.</p>
<p>Otherwise this function is the same as <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-505">SDL::Mixer.play_channel</a>.</p>
<p>EXAMPLE</p>
<pre># play sample on first free unreserved channel
# play it exactly 3 times through
# fade in over one second
SDL::Mixer.fade_in_channel(-1, sample, 2, 1000)</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-505">SDL::Mixer.play_channel</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-511">SDL::Mixer.fade_in_channel_timed</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-523">SDL::Mixer.fading</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-517">SDL::Mixer.fade_out</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-515">SDL::Mixer.halt</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-516">SDL::Mixer.expire</a></p></li>
</ul></dd>
<dt><a name="label-511" id="label-511"><code>SDL::Mixer.fade_in_channel_timed(<var>channel</var>, <var>wave</var>, <var>loops</var>, <var>ms</var>, <var>ticks</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.fade_in_channel_timed" -->
<dt><a name="label-512" id="label-512"><code>SDL::Mixer.fadeInChannelTimed(<var>channel</var>, <var>wave</var>, <var>loops</var>, <var>ms</var>, <var>ticks</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.fadeInChannelTimed" -->
<dd>
If the sample is long enough and has enough loops then the
sample will stop after ticks milliseconds. Otherwise this
method is the same as <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-507">SDL::Mixer.play_channel_timed</a>.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-507">SDL::Mixer.play_channel_timed</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-509">SDL::Mixer.fade_in_channel</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-523">SDL::Mixer.fading</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-517">SDL::Mixer.fade_out</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-515">SDL::Mixer.halt</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-516">SDL::Mixer.expire</a></p></li>
</ul></dd>
<dt><a name="label-513" id="label-513"><code>SDL::Mixer.pause(<var>channel</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.pause" -->
<dd>
<p>Pause <var>channel</var>, or all playing channels if -1 is passed in. You
may still <var>halt|Mixer.halt</var> a paused channel.</p>
<p>EXAMPLE</p>
<pre># pause all sample playback
SDL::Mixer.pause(-1)</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-514">SDL::Mixer.resume</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-522">SDL::Mixer.pause?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-515">SDL::Mixer.halt</a></p></li>
</ul></dd>
<dt><a name="label-514" id="label-514"><code>SDL::Mixer.resume(<var>channel</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.resume" -->
<dd>
Unpause <var>channel</var>, or all playing and paused channels if -1 is
passed in.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-513">SDL::Mixer.pause</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-522">SDL::Mixer.pause?</a></p></li>
</ul></dd>
<dt><a name="label-515" id="label-515"><code>SDL::Mixer.halt(<var>channel</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.halt" -->
<dd>
Halt channel playback, or all channels if -1 is passed in.
Any callback set by Mix_ChannelFinished will be called.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-516">SDL::Mixer.expire</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-517">SDL::Mixer.fade_out</a></p></li>
</ul></dd>
<dt><a name="label-516" id="label-516"><code>SDL::Mixer.expire(<var>channel</var>, <var>ticks</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.expire" -->
<dd>
<p>Halt <var>channel</var> playback, or all channels 
if -1 is passed in, after <var>ticks</var> milliseconds.</p>
<p>Returns the number of channels set to expire. Whether or not they
are active.</p>
<p>EXAMPLE</p>
<pre># halt playback on all channels in 2 seconds
SDL::Mixer.expire(-1, 2000)</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-515">SDL::Mixer.halt</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-517">SDL::Mixer.fade_out</a></p></li>
</ul></dd>
<dt><a name="label-517" id="label-517"><code>SDL::Mixer.fade_out(<var>channel</var>, <var>ms</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.fade_out" -->
<dt><a name="label-518" id="label-518"><code>SDL::Mixer.fadeOut(<var>channel</var>, <var>ms</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.fadeOut" -->
<dd>
<p>Gradually fade out which <var>channel</var></p>
<pre>over ((|ms|)) milliseconds starting</pre>
<p>from now. The channel will be halted after the fade out is
completed. Only channels that are playing are set to fade out,
including paused channels. </p>
<p>Returns the number of channels set to fade out.</p>
<p>EXAMPLE</p>
<pre># fade out all channels to finish 3 seconds from now
printf "starting fade out of %d channels", SDL::Mixer.fade_out(-1, 3000)</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-509">SDL::Mixer.fade_in_channel</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-511">SDL::Mixer.fade_in_channel_timed</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-523">SDL::Mixer.fading</a></p></li>
</ul></dd>
<dt><a name="label-519" id="label-519"><code>SDL::Mixer.play?(<var>channel</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.play?" -->
<dd>
Returns true if <var>channel</var> is playing, otherwise
returns false.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-522">SDL::Mixer.pause?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-523">SDL::Mixer.fading</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-505">SDL::Mixer.play_channel</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-513">SDL::Mixer.pause</a></p></li>
</ul></dd>
<dt><a name="label-520" id="label-520"><code>SDL::Mixer.playing_channels</code></a></dt><!-- RDLabel: "SDL::Mixer.playing_channels" -->
<dt><a name="label-521" id="label-521"><code>SDL::Mixer.playingChannels</code></a></dt><!-- RDLabel: "SDL::Mixer.playingChannels" -->
<dd>
Returns the number of playing.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-522">SDL::Mixer.pause?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-523">SDL::Mixer.fading</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-505">SDL::Mixer.play_channel</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-513">SDL::Mixer.pause</a></p></li>
</ul></dd>
<dt><a name="label-522" id="label-522"><code>SDL::Mixer.pause?(<var>channel</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.pause?" -->
<dd>
Returns true if <var>channel</var> is paused, otherwise 
returns false.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-519">SDL::Mixer.play?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-513">SDL::Mixer.pause</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-514">SDL::Mixer.resume</a></p></li>
</ul></dd>
<dt><a name="label-523" id="label-523"><code>SDL::Mixer.fading(<var>which</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.fading" -->
<dd>
Tells you if which <var>channel</var> is fading in, out, or not. Does not
tell you if the channel is playing anything, or paused, so you'd
need to test that separately.
Returns the fading status:
<ul>
<li>SDL::Mixer::FADING_OUT</li>
<li>SDL::Mixer::FADING_IN</li>
<li>SDL::Mixer::NO_FADING</li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-519">SDL::Mixer.play?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-522">SDL::Mixer.pause?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-509">SDL::Mixer.fade_in_channel</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-511">SDL::Mixer.fade_in_channel_timed</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-517">SDL::Mixer.fade_out</a></p></li>
</ul></dd>
<dt><a name="label-524" id="label-524"><code>SDL::Mixer.play_music(<var>music</var>, <var>loops</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.play_music" -->
<dt><a name="label-525" id="label-525"><code>SDL::Mixer.playMusic(<var>music</var>, <var>loops</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.playMusic" -->
<dd>
<p>Play the loaded <var>music</var>
<var>loops</var> times through from start to finish.
The previous music will be halted, or if fading out it waits
(blocking) for that to finish.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><!-- Reference, RDLabel "SDL::Mixer.fade_in_music" doesn't exist --><em class="label-not-found">SDL::Mixer.fade_in_music</em><!-- Reference end --></p></li>
</ul></dd>
<dt><a name="label-526" id="label-526"><code>SDL.fade_in_music(<var>music</var>, <var>loops</var>, <var>ms</var>)</code></a></dt><!-- RDLabel: "SDL.fade_in_music" -->
<dt><a name="label-527" id="label-527"><code>SDL.fadeInMusic(<var>music</var>, <var>loops</var>, <var>ms</var>)</code></a></dt><!-- RDLabel: "SDL.fadeInMusic" -->
<dd>
<p>Fade in over <var>ms</var> milliseconds of time, 
the loaded <var>music</var>, playing
it <var>loops</var> times through from start to finish.
The fade in effect only applies to the first loop.
Any previous music will be halted, or if it is fading out it
will wait (blocking) for the fade to complete.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-524">SDL::Mixer.play_music</a></p></li>
</ul></dd>
<dt><a name="label-528" id="label-528"><code>SDL::Mixer.set_volume_music(<var>volume</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.set_volume_music" -->
<dt><a name="label-529" id="label-529"><code>SDL::Mixer.setVolumeMusic(<var>volume</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.setVolumeMusic" -->
<dd>
Set the volume to <var>volume</var>, if it is 0 or greater.
Setting the volume during a fade will
not work, the faders use this function to perform their effect!
<ul>
<li><p>See Also</p>
<p><!-- Reference, RDLabel "SDL::Mixer.fade_in_music" doesn't exist --><em class="label-not-found">SDL::Mixer.fade_in_music</em><!-- Reference end -->, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-538">SDL::Mixer.fade_out_music</a></p></li>
</ul></dd>
<dt><a name="label-530" id="label-530"><code>SDL::Mixer.pause_music</code></a></dt><!-- RDLabel: "SDL::Mixer.pause_music" -->
<dt><a name="label-531" id="label-531"><code>SDL::Mixer.pauseMusic</code></a></dt><!-- RDLabel: "SDL::Mixer.pauseMusic" -->
<dd>
Pause the music playback. You may <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-536">halt</a>
paused music.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-532">SDL::Mixer.resume_music</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-542">SDL::Mixer.pause_music?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-536">SDL::Mixer.halt_music</a></p></li>
</ul></dd>
<dt><a name="label-532" id="label-532"><code>SDL::Mixer.resume_music</code></a></dt><!-- RDLabel: "SDL::Mixer.resume_music" -->
<dt><a name="label-533" id="label-533"><code>SDL::Mixer.resumeMusic</code></a></dt><!-- RDLabel: "SDL::Mixer.resumeMusic" -->
<dd>
Unpause the music. This is safe to use on halted, paused, and
already playing music.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-530">SDL::Mixer.pause_music</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-542">SDL::Mixer.pause_music?</a></p></li>
</ul></dd>
<dt><a name="label-534" id="label-534"><code>SDL::Mixer.rewind_music</code></a></dt><!-- RDLabel: "SDL::Mixer.rewind_music" -->
<dt><a name="label-535" id="label-535"><code>SDL::Mixer.rewindMusic</code></a></dt><!-- RDLabel: "SDL::Mixer.rewindMusic" -->
<dd>
<p>Rewind the music to the start. This is safe to use on halted,
paused, and already playing music. It is not useful to rewind
the music immediately after starting playback, because it starts
at the beginning by default.</p>
<p>This function only works for these streams: MOD, OGG, MP3,
Native MIDI.</p></dd>
<dt><a name="label-536" id="label-536"><code>SDL::Mixer.halt_music</code></a></dt><!-- RDLabel: "SDL::Mixer.halt_music" -->
<dt><a name="label-537" id="label-537"><code>SDL::Mixer.haltMusic</code></a></dt><!-- RDLabel: "SDL::Mixer.haltMusic" -->
<dd>
Halt playback of music. This interrupts music fader effects. 
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-538">SDL::Mixer.fade_out_music</a></p></li>
</ul></dd>
<dt><a name="label-538" id="label-538"><code>SDL::Mixer.fade_out_music(<var>ms</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.fade_out_music" -->
<dt><a name="label-539" id="label-539"><code>SDL::Mixer.fadeOutMusic(<var>ms</var>)</code></a></dt><!-- RDLabel: "SDL::Mixer.fadeOutMusic" -->
<dd>
Gradually fade out the music over <var>ms</var> milliseconds starting from
now. The music will be halted after the fade out is completed.
Only when music is playing and not fading already are set to
fade out, including paused channels.</dd>
<dt><a name="label-540" id="label-540"><code>SDL::Mixer.play_music?</code></a></dt><!-- RDLabel: "SDL::Mixer.play_music?" -->
<dt><a name="label-541" id="label-541"><code>SDL::Mixer.playMusic?</code></a></dt><!-- RDLabel: "SDL::Mixer.playMusic?" -->
<dd>
Returns true if music is actively playing, otherwise
returns false.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-542">SDL::Mixer.pause_music?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-544">SDL::Mixer.fading_music</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-524">SDL::Mixer.play_music</a></p></li>
</ul></dd>
<dt><a name="label-542" id="label-542"><code>SDL::Mixer.pause_music?</code></a></dt><!-- RDLabel: "SDL::Mixer.pause_music?" -->
<dt><a name="label-543" id="label-543"><code>SDL::Mixer.pauseMusic?</code></a></dt><!-- RDLabel: "SDL::Mixer.pauseMusic?" -->
<dd>
Returns true if music is paused, otherwise returns false.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-540">SDL::Mixer.play_music?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-530">SDL::Mixer.pause_music</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-532">SDL::Mixer.resume_music</a></p></li>
</ul></dd>
<dt><a name="label-544" id="label-544"><code>SDL::Mixer.fading_music</code></a></dt><!-- RDLabel: "SDL::Mixer.fading_music" -->
<dt><a name="label-545" id="label-545"><code>SDL::Mixer.fadingMusic</code></a></dt><!-- RDLabel: "SDL::Mixer.fadingMusic" -->
<dd>
<p>Tells you if music is fading in, out, or not at all. Does not
tell you if the channel is playing anything, or paused, so you'd
need to test that separately.</p>
<p>return value is one of follwoing:</p>
<ul>
<li>SDL::Mixer::FADING_OUT</li>
<li>SDL::Mixer::FADING_IN</li>
<li>SDL::Mixer::NO_FADING</li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-523">SDL::Mixer.fading</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-542">SDL::Mixer.pause_music?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-540">SDL::Mixer.play_music?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-538">SDL::Mixer.fade_out_music</a></p></li>
</ul></dd>
</dl>
<h1><a name="label-546" id="label-546">Time</a></h1><!-- RDLabel: "Time" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-548">SDL.get_ticks</a> -- Get the number of milliseconds since the SDL library initialization</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-550">SDL.delay</a> -- Wait a specified number of milliseconds before returning</li>
</ul>
<p>SDL provides several cross-platform functions for dealing with
time.
It provides a way to get the current time
and a way to wait a little while.</p>
<h2><a name="label-547" id="label-547">Methods</a></h2><!-- RDLabel: "Methods" -->
<dl>
<dt><a name="label-548" id="label-548"><code>SDL.get_ticks</code></a></dt><!-- RDLabel: "SDL.get_ticks" -->
<dt><a name="label-549" id="label-549"><code>SDL.getTicks</code></a></dt><!-- RDLabel: "SDL.getTicks" -->
<dd>
Get the number of milliseconds since <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a> is called
Note that this value wraps if the program runs
for more than ~49 days.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-550">SDL.delay</a></p></li>
</ul></dd>
<dt><a name="label-550" id="label-550"><code>SDL.delay(<var>ms</var>)</code></a></dt><!-- RDLabel: "SDL.delay" -->
<dd>
Wait a specified number of milliseconds before returning.
This method will wait <em>at least</em> the specified time, 
but possible longer due to OS scheduling.
<ul>
<li><p>NOTES</p>
<p>Count on a delay granularity of <em>at least</em> 10 ms. Some
platforms have shorter clock ticks but this is the most
common.</p>
<p>Ruby's threads cannot preempt while waiting with this method.
You can use Kernel#sleep instead.</p></li>
</ul></dd>
</dl>
<h1><a name="label-551" id="label-551">Font</a></h1><!-- RDLabel: "Font" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-552"> Font drawing outline</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-553">SDL::TTF</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-554">SDL::BMFont</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-555">SDL::Kanji</a></li>
<li>Font methods
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-557">SDL::TTF.init</a> -- Initialize TTF APIs</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-558">SDL::TTF.init?</a> -- Query TTF API initialization status</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-559">SDL::TTF.open</a> -- Load font From a file</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-560">SDL::TTF#close</a> -- Closes a font</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-561">SDL::TTF#closed?</a> -- Returns whether a font is closed or not</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-562">SDL::TTF#style</a> -- Get font render style</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-563">SDL::TTF#style=</a> -- Set the rendering style.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-564">SDL::TTF#height</a> -- Get font max height</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-565">SDL::TTF#ascent</a> -- Get font max ascent (y above origin)</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-566">SDL::TTF#descent</a> -- Get font min descent (y below origin)</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-567">SDL::TTF#line_skip</a> -- Get font recommended line spacing</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-568">SDL::TTF#faces</a> -- Get the number of faces in a font</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-569">SDL::TTF#fixed_width?</a> -- Get whether font is monospaced or not.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-570">SDL::TTF#family_name</a> -- Get current font face family name string</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-572">SDL::TTF#style_name</a> -- Get current font face style name string</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-574">SDL::TTF#text_size</a> -- Get size of text string as would be rendered</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-576">SDL::TTF#render_solid_utf8</a> -- Render UTF8 text in solid mode</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-578">SDL::TTF#render_shaded_utf8</a> -- Render UTF8 text in shaded mode</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-580">SDL::TTF#render_blended_utf8</a> -- Render UTF8 text in blended mode</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-582">SDL::TTF#draw_solid_utf8</a> -- Draw UTF8 text in solid mode</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-584">SDL::TTF#draw_shaded_utf8</a> -- Draw UTF8 text in shaded mode</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-586">SDL::TTF#draw_blended_utf8</a> -- Draw UTF8 text in blended mode</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-588">SDL::BMFont.open</a> -- Load a bitmap font from file</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-593">SDL::BMFont#close</a> -- Closes a font.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-594">SDL::BMFont#closed?</a> -- Returns whether a font is closed.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-595">SDL::BMFont#set_color</a> -- Change font color</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-597">SDL::BMFont#height</a> -- Get height of the font</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-598">SDL::BMFont#width</a> -- Get width of one character in the font</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-599">SDL::BMFont#text_size</a> -- Get the size of surface needed</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-601">SDL::BMFont#textout</a> -- Render the given string</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-602">SDL::Kanji.open</a> -- Load bdf font file</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-603">SDL::Kanji#close</a> -- Closes bdf font data</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-604">SDL::Kanji#closed?</a> -- Returns whether bdf font is closed</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-605">SDL::Kanji#add</a> -- Add font data into already loaded font</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-606">SDL::Kanji#set_coding_system</a> -- Set character encoding</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-608">SDL::Kanji#get_coding_system</a> -- Get character encoding</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-610">SDL::Kanji#height</a> -- Get height of one character</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-611">SDL::Kanji#textwidth</a> -- Get width of given string</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-612">SDL::Kanji#width</a> -- Get the width of one character</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-613">SDL::Kanji#put</a> -- Render text</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-614">SDL::Kanji#put_tate</a> -- Render tategaki text</li>
</ul></li>
</ul>
<h2><a name="label-552" id="label-552">Font drawing outline</a></h2><!-- RDLabel: "Font drawing outline" -->
<p>Ruby/SDL has three different font drawing system.
First is True Type Font drawing by
<a href="http://www.libsdl.org/projects/SDL_ttf/index.html">SDL_ttf</a>,
second is original bitmap font/SFont drawing by
<a href="http://www.etek.chalmers.se/~e8cal1/sge/index.html">SGE</a>,
and the last is bdf font drawing by
<a href="http://shinh.skr.jp/sdlkanji/">SDL_kanji</a>.</p>
<p>Each system has following features. </p>
<ul>
<li><p>SDL::TTF</p>
<p>Extension name of Font file name is ttf and ttc.
True type font has vector data, therefore you can use arbitrary font size.</p></li>
<li><p>SDL::BMFont</p>
<p>Font files are mere Windows BMP files or PNG image files.
In original font file format, image data is regarded as 256 character
images ordered by ASCII.
Creating your own fonts is more easy than true type fonts.</p>
<p>You can use <a href="http://www.linux-games.com/sfont/">SFont</a>
with this class. This format is also bitmap font, but character width
is variable.</p>
<p>You can't use kanji and other Unicode characters.</p></li>
<li><p>SDL::Kanji</p>
<p>Font files are BDF format. BDF is a kind of bitmap font.
You can mix multiple font files (for example, alphabet and kanji).</p></li>
</ul>
<h2><a name="label-553" id="label-553">SDL::TTF</a></h2><!-- RDLabel: "SDL::TTF" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-557">SDL::TTF.init</a> -- Initialize TTF APIs</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-558">SDL::TTF.init?</a> -- Query TTF API initialization status</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-559">SDL::TTF.open</a> -- Load font From a file</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-560">SDL::TTF#close</a> -- Closes a font</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-561">SDL::TTF#closed?</a> -- Returns whether a font is closed or not</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-562">SDL::TTF#style</a> -- Get font render style</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-563">SDL::TTF#style=</a> -- Set the rendering style.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-564">SDL::TTF#height</a> -- Get font max height</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-565">SDL::TTF#ascent</a> -- Get font max ascent (y above origin)</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-566">SDL::TTF#descent</a> -- Get font min descent (y below origin)</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-567">SDL::TTF#line_skip</a> -- Get font recommended line spacing</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-568">SDL::TTF#faces</a> -- Get the number of faces in a font</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-569">SDL::TTF#fixed_width?</a> -- Get whether font is monospaced or not.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-570">SDL::TTF#family_name</a> -- Get current font face family name string</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-572">SDL::TTF#style_name</a> -- Get current font face style name string</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-574">SDL::TTF#text_size</a> -- Get size of text string as would be rendered</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-576">SDL::TTF#render_solid_utf8</a> -- Render UTF8 text in solid mode</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-578">SDL::TTF#render_shaded_utf8</a> -- Render UTF8 text in shaded mode</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-580">SDL::TTF#render_blended_utf8</a> -- Render UTF8 text in blended mode</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-582">SDL::TTF#draw_solid_utf8</a> -- Draw UTF8 text in solid mode</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-584">SDL::TTF#draw_shaded_utf8</a> -- Draw UTF8 text in shaded mode</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-586">SDL::TTF#draw_blended_utf8</a> -- Draw UTF8 text in blended mode</li>
</ul>
<p>This class represents true type font. 
<a href="http://www.libsdl.org/projects/SDL_ttf/index.html">SDL_ttf</a>
is needed to use this class. Backend of SDL_ttf is 
<a href="http://www.freetype.org/">Freetype</a>.</p>
<p>Note that you should pay attention to font license.</p>
<h2><a name="label-554" id="label-554">SDL::BMFont</a></h2><!-- RDLabel: "SDL::BMFont" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-588">SDL::BMFont.open</a> -- Load a bitmap font from file</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-593">SDL::BMFont#close</a> -- Closes a font.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-594">SDL::BMFont#closed?</a> -- Returns whether a font is closed.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-595">SDL::BMFont#set_color</a> -- Change font color</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-597">SDL::BMFont#height</a> -- Get height of the font</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-598">SDL::BMFont#width</a> -- Get width of one character in the font</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-599">SDL::BMFont#text_size</a> -- Get the size of surface needed</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-601">SDL::BMFont#textout</a> -- Render the given string</li>
</ul>
<p>This class represets bitmap font. 
<a href="http://www.etek.chalmers.se/~e8cal1/sge/index.html">SGE</a>
is needed.</p>
<h2><a name="label-555" id="label-555">SDL::Kanji</a></h2><!-- RDLabel: "SDL::Kanji" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-602">SDL::Kanji.open</a> -- Load bdf font file</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-603">SDL::Kanji#close</a> -- Closes bdf font data</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-604">SDL::Kanji#closed?</a> -- Returns whether bdf font is closed</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-605">SDL::Kanji#add</a> -- Add font data into already loaded font</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-606">SDL::Kanji#set_coding_system</a> -- Set character encoding</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-608">SDL::Kanji#get_coding_system</a> -- Get character encoding</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-610">SDL::Kanji#height</a> -- Get height of one character</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-611">SDL::Kanji#textwidth</a> -- Get width of given string</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-612">SDL::Kanji#width</a> -- Get the width of one character</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-613">SDL::Kanji#put</a> -- Render text</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-614">SDL::Kanji#put_tate</a> -- Render tategaki text</li>
</ul>
<p>This class represets bdf font. </p>
<h2><a name="label-556" id="label-556">Font methods</a></h2><!-- RDLabel: "Font methods" -->
<dl>
<dt><a name="label-557" id="label-557"><code>SDL::TTF.init</code></a></dt><!-- RDLabel: "SDL::TTF.init" -->
<dd>
<p>Initialize the truetype font API. This must be called before using other methods
of this class, excepting <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-558">SDL::TTF.init?</a>.
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a> does not have to be called before this call.</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-558">SDL::TTF.init?</a></p></li>
</ul></dd>
<dt><a name="label-558" id="label-558"><code>SDL::TTF.init?</code></a></dt><!-- RDLabel: "SDL::TTF.init?" -->
<dd>
<p>Returns true if TTF API is already initialize, otherwise returns false.</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-557">SDL::TTF.init</a></p></li>
</ul></dd>
<dt><a name="label-559" id="label-559"><code>SDL::TTF.open(<var>filename</var>, <var>ptsize</var>, <var>index</var>=<var>0</var>)</code></a></dt><!-- RDLabel: "SDL::TTF.open" -->
<dd>
<p>Load <var>filename</var>, face <var>index</var>, for use as a font, at <var>ptsize</var> size.</p>
<p>Returns new <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-553">SDL::TTF</a> object.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>You need SDL_ttf to use this method.</p>
<p>EXAMPLE</p>
<pre>SDL::TTF.init
font = SDL::TTF.open("font.ttf", 32, 0)</pre></dd>
<dt><a name="label-560" id="label-560"><code>SDL::TTF#close</code></a></dt><!-- RDLabel: "SDL::TTF#close" -->
<dd>
<p>Closes a font and free related resources.</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-561">SDL::TTF#closed?</a></p></li>
</ul></dd>
<dt><a name="label-561" id="label-561"><code>SDL::TTF#closed?</code></a></dt><!-- RDLabel: "SDL::TTF#closed?" -->
<dd>
<p>Returns whether a font is closed by <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-560">SDL::TTF#close</a></p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-560">SDL::TTF#close</a></p></li>
</ul></dd>
<dt><a name="label-562" id="label-562"><code>SDL::TTF#style</code></a></dt><!-- RDLabel: "SDL::TTF#style" -->
<dd>
<p>Returns the rendering style as a bitmask composed of the follwing masks:</p>
<ul>
<li>SDL::TTF::STYLE_BOLD</li>
<li>SDL::TTF::STYLE_ITALIC</li>
<li>SDL::TTF::STYLE_UNDERLINE</li>
</ul>
<p>If no style is set then SDL::TTF::STYLE_NORMAL is returned.</p>
<p>You need SDL_ttf to use this method.</p>
<p>EXAMPLE</p>
<pre>print "The font style is:"

print " normal" if font.style == SDL::TTF::STYLE_NORMAL
print " bold" if (font.style &amp; SDL::TTF::STYLE_BOLD) != 0
print " italic" if (font.style &amp; SDL::TTF::STYLE_ITALIC) != 0
print " italic" if (font.style &amp; SDL::TTF::STYLE_UNDERLINE) != 0

print "\n"</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-563">SDL::TTF#style=</a></p></li>
</ul></dd>
<dt><a name="label-563" id="label-563"><code>SDL::TTF#style=(<var>new_style</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#style=" -->
<dd>
<p>Set the rendering style as <var>new_style</var>.
<var>new_style</var> should be a bitmask composed of the follwing masks:</p>
<ul>
<li>SDL::TTF::STYLE_BOLD</li>
<li>SDL::TTF::STYLE_ITALIC</li>
<li>SDL::TTF::STYLE_UNDERLINE</li>
</ul>
<p>or SDL::TTF::STYLE_NORMAL to reset style.</p>
<p>You need SDL_ttf to use this method.</p>
<p>EXAMPLE</p>
<pre># set the loaded font's style to fake bold italics
font.style = SDL::TTF::STYLE_ITALIC | SDL::TTF::STYLE_BOLD

# render some text in fake bold italics...

# set the loaded font's style back to normal
font.style = SDL::TTF::STYLE_NORMAL</pre>
<ul>
<li><p>NOTES</p>
<p>This will flush the internal cache of previously rendered glyphs, even if
there is no change in style, so it may be best to check the current style using 
<!-- Reference, RDLabel "SDL::TTF.style" doesn't exist --><em class="label-not-found">SDL::TTF.style</em><!-- Reference end --> first.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-562">SDL::TTF#style</a></p></li>
</ul></dd>
<dt><a name="label-564" id="label-564"><code>SDL::TTF#height</code></a></dt><!-- RDLabel: "SDL::TTF#height" -->
<dd>
<p>Returns the maximum pixel height of all glyphs of the font. You may use this
height for rendering text as close together vertically as possible, though adding
at least one pixel height to it will space it so they can't touch. Remember that
Ruby/SDL and SDL_ttf doesn't handle multiline
printing, so you are responsible for line
spacing, see the <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-567">SDL::TTF#line_skip</a> as well.</p>
<p>You need SDL_ttf to use this method.</p></dd>
<dt><a name="label-565" id="label-565"><code>SDL::TTF#ascent</code></a></dt><!-- RDLabel: "SDL::TTF#ascent" -->
<dd>
<p>Get the maximum pixel ascent (height above baseline)
of all glyphs of the loaded font. This can also be
interpreted as the distance from the top of the font to the baseline. It could be
used when drawing an individual glyph relative to a top point, by combining it
with the glyph's maxy metric to resolve the top of the rectangle used when
blitting the glyph on the screen.</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-564">SDL::TTF#height</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-566">SDL::TTF#descent</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-567">SDL::TTF#line_skip</a></p></li>
</ul></dd>
<dt><a name="label-566" id="label-566"><code>SDL::TTF#descent</code></a></dt><!-- RDLabel: "SDL::TTF#descent" -->
<dd>
<p>Get the maximum pixel descent (height below baseline)
of all glyphs of the loaded font. This can also be
interpreted as the distance from the baseline to the bottom of the font. It could
be used when drawing an individual glyph relative to a bottom point, by combining
it with the glyph's maxy metric to resolve the top of the rectangle used when
blitting the glyph on the screen.</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-564">SDL::TTF#height</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-565">SDL::TTF#ascent</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-567">SDL::TTF#line_skip</a></p></li>
</ul></dd>
<dt><a name="label-567" id="label-567"><code>SDL::TTF#line_skip</code></a></dt><!-- RDLabel: "SDL::TTF#line_skip" -->
<dd>
<p>Get the reccomended pixel height of a rendered line of text of the loaded font.
This is usually larger than the <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-564">SDL::TTF#height</a> of the font.</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-564">SDL::TTF#height</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-565">SDL::TTF#ascent</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-566">SDL::TTF#descent</a></p></li>
</ul></dd>
<dt><a name="label-568" id="label-568"><code>SDL::TTF#faces</code></a></dt><!-- RDLabel: "SDL::TTF#faces" -->
<dd>
<p>Returns the number of faces(subfonts) in a font.</p>
<p>You need SDL_ttf to use this method.</p></dd>
<dt><a name="label-569" id="label-569"><code>SDL::TTF#fixed_width?</code></a></dt><!-- RDLabel: "SDL::TTF#fixed_width?" -->
<dd>
<p>Returns true if <var>self</var> font is monospaced, otherwise returns false.
If font is monospaced, width of the rendered surface is
(width)*(length of string).</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-568">SDL::TTF#faces</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-570">SDL::TTF#family_name</a></p></li>
</ul></dd>
<dt><a name="label-570" id="label-570"><code>SDL::TTF#family_name</code></a></dt><!-- RDLabel: "SDL::TTF#family_name" -->
<dt><a name="label-571" id="label-571"><code>SDL::TTF#familyName</code></a></dt><!-- RDLabel: "SDL::TTF#familyName" -->
<dd>
<p>Returns current font face family name string.
Returns nil if that font has no name information.</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-568">SDL::TTF#faces</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-569">SDL::TTF#fixed_width?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-572">SDL::TTF#style_name</a></p></li>
</ul></dd>
<dt><a name="label-572" id="label-572"><code>SDL::TTF#style_name</code></a></dt><!-- RDLabel: "SDL::TTF#style_name" -->
<dt><a name="label-573" id="label-573"><code>SDL::TTF#styleName</code></a></dt><!-- RDLabel: "SDL::TTF#styleName" -->
<dd>
<p>Returns current font face style name string.
Returns nil if the font has no name information.</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-568">SDL::TTF#faces</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-569">SDL::TTF#fixed_width?</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-570">SDL::TTF#family_name</a></p></li>
</ul></dd>
<dt><a name="label-574" id="label-574"><code>SDL::TTF#text_size(<var>text</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#text_size" -->
<dt><a name="label-575" id="label-575"><code>SDL::TTF#textSize(<var>text</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#textSize" -->
<dd>
<p>Calculate the resulting surface size of the UTF8 encoded text rendered using font.
No actual rendering is done, however correct kerning is done to get the actual
width. The height returned in h is the same as you can get using <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-564">SDL::TTF#height</a>.</p>
<p>Returns a 2 element array as [w, h].</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>You need SDL_ttf to use this method.</p>
<p>EXAMPLE</p>
<pre>w, h = font.size_text("Hello World!")
puts "width=#{w} height=#{h}"</pre>
<ul>
<li><p>NOTES</p>
<p>If Ruby/SDL m17n support is enabled, 
<var>text</var> will be converted to suitable encoding.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-576">SDL::TTF#render_solid_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-578">SDL::TTF#render_shaded_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-580">SDL::TTF#render_blended_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-582">SDL::TTF#draw_solid_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-584">SDL::TTF#draw_shaded_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-586">SDL::TTF#draw_blended_utf8</a></p></li>
</ul></dd>
<dt><a name="label-576" id="label-576"><code>SDL::TTF#render_solid_utf8(<var>text</var>, <var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#render_solid_utf8" -->
<dt><a name="label-577" id="label-577"><code>SDL::TTF#renderSolidUTF8(<var>text</var>, <var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#renderSolidUTF8" -->
<dd>
<p>This method will render the given <var>text</var> with the given font with
(<var>r</var>, [g], <var>b</var>)
color onto a new surface. The Solid mode is used and this is the fastest.
This method returns new <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">surface</a> object.</p>
<p>This method create an 8-bit palettized
surface and render the given text at fast quality
with the given font and color. The 0 pixel value is the colorkey, giving a
transparent background, and the 1 pixel value is set to the text color. The
colormap is set to have the desired foreground color at index 1, this allows
you to change the color without having to render the text again. Colormap
index 0 is of course not drawn, since it is the colorkey, and thus
transparent, though it's actual color is 255 minus each RGB component of the
foreground. This is the fastest rendering speed of all the rendering modes.
This results in no box around the text, but the text is not as smooth. The
resulting surface should blit faster than
the <var>Blended|TTF#render_blended_utf8</var> one. Use this mode for
FPS and other fast changing updating text displays.</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-578">SDL::TTF#render_shaded_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-580">SDL::TTF#render_blended_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-582">SDL::TTF#draw_solid_utf8</a></p></li>
</ul></dd>
<dt><a name="label-578" id="label-578"><code>SDL::TTF#render_shaded_utf8(<var>text</var>,<var>fg_r</var>,<var>fg_g</var>,<var>fg_b</var>,<var>bg_r</var>,<var>bg_g</var>,<var>bg_b</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#render_shaded_utf8" -->
<dt><a name="label-579" id="label-579"><code>SDL::TTF#renderShadedUTF8(<var>text</var>,<var>fg_r</var>,<var>fg_g</var>,<var>fg_b</var>,<var>bg_r</var>,<var>bg_g</var>,<var>bg_b</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#renderShadedUTF8" -->
<dd>
<p>This method will render the given <var>text</var> with the given font with
(<var>fg_r</var>, [fg_g], <var>fg_b</var>) color onto a new surface
with background color (<var>bg_r</var>, [bg_g], <var>bg_b</var>).
Returns new <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">surface</a> object.</p>
<p>This method create an 8-bit palettized
surface and render the given text at high quality
with the given font and colors. The 0 pixel value is background, while other
pixels have varying degrees of the foreground color from the background color.
This results in a box of the background color around the text in the
foreground color. The text is antialiased.
This will render slower than <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-576">Solid</a>,
but in about the same time as <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-580">SDL::TTF#render_blended_utf8</a>.
The resulting surface should blit
as fast as <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-576">Solid</a>, once it is made.
Use this when you need nice text, and can
live with a box...</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-576">SDL::TTF#render_solid_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-580">SDL::TTF#render_blended_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-584">SDL::TTF#draw_shaded_utf8</a></p></li>
</ul></dd>
<dt><a name="label-580" id="label-580"><code>SDL::TTF#render_blended_utf8(<var>text</var>, <var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#render_blended_utf8" -->
<dt><a name="label-581" id="label-581"><code>SDL::TTF#render_blended_utf8(<var>text</var>, <var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#render_blended_utf8" -->
<dd>
<p>This method will render the given <var>text</var> with the given font with (<var>r</var>, [g], <var>b</var>)
color onto a new surface with transparent background. This is
the slowest but most beautiful.</p>
<p>This method creates a 32-bit ARGB surface and
render the given text at high quality, using
alpha blending to dither the font with the given color. This results in a
surface with alpha transparency, so you don't have a solid colored box around
the text. The text is antialiased.
This will render slower than <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-576">SDL::TTF#render_solid_utf8</a>, but in
about the same time as <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-578">SDL::TTF#render_shaded_utf8</a>.
The resulting surface will blit slower
than if you had used <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-576">SDL::TTF#render_solid_utf8</a> and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-578">SDL::TTF#render_shaded_utf8</a>.
Use this when you want high quality, and the text isn't changing too fast.</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-576">SDL::TTF#render_solid_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-578">SDL::TTF#render_shaded_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-586">SDL::TTF#draw_blended_utf8</a></p></li>
</ul></dd>
<dt><a name="label-582" id="label-582"><code>SDL::TTF#draw_solid_utf8(<var>dest</var>, <var>text</var>, <var>x</var>, <var>y</var>, <var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#draw_solid_utf8" -->
<dt><a name="label-583" id="label-583"><code>SDL::TTF#drawSolidUTF8(<var>dest</var>, <var>text</var>, <var>x</var>, <var>y</var>, <var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#drawSolidUTF8" -->
<dd>
<p>This method will draw the given <var>text</var>
with the given font with (<var>r</var>, [g], <var>b</var>)
onto <var>dest</var> <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">surface</a> at (<var>x</var>, <var>y</var>)
in <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-576">solid</a> mode.</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-584">SDL::TTF#draw_shaded_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-586">SDL::TTF#draw_blended_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-576">SDL::TTF#render_solid_utf8</a></p></li>
</ul></dd>
<dt><a name="label-584" id="label-584"><code>SDL::TTF#draw_shaded_utf8(<var>dest</var>, <var>text</var>, <var>x</var>, <var>y</var>, <var>fg_r</var>, <var>fg_g</var>, <var>fg_b</var>, <var>bg_r</var>, <var>bg_g</var>, <var>bg_b</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#draw_shaded_utf8" -->
<dt><a name="label-585" id="label-585"><code>SDL::TTF#drawShadedUTF8(<var>dest</var>, <var>text</var>, <var>x</var>, <var>y</var>, <var>fg_r</var>, <var>fg_g</var>, <var>fg_b</var>, <var>bg_r</var>, <var>bg_g</var>, <var>bg_b</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#drawShadedUTF8" -->
<dd>
<p>This method will draw the given <var>text</var>
with the given font with (<var>fg_r</var>, [fg_g], <var>fg_b</var>)
color onto onto <var>dest</var> <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">surface</a> at (<var>x</var>, <var>y</var>)
with background color (<var>bg_r</var>, [bg_g], <var>bg_b</var>)
in <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-578">shaded</a> mode.</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-582">SDL::TTF#draw_solid_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-586">SDL::TTF#draw_blended_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-578">SDL::TTF#render_shaded_utf8</a></p></li>
</ul></dd>
<dt><a name="label-586" id="label-586"><code>SDL::TTF#draw_blended_utf8(<var>dest</var>, <var>text</var>, <var>x</var>, <var>y</var>, <var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#draw_blended_utf8" -->
<dt><a name="label-587" id="label-587"><code>SDL::TTF#drawBlendedUTF8(<var>dest</var>, <var>text</var>, <var>x</var>, <var>y</var>, <var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::TTF#drawBlendedUTF8" -->
<dd>
<p>This method will draw the given <var>text</var>
with the given font with (<var>r</var>, [g], <var>b</var>)
onto <var>dest</var> <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">surface</a> at (<var>x</var>, <var>y</var>)
in <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-580">blended</a> mode.</p>
<p>You need SDL_ttf to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-582">SDL::TTF#draw_solid_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-584">SDL::TTF#draw_shaded_utf8</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-580">SDL::TTF#render_blended_utf8</a></p></li>
</ul></dd>
<dt><a name="label-588" id="label-588"><code>SDL::BMFont.open(<var>filename</var>, <var>flags</var>)</code></a></dt><!-- RDLabel: "SDL::BMFont.open" -->
<dd>
<p>Load a bitmap font from <var>filename</var> file and
returns new <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-554">SDL::BMFont</a> object.</p>
<p><var>flags</var> is OR'd combination of following values:</p>
<dl>
<dt><a name="label-589" id="label-589">SDL::BMFont::TRANSPARENT</a></dt><!-- RDLabel: "SDL::BMFont::TRANSPARENT" -->
<dd>
Transparent (use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-127">SDL::Surface#set_color_key</a> internally, should usually be set)
</dd>
<dt><a name="label-590" id="label-590">SDL::BMFont::NOCONVERT</a></dt><!-- RDLabel: "SDL::BMFont::NOCONVERT" -->
<dd>
Don't <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-145">convert font surface to display format</a>
for faster blits.
</dd>
<dt><a name="label-591" id="label-591">SDL::BMFont::SFONT</a></dt><!-- RDLabel: "SDL::BMFont::SFONT" -->
<dd>
If you enabled support for SDL_img when compiling
SGE you can also set this flag, this enables you to
load Karl Bartel's SFont files.
</dd>
<dt><a name="label-592" id="label-592">SDL::BMFont::PALETTE</a></dt><!-- RDLabel: "SDL::BMFont::PALETTE" -->
<dd>
Converts the font surface to a palette surface
(8bit). Don't do this on color fonts or SFonts! Blits from the
font surface will be a bit slower but <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-595">SDL::BMFont#set_color</a>
will be faster (O(1) instead of O(n^2)).
</dd>
</dl>
<p>You need SGE to use this method.</p></dd>
<dt><a name="label-593" id="label-593"><code>SDL::BMFont#close</code></a></dt><!-- RDLabel: "SDL::BMFont#close" -->
<dd>
<p>Closes a font and release the resources.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-588">SDL::BMFont.open</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-594">SDL::BMFont#closed?</a></p></li>
</ul></dd>
<dt><a name="label-594" id="label-594"><code>SDL::BMFont#closed?</code></a></dt><!-- RDLabel: "SDL::BMFont#closed?" -->
<dd>
<p>Returns whether a font is closed by <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-593">SDL::BMFont#close</a>.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-593">SDL::BMFont#close</a></p></li>
</ul></dd>
<dt><a name="label-595" id="label-595"><code>SDL::BMFont#set_color(<var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::BMFont#set_color" -->
<dt><a name="label-596" id="label-596"><code>SDL::BMFont#setColor(<var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::BMFont#setColor" -->
<dd>
<p>Changes the color of the font to (<var>r</var>, <var>g</var>, <var>b</var>). 
Doesn't work on 'color
fonts' or SFonts. Use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-592">SDL::BMFont::PALETTE</a>
when <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-588">opening</a> the font if
you're going to use this function often.</p>
<p>You need SGE to use this method.</p></dd>
<dt><a name="label-597" id="label-597"><code>SDL::BMFont#height</code></a></dt><!-- RDLabel: "SDL::BMFont#height" -->
<dd>
<p>Returns height.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-598">SDL::BMFont#width</a></p></li>
</ul></dd>
<dt><a name="label-598" id="label-598"><code>SDL::BMFont#width</code></a></dt><!-- RDLabel: "SDL::BMFont#width" -->
<dd>
<p>Returns the width of one character in <var>self</var> font.
Doesn't work on SFonts.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-597">SDL::BMFont#height</a></p></li>
</ul></dd>
<dt><a name="label-599" id="label-599"><code>SDL::BMFont#text_size(<var>string</var>)</code></a></dt><!-- RDLabel: "SDL::BMFont#text_size" -->
<dt><a name="label-600" id="label-600"><code>SDL::BMFont#textSize(<var>string</var>)</code></a></dt><!-- RDLabel: "SDL::BMFont#textSize" -->
<dd>
<p>Returns the width and height of the <var>string</var> with <var>self</var>.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-601">SDL::BMFont#textout</a></p></li>
</ul></dd>
<dt><a name="label-601" id="label-601"><code>SDL::BMFont#textout(<var>surface</var>, <var>string</var>, <var>x</var>, <var>y</var>)</code></a></dt><!-- RDLabel: "SDL::BMFont#textout" -->
<dd>
<p>Renders the given <var>string</var> on surface with the given font. 
(<var>x</var>, <var>y</var>) is the position of the left top corner. </p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-599">SDL::BMFont#text_size</a></p></li>
</ul></dd>
<dt><a name="label-602" id="label-602"><code>SDL::Kanji.open(<var>filename</var>, <var>size</var>)</code></a></dt><!-- RDLabel: "SDL::Kanji.open" -->
<dd>
Load bdf font data from <var>filename</var> and 
returns new <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-555">SDL::Kanji</a> obejct.
<var>size</var> is the height of one character.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-605">SDL::Kanji#add</a></p></li>
</ul></dd>
<dt><a name="label-603" id="label-603"><code>SDL::Kanji#close</code></a></dt><!-- RDLabel: "SDL::Kanji#close" -->
<dd>
Closes bdf font data and release
the resouces and memories.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-602">SDL::Kanji.open</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-604">SDL::Kanji#closed?</a></p></li>
</ul></dd>
<dt><a name="label-604" id="label-604"><code>SDL::Kanji#closed?</code></a></dt><!-- RDLabel: "SDL::Kanji#closed?" -->
<dd>
Returns whether bdf font is closed by <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-603">SDL::Kanji#close</a>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-603">SDL::Kanji#close</a></p></li>
</ul></dd>
<dt><a name="label-605" id="label-605"><code>SDL::Kanji#add(<var>filename</var>)</code></a></dt><!-- RDLabel: "SDL::Kanji#add" -->
<dd>
Add font data fromt <var>filename</var> into already loaded font <var>self</var>.
This method combines two or more font files into one.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-602">SDL::Kanji.open</a></p></li>
</ul></dd>
<dt><a name="label-606" id="label-606"><code>SDL::Kanji#set_coding_system(<var>sys</var>)</code></a></dt><!-- RDLabel: "SDL::Kanji#set_coding_system" -->
<dt><a name="label-607" id="label-607"><code>SDL::Kanji#setCodingSystem(<var>sys</var>)</code></a></dt><!-- RDLabel: "SDL::Kanji#setCodingSystem" -->
<dd>
<p>Set encoding. <var>sys</var> is one of following:</p>
<ul>
<li>SDL::Kanji::SJIS</li>
<li>SDL::Kanji::EUC</li>
<li>SDL::Kanji::JIS</li>
</ul>
<p>Default is SDL::Kanji::JIS.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-608">SDL::Kanji#get_coding_system</a></p></li>
</ul></dd>
<dt><a name="label-608" id="label-608"><code>SDL::Kanji#get_coding_system</code></a></dt><!-- RDLabel: "SDL::Kanji#get_coding_system" -->
<dt><a name="label-609" id="label-609"><code>SDL::Kanji#getCodingSystem</code></a></dt><!-- RDLabel: "SDL::Kanji#getCodingSystem" -->
<dd>
<p>Get encoding. A return value is one of following:</p>
<ul>
<li>SDL::Kanji::SJIS</li>
<li>SDL::Kanji::EUC</li>
<li>SDL::Kanji::JIS</li>
</ul>
<p>Default is SDL::Kanji::JIS.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-606">SDL::Kanji#set_coding_system</a></p></li>
</ul></dd>
<dt><a name="label-610" id="label-610"><code>SDL::Kanji#height</code></a></dt><!-- RDLabel: "SDL::Kanji#height" -->
<dd>
Returns the height of one character as piexel.</dd>
<dt><a name="label-611" id="label-611"><code>SDL::Kanji#textwidth(<var>text</var>)</code></a></dt><!-- RDLabel: "SDL::Kanji#textwidth" -->
<dd>
Get width of given <var>text</var> with <var>self</var> font.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-612">SDL::Kanji#width</a></p></li>
</ul></dd>
<dt><a name="label-612" id="label-612"><code>SDL::Kanji#width</code></a></dt><!-- RDLabel: "SDL::Kanji#width" -->
<dd>
Returns the width of one character.
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-611">SDL::Kanji#textwidth</a></p></li>
</ul></dd>
<dt><a name="label-613" id="label-613"><code>SDL::Kanji#put(<var>surface</var>, <var>text</var>, <var>x</var>, <var>y</var>, <var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::Kanji#put" -->
<dd>
Renders <var>text</var> at (<var>x</var>, <var>y</var>) in <var>surface</var>
with (<var>r</var>, <var>g</var>, <var>b</var>) color.
<ul>
<li><p>NOTES</p>
<p>If Ruby/SDL m17n support is enabled, <var>text</var> 
will be converted to suitable encoding.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-614">SDL::Kanji#put_tate</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-606">SDL::Kanji#set_coding_system</a></p></li>
</ul></dd>
<dt><a name="label-614" id="label-614"><code>SDL::Kanji#put_tate(<var>surface</var>, <var>x</var>, <var>y</var>, <var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::Kanji#put_tate" -->
<dt><a name="label-615" id="label-615"><code>SDL::Kanji#putTate(<var>surface</var>, <var>x</var>, <var>y</var>, <var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::Kanji#putTate" -->
<dd>
<p>Renders <var>text</var> as tagetaki at (<var>x</var>, <var>y</var>) in <var>surface</var>
with (<var>r</var>, <var>g</var>, <var>b</var>) color.</p>
<p>`Half-width' character is not rendered.</p>
<ul>
<li><p>NOTES</p>
<p>If Ruby/SDL m17n support is enabled, <var>text</var> 
will be converted to suitable encoding.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-613">SDL::Kanji#put</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-606">SDL::Kanji#set_coding_system</a></p></li>
</ul></dd>
</dl>
<h1><a name="label-616" id="label-616">Collision Detection</a></h1><!-- RDLabel: "Collision Detection" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-617">Collision Detection outline</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-618">SDL::CollisionMap</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-619">Collision Detection Methods</a>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-620">SDL::Surface#make_collision_map</a> -- Creates a new collision map</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-622">SDL::CollisionMap#collision_check</a> -- Does pixel collision detection.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-623">SDL::CollisionMap.bounding_box_check</a> -- Checks if two shapes overlap.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-625">SDL::CollisionMap#bounding_box_check</a> -- Checks if two shapes overlap.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-627">SDL::CollisionMap#clear</a> -- Clears an area in the collision map</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-628">SDL::CollisionMap#set</a> -- Makes an area in the collision map solid</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-629">SDL::CollisionMap#w</a> -- Gets width of collision map</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-630">SDL::CollisionMap#h</a> -- Get height of collision map</li>
</ul></li>
</ul>
<h2><a name="label-617" id="label-617">Collision Detection outline</a></h2><!-- RDLabel: "Collision Detection outline" -->
<p>Ruby/SDL has collision detection system
derived from 
<a href="http://www.etek.chalmers.se/~e8cal1/sge/index.html">SGE</a>.
This enables you to pixel-pixel checking after
creating binary image by  <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-620">SDL::Surface#make_collision_map</a>.</p>
<p>Please see sample/collision.rb too.</p>
<h2><a name="label-618" id="label-618">SDL::CollisionMap</a></h2><!-- RDLabel: "SDL::CollisionMap" -->
<p>This class represents binary image used by collision 
detections.
You can create this instance only by 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-620">SDL::Surface#make_collision_map</a>.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-622">SDL::CollisionMap#collision_check</a> -- Does pixel collision detection.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-623">SDL::CollisionMap.bounding_box_check</a> -- Checks if two shapes overlap.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-625">SDL::CollisionMap#bounding_box_check</a> -- Checks if two shapes overlap.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-627">SDL::CollisionMap#clear</a> -- Clears an area in the collision map</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-628">SDL::CollisionMap#set</a> -- Makes an area in the collision map solid</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-629">SDL::CollisionMap#w</a> -- Gets width of collision map</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-630">SDL::CollisionMap#h</a> -- Get height of collision map</li>
</ul>
<h2><a name="label-619" id="label-619">Collision Detection Methods</a></h2><!-- RDLabel: "Collision Detection Methods" -->
<dl>
<dt><a name="label-620" id="label-620"><code>SDL::Surface#make_collision_map</code></a></dt><!-- RDLabel: "SDL::Surface#make_collision_map" -->
<dt><a name="label-621" id="label-621"><code>SDL::Surface#makeCollisionMap</code></a></dt><!-- RDLabel: "SDL::Surface#makeCollisionMap" -->
<dd>
<p>Creates a new collision map from <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a> object.
Use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-127">SDL::Surface#set_color_key</a> before calling this method.
Every non-transparent pixel is set to
solid in the collision map. </p>
<p>Returns a new <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-618">SDL::CollisionMap</a> object.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-127">SDL::Surface#set_color_key</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-622">SDL::CollisionMap#collision_check</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-627">SDL::CollisionMap#clear</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-628">SDL::CollisionMap#set</a></p></li>
</ul></dd>
<dt><a name="label-622" id="label-622"><code>SDL::CollisionMap#collision_check(<var>x1</var>, <var>y1</var>, <var>cmap</var>, <var>x2</var>, <var>y2</var>)</code></a></dt><!-- RDLabel: "SDL::CollisionMap#collision_check" -->
<dd>
<p>Does pixel perfect collision detection with 
<var>self</var> and <var>cmap</var>. 
The (<var>x1</var>,<var>y1</var>) and (<var>x2</var>,<var>y2</var>)
coords are the positions of the upper left corners of the
images. Returns true if any solid
pixels of the two images overlap or else false.</p>
<p>This method calls <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-625">SDL::CollisionMap#bounding_box_check</a> 
internally.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-625">SDL::CollisionMap#bounding_box_check</a></p></li>
</ul></dd>
<dt><a name="label-623" id="label-623"><code>SDL::CollisionMap.bounding_box_check(<var>x1</var>,<var>y1</var>,<var>w1</var>,<var>h1</var>,<var>x2</var>,<var>y2</var>,<var>w2</var>,<var>h2</var>)</code></a></dt><!-- RDLabel: "SDL::CollisionMap.bounding_box_check" -->
<dt><a name="label-624" id="label-624"><code>SDL::CollisionMap.boundingBoxCheck(<var>x1</var>,<var>y1</var>,<var>w1</var>,<var>h1</var>,<var>x2</var>,<var>y2</var>,<var>w2</var>,<var>h2</var>)</code></a></dt><!-- RDLabel: "SDL::CollisionMap.boundingBoxCheck" -->
<dd>
<p>Checks if two rectangles 
(<var>x1</var>, <var>$y1</var>, <var>w1</var>, <var>h1</var>) and
(<var>x2</var>, <var>$y2</var>, <var>w2</var>, <var>h2</var>) overlap.</p>
<p>Returns true if two rectangles overlap, otherwise
returns false.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-625">SDL::CollisionMap#bounding_box_check</a></p></li>
</ul></dd>
<dt><a name="label-625" id="label-625"><code>SDL::CollisionMap#bounding_box_check(<var>x1</var>, <var>y1</var>, <var>cmap</var>, <var>x2</var>, <var>y2</var>)</code></a></dt><!-- RDLabel: "SDL::CollisionMap#bounding_box_check" -->
<dt><a name="label-626" id="label-626"><code>SDL::CollisionMap#boundingBoxCheck(<var>x1</var>, <var>y1</var>, <var>cmap</var>, <var>x2</var>, <var>y2</var>)</code></a></dt><!-- RDLabel: "SDL::CollisionMap#boundingBoxCheck" -->
<dd>
<p>Checks if two rectangles 
(the bounding boxes, <var>self</var> and <var>cmap</var>) overlap. 
The (<var>x1</var>,<var>y1</var>) and (<var>x2</var>,<var>y2</var>)
coords are the positions of the upper left corners of the
images.</p>
<p>Returns true if two rectangles overlap, otherwise
returns false.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-623">SDL::CollisionMap.bounding_box_check</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-622">SDL::CollisionMap#collision_check</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-629">SDL::CollisionMap#w</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-630">SDL::CollisionMap#h</a></p></li>
</ul></dd>
<dt><a name="label-627" id="label-627"><code>SDL::CollisionMap#clear(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</code></a></dt><!-- RDLabel: "SDL::CollisionMap#clear" -->
<dd>
<p>Clears an area in the collision map from anything solid.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-628">SDL::CollisionMap#set</a></p></li>
</ul></dd>
<dt><a name="label-628" id="label-628"><code>SDL::CollisionMap#set(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</code></a></dt><!-- RDLabel: "SDL::CollisionMap#set" -->
<dd>
<p>Makes an area in the collision map solid.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-628">SDL::CollisionMap#set</a></p></li>
</ul></dd>
<dt><a name="label-629" id="label-629"><code>SDL::CollisionMap#w</code></a></dt><!-- RDLabel: "SDL::CollisionMap#w" -->
<dd>
<p>Returns width of collision map.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-630">SDL::CollisionMap#h</a></p></li>
</ul></dd>
<dt><a name="label-630" id="label-630"><code>SDL::CollisionMap#h</code></a></dt><!-- RDLabel: "SDL::CollisionMap#h" -->
<dd>
<p>Returns height of collision map.</p>
<p>You need SGE to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-629">SDL::CollisionMap#w</a></p></li>
</ul></dd>
</dl>
<h1><a name="label-631" id="label-631">SDLSKK</a></h1><!-- RDLabel: "SDLSKK" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-632">Japanese input system by SDLSKK</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-634">SDL::SKK::Context</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-635">SDL::SKK::Dictionary</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-636">SDL::SKK::Keybind</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-637">SDL::SKK::RomKanaRuleTable</a></li>
<li>SDLSKK methods
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-639">SDL::SKK.encoding=</a> -- Set SDLSKK internal encoding</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-640">SDL::SKK.encoding</a> -- Get SDLSKK internal encoding</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-641">SDL::SKK::RomKanaRuleTable.new</a> -- Load a Romaji-Kana trasnlation table</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-642">SDL::SKK::Dictionary.new</a> -- Create empty dictionary</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-643">SDL::SKK::Dictionary#load</a> -- Read a dictionary file</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-644">SDL::SKK::Dictionary#save</a> -- Save user dictionary data</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-645">SDL::SKK::Keybind.new</a> -- Create empty keybind</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-646">SDL::SKK::Keybind#set_key</a> -- Set keybind</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-647">SDL::SKK::Keybind#set_default_key</a> -- Load default Emacs-like keybinds</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-648">SDL::SKK::Keybind#unset_key</a> -- Unset keybind</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-649">SDL::SKK::Context.new</a> -- Create new input context</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-650">SDL::SKK::Context#input</a> -- Handle keyboard event</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-651">SDL::SKK::Context#str</a> -- Get input string</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-652">SDL::SKK::Context#render_str</a> -- Render input string</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-653">SDL::SKK::Context#render_minibuffer_str</a> -- Render minibuffer string</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-654">SDL::SKK::Context#clear</a> -- Clear context</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-655">SDL::SKK::Context#clear_text</a> -- Creat input text</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-656">SDL::SKK::Context#get_basic_mode</a> -- Get whether input mode is basic mode</li>
</ul></li>
</ul>
<h2><a name="label-632" id="label-632">Japanese input system by SDLSKK</a></h2><!-- RDLabel: "Japanese input system by SDLSKK" -->
<p>Ruby/SDL has 
<a href="http://openlab.jp/skk/index-j.html">SKK</a>-like
Japanese input system by 
<a href="http://www.kmc.gr.jp/~ohai/sdlskk.html">SDLSKK</a>.</p>
<p>This system enables you not only to input Japanse
but also to handle line input including 
cut and paste.</p>
<p>Please see sample/sdlskk.rb.</p>
<h2><a name="label-633" id="label-633">SDL::SKK</a></h2><!-- RDLabel: "SDL::SKK" -->
<p>This module has some SDLSKK-related module functions
and classes.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-639">SDL::SKK.encoding=</a> -- Set SDLSKK internal encoding</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-640">SDL::SKK.encoding</a> -- Get SDLSKK internal encoding</li>
</ul>
<h2><a name="label-634" id="label-634">SDL::SKK::Context</a></h2><!-- RDLabel: "SDL::SKK::Context" -->
<p>This class represents input state.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-649">SDL::SKK::Context.new</a> -- Create new input context</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-650">SDL::SKK::Context#input</a> -- Handle keyboard event</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-651">SDL::SKK::Context#str</a> -- Get input string</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-652">SDL::SKK::Context#render_str</a> -- Render input string</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-653">SDL::SKK::Context#render_minibuffer_str</a> -- Render minibuffer string</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-654">SDL::SKK::Context#clear</a> -- Clear context</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-655">SDL::SKK::Context#clear_text</a> -- Creat input text</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-656">SDL::SKK::Context#get_basic_mode</a> -- Get whether input mode is basic mode</li>
</ul>
<h2><a name="label-635" id="label-635">SDL::SKK::Dictionary</a></h2><!-- RDLabel: "SDL::SKK::Dictionary" -->
<p>This class represents a Kana-Kanji dictionary.
Load SKK dictionary from files.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-642">SDL::SKK::Dictionary.new</a> -- Create empty dictionary</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-643">SDL::SKK::Dictionary#load</a> -- Read a dictionary file</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-644">SDL::SKK::Dictionary#save</a> -- Save user dictionary data</li>
</ul>
<h2><a name="label-636" id="label-636">SDL::SKK::Keybind</a></h2><!-- RDLabel: "SDL::SKK::Keybind" -->
<p>This class represents keybind.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-645">SDL::SKK::Keybind.new</a> -- Create empty keybind</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-646">SDL::SKK::Keybind#set_key</a> -- Set keybind</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-647">SDL::SKK::Keybind#set_default_key</a> -- Load default Emacs-like keybinds</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-648">SDL::SKK::Keybind#unset_key</a> -- Unset keybind</li>
</ul>
<h2><a name="label-637" id="label-637">SDL::SKK::RomKanaRuleTable</a></h2><!-- RDLabel: "SDL::SKK::RomKanaRuleTable" -->
<p>This class represents the translation table
from Romaji(Alphabet) to Kana.
Load text data from a file and create new table object.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-641">SDL::SKK::RomKanaRuleTable.new</a> -- Load a Romaji-Kana trasnlation table</li>
</ul>
<h2><a name="label-638" id="label-638">SDLSKK methods</a></h2><!-- RDLabel: "SDLSKK methods" -->
<dl>
<dt><a name="label-639" id="label-639"><code>SDL::SKK.encoding=(<var>encoding</var>)</code></a></dt><!-- RDLabel: "SDL::SKK.encoding=" -->
<dd>
<p>Sets SDLSKKK internal encoding to <var>encoding</var>.
Following constants are allowed:</p>
<ul>
<li>SDL::SKK::EUCJP</li>
<li>SDL::SKK::UTF8</li>
<li>SDL::SKK::SJIS</li>
</ul>
<p>Default is SDL::SKK::EUCJP.</p>
<p>This encoding determines 
the encoding of <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-643">dictionary files</a>,
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-641">a romaji-kana translation table file</a>
and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-644">private dictionary</a>.</p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>NOTES</p>
<p>This function should call once before calling other
SDLSKK methods.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-640">SDL::SKK.encoding</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-643">SDL::SKK::Dictionary#load</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-644">SDL::SKK::Dictionary#save</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-641">SDL::SKK::RomKanaRuleTable.new</a></p></li>
</ul></dd>
<dt><a name="label-640" id="label-640"><code>SDL::SKK.encoding</code></a></dt><!-- RDLabel: "SDL::SKK.encoding" -->
<dd>
<p>Returns the SDLSKK internal encoding. Please see
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-639">SDL::SKK.encoding=</a> for more detail.</p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-639">SDL::SKK.encoding=</a></p></li>
</ul></dd>
<dt><a name="label-641" id="label-641"><code>SDL::SKK::RomKanaRuleTable.new(<var>filename</var>)</code></a></dt><!-- RDLabel: "SDL::SKK::RomKanaRuleTable.new" -->
<dd>
<p>Load a Romaji-Kana trasnlation table from <var>filename</var>.
File format is:</p>
<ul>
<li>a line beginnig with ;; is comment</li>
<li>empty line is ignored</li>
<li>one entry per one line: &lt;input alphabets&gt;&lt;TAB&gt;&lt;Katakana&gt;&lt;TAB&gt;&lt;Hiragana&gt;</li>
</ul>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>NOTES</p>
<p>Encoding of this file is set by <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-639">SDL::SKK.encoding=</a>
before loading it.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-649">SDL::SKK::Context.new</a></p></li>
</ul></dd>
<dt><a name="label-642" id="label-642"><code>SDL::SKK::Dictionary.new</code></a></dt><!-- RDLabel: "SDL::SKK::Dictionary.new" -->
<dd>
<p>Creates empty dictionary object and returns it.</p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-643">SDL::SKK::Dictionary#load</a></p></li>
</ul></dd>
<dt><a name="label-643" id="label-643"><code>SDL::SKK::Dictionary#load(<var>filename</var>, <var>user</var>)</code></a></dt><!-- RDLabel: "SDL::SKK::Dictionary#load" -->
<dd>
<p>Read a dictionary data from <var>filename</var>. 
Format of dictionary is same as of SKK
(Ruby/SDL cannot read data with annotations).
If <var>user</var> is true, loaded data is treated as
user dictionary data. If <var>user</var> is false,
loaded data is treated as system dictionary data.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>NOTES</p>
<p>Encoding of this file is set by <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-639">SDL::SKK.encoding=</a>
before loading it.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-642">SDL::SKK::Dictionary.new</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-644">SDL::SKK::Dictionary#save</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-649">SDL::SKK::Context.new</a></p></li>
</ul></dd>
<dt><a name="label-644" id="label-644"><code>SDL::SKK::Dictionary#save(<var>filename</var>)</code></a></dt><!-- RDLabel: "SDL::SKK::Dictionary#save" -->
<dd>
<p>Save user dictionary data into <var>filename</var>.</p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-642">SDL::SKK::Dictionary.new</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-643">SDL::SKK::Dictionary#load</a></p></li>
</ul></dd>
<dt><a name="label-645" id="label-645"><code>SDL::SKK::Keybind.new</code></a></dt><!-- RDLabel: "SDL::SKK::Keybind.new" -->
<dd>
<p>Creates empty keybind object and returns it.
Add keybind to this object using
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-646">SDL::SKK::Keybind#set_key</a> and <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-647">SDL::SKK::Keybind#set_default_key</a>.</p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-646">SDL::SKK::Keybind#set_key</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-647">SDL::SKK::Keybind#set_default_key</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-649">SDL::SKK::Context.new</a></p></li>
</ul></dd>
<dt><a name="label-646" id="label-646"><code>SDL::SKK::Keybind#set_key(<var>key_str</var>, <var>cmd_str</var>)</code></a></dt><!-- RDLabel: "SDL::SKK::Keybind#set_key" -->
<dd>
<p>Sets keybind. <var>key_str</var> is a key-symbol string.
<var>cmd_str</var> is command string.</p>
<p>Following strings are allowed as <var>key_str</var>:</p>
<ul>
<li>Alphabet and ascii characters like "%"</li>
<li>"SPC" "TAB" "DEL" "RET" "UP" "DOWN" "RIGHT" "LEFT" "INSERT" "HOME" "END"
      "PAGEUP" "PAGEDOWN" "F1" "F2" "F3" "F4" "F5" "F6" "F7" "F8" "F9" "F10"
      "F11" "F12" "F13" "F14" "F15" "HELP"</li>
<li>key with modifiers like "C-a" and "M-C-a"</li>
</ul>
<p>Following strings is allowed as <var>cmd_str</var>:</p>
<ul>
<li>"backward-char",</li>
<li>"forward-char",</li>
<li>"backward-delete-char",</li>
<li>"delete-char",</li>
<li>"kakutei",</li>
<li>"kettei",</li>
<li>"space",</li>
<li>"keyboard-quit",</li>
<li>"set-mark-command",</li>
<li>"kill-region",</li>
<li>"yank",</li>
<li>"copy",</li>
<li>"graph-char",</li>
<li>"upper-char",</li>
<li>"lower-char",</li>
<li>"abbrev-input",</li>
<li>"latin-mode",</li>
<li>"previous-candidate",</li>
<li>"jisx0208-mode",</li>
<li>"toggle-kana",</li>
<li>"beginning-of-line"</li>
<li>"end-of-line"</li>
<li>"do-nothing"</li>
</ul>
<p>You shouldn't change the keybind of only one ascii character key
like "a" and "/".</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-647">SDL::SKK::Keybind#set_default_key</a> is useful.</p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-647">SDL::SKK::Keybind#set_default_key</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-648">SDL::SKK::Keybind#unset_key</a></p></li>
</ul></dd>
<dt><a name="label-647" id="label-647"><code>SDL::SKK::Keybind#set_default_key</code></a></dt><!-- RDLabel: "SDL::SKK::Keybind#set_default_key" -->
<dd>
<p>Load default Emacs-like keybinds.</p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-646">SDL::SKK::Keybind#set_key</a></p></li>
</ul></dd>
<dt><a name="label-648" id="label-648"><code>SDL::SKK::Keybind#unset_key(<var>key_str</var>)</code></a></dt><!-- RDLabel: "SDL::SKK::Keybind#unset_key" -->
<dd>
<p>Unset keybind of <var>key_str</var>.</p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-646">SDL::SKK::Keybind#set_key</a></p></li>
</ul></dd>
<dt><a name="label-649" id="label-649"><code>SDL::SKK::Context.new(<var>dict</var>, <var>romkama_table</var>, <var>bind</var>, <var>use_minibuffer</var>)</code></a></dt><!-- RDLabel: "SDL::SKK::Context.new" -->
<dd>
<p>Creates input context and returns new <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-634">SDL::SKK::Context</a> object.
<var>dict</var> is a <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-635">dictionary</a>,
<var>romkama_table</var> is a
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-637">Ronaji-Kana translation table</a>
and <var>bind</var> is <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-636">keybind</a>.
If <var>use_minibuffer</var> is true, 
SKK-like minibuffer is enabled.</p>
<p>You need SDLSKK to use this method.</p>
<p>EXAMPLE</p>
<pre># Create dictionary object and read data from 'jisyo'
dict = SDL::SKK::Dictionary.new
dict.load( 'jisyo', false )
# Read Romaji-Kana translation table from 'rule_table'
table = SDL::SKK::RomKanaRuleTable.new( 'rule_table' )
# Set keybind
bind = SDL::SKK::Keybind.new
bind.set_default_key

# Create context
context = SDL::SKK::Context.new( dict, table, bind, use_minibuffer )</pre>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-650">SDL::SKK::Context#input</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-651">SDL::SKK::Context#str</a></p></li>
</ul></dd>
<dt><a name="label-650" id="label-650"><code>SDL::SKK::Context#input(<var>event</var>)</code></a></dt><!-- RDLabel: "SDL::SKK::Context#input" -->
<dd>
<p>Handles keyboard event. <var>event</var> should be 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-301">SDL::Event</a> object.
This method handles only <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-304">keydown events</a>
and ignore other events.</p>
<p>You need SDLSKK to use this method.</p>
<p>EXAMPLE</p>
<pre>while event = SDL::Event.poll do
  case event
  when SDL::Event::Quit
    exit
  when SDL::Event::KeyDown
    if event.sym == SDL::Key::ESCAPE then
      exit
    end
    if event.sym == SDL::Key::F1
      dict.save("test_user_dict")
    end
    context.input( event )      
  end
end</pre></dd>
<dt><a name="label-651" id="label-651"><code>SDL::SKK::Context#str</code></a></dt><!-- RDLabel: "SDL::SKK::Context#str" -->
<dd>
<p>Returns input string.</p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>NOTES</p>
<p>If Ruby/SDL m17n support is enabled,
the string with proper encoding will be returned.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-652">SDL::SKK::Context#render_str</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-654">SDL::SKK::Context#clear</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-655">SDL::SKK::Context#clear_text</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-640">SDL::SKK.encoding</a></p></li>
</ul></dd>
<dt><a name="label-652" id="label-652"><code>SDL::SKK::Context#render_str(<var>font</var>, <var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::SKK::Context#render_str" -->
<dd>
<p>Renders input string and returns <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a> object.</p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-653">SDL::SKK::Context#render_minibuffer_str</a></p></li>
</ul></dd>
<dt><a name="label-653" id="label-653"><code>SDL::SKK::Context#render_minibuffer_str(<var>font</var>, <var>r</var>, <var>g</var>, <var>b</var>)</code></a></dt><!-- RDLabel: "SDL::SKK::Context#render_minibuffer_str" -->
<dd>
<p>Renders minibuffer string and returns <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a> object.</p>
<p>You need SDLSKK to use this method.</p></dd>
<dt><a name="label-654" id="label-654"><code>SDL::SKK::Context#clear</code></a></dt><!-- RDLabel: "SDL::SKK::Context#clear" -->
<dd>
<p>Clears input context.</p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-655">SDL::SKK::Context#clear_text</a></p></li>
</ul></dd>
<dt><a name="label-655" id="label-655"><code>SDL::SKK::Context#clear_text</code></a></dt><!-- RDLabel: "SDL::SKK::Context#clear_text" -->
<dd>
<p>Clears input text, but input mode is held.</p>
<p>If you want multi-line input, this method is better
than <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-654">SDL::SKK::Context#clear</a></p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-656">SDL::SKK::Context#get_basic_mode</a></p></li>
</ul></dd>
<dt><a name="label-656" id="label-656"><code>SDL::SKK::Context#get_basic_mode</code></a></dt><!-- RDLabel: "SDL::SKK::Context#get_basic_mode" -->
<dd>
<p>Returns true if <var>self</var>'s input mode is kakutei-mode,
latin-mode or jisx0208-latim-mode, otherwise returns
false.</p>
<p>You need SDLSKK to use this method.</p>
<ul>
<li><p>NOTES</p>
<p>Please see <a href="http://openlab.jp/skk/index.html">SKK</a>.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-655">SDL::SKK::Context#clear_text</a></p></li>
</ul></dd>
</dl>
<h1><a name="label-657" id="label-657">MPEG playback</a></h1><!-- RDLabel: "MPEG playback" -->
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-658">MPEG playback Outline</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-659">SDL::MPEG</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-660">SDL::MPEG::Info</a></li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-661">MPEG playback methods</a>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-662">SDL::MPEG.new</a> -- Load MPEG file.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-664">SDL::MPEG#info</a> -- Get information about MPEG object</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-665">SDL::MPEG#enable_audio</a> -- Enable/Dislable audio</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-667">SDL::MPEG#enable_video</a> -- Enable/Disable video</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-669">SDL::MPEG#status</a> -- Get current status</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-670">SDL::MPEG#set_volume</a> -- Change volume of MPEG stream</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-672">SDL::MPEG#set_display</a> -- Set display surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-674">SDL::MPEG#set_loop</a> -- Set/Clear looping play</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-676">SDL::MPEG#scale_xy</a> -- Scale pixel display</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-678">SDL::MPEG#scale</a> -- Scale pixel display</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-679">SDL::MPEG#move</a> -- Move the video display area</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-680">SDL::MPEG#set_display_region</a> -- Set the video display region</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-681">SDL::MPEG#play</a> -- Play an MPEG object</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-682">SDL::MPEG#stop</a> -- Stop playback of an MPEG object</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-683">SDL::MPEG#pause</a> -- Pause/Resume playback of an MPEG object</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-684">SDL::MPEG#rewind</a> -- Rewind the play position </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-685">SDL::MPEG#seek</a> -- Seek in the MPEG stream.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-686">SDL::MPEG#skip</a> -- Skip seconds in the MPEG stream</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-687">SDL::MPEG#render_frame</a> -- Render a particular frame in the MPEG video.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-688">SDL::MPEG#render_final</a> -- Render the last frame of an MPEG video</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-689">SDL::MPEG#set_filer</a> -- Set video filter</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-690">SDL::MPEG::Info#has_audio</a> -- Get whether an MPEG stream has audio data</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-691">SDL::MPEG::Info#has_video</a> -- Get whether an MPEG stream has video data</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-692">SDL::MPEG::Info#width</a> -- Get width of video</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-693">SDL::MPEG::Info#height</a> -- Get height of video</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-694">SDL::MPEG::Info#current_frame</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-695">SDL::MPEG::Info#current_fps</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-696">SDL::MPEG::Info#audio_string</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-697">SDL::MPEG::Info#audio_current_frame</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-698">SDL::MPEG::Info#current_offset</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-699">SDL::MPEG::Info#total_size</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-700">SDL::MPEG::Info#current_time</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-701">SDL::MPEG#total_time</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-702">SDL::MPEG#delete</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-703">SDL::MPEG#deleted?</a> -- </li>
</ul></li>
</ul>
<h2><a name="label-658" id="label-658">MPEG playback Outline</a></h2><!-- RDLabel: "MPEG playback Outline" -->
<p>Ruby/SDL enables you to play MPEG movie 
with <a href="http://www.icculus.org/smpeg">SMPEG</a>.</p>
<p>Before calling MPEG methods, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-7">SDL.init</a> should be called 
with SDL::INIT_AUDIO|SDL::INIT_VIDEO and 
<a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-475">SDL::Mixer.open</a> should be called.</p>
<p>MPEG playback system runs in sub thread(native thread).
Therefore you cannot read and write movie <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a> 
while playing. In addition you cannot use <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-471">SDL::Mixer</a> 
routines while playing if <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-665">audio is enabled</a>.
Ruby/SDL doesn't control such an invalid access.</p>
<h2><a name="label-659" id="label-659">SDL::MPEG</a></h2><!-- RDLabel: "SDL::MPEG" -->
<p>This class represents MPEG stream and playing state.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-662">SDL::MPEG.new</a> -- Load MPEG file.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-664">SDL::MPEG#info</a> -- Get information about MPEG object</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-665">SDL::MPEG#enable_audio</a> -- Enable/Dislable audio</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-667">SDL::MPEG#enable_video</a> -- Enable/Disable video</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-669">SDL::MPEG#status</a> -- Get current status</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-670">SDL::MPEG#set_volume</a> -- Change volume of MPEG stream</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-672">SDL::MPEG#set_display</a> -- Set display surface</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-674">SDL::MPEG#set_loop</a> -- Set/Clear looping play</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-676">SDL::MPEG#scale_xy</a> -- Scale pixel display</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-678">SDL::MPEG#scale</a> -- Scale pixel display</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-679">SDL::MPEG#move</a> -- Move the video display area</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-680">SDL::MPEG#set_display_region</a> -- Set the video display region</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-681">SDL::MPEG#play</a> -- Play an MPEG object</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-682">SDL::MPEG#stop</a> -- Stop playback of an MPEG object</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-683">SDL::MPEG#pause</a> -- Pause/Resume playback of an MPEG object</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-684">SDL::MPEG#rewind</a> -- Rewind the play position </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-685">SDL::MPEG#seek</a> -- Seek in the MPEG stream.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-686">SDL::MPEG#skip</a> -- Skip seconds in the MPEG stream</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-687">SDL::MPEG#render_frame</a> -- Render a particular frame in the MPEG video.</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-688">SDL::MPEG#render_final</a> -- Render the last frame of an MPEG video</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-689">SDL::MPEG#set_filer</a> -- Set video filter</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-701">SDL::MPEG#total_time</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-702">SDL::MPEG#delete</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-703">SDL::MPEG#deleted?</a> -- </li>
</ul>
<h2><a name="label-660" id="label-660">SDL::MPEG::Info</a></h2><!-- RDLabel: "SDL::MPEG::Info" -->
<p>This class represents <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-659">SDL::MPEG</a> information.
You can get instance by <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-664">SDL::MPEG#info</a>.</p>
<ul>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-690">SDL::MPEG::Info#has_audio</a> -- Get whether an MPEG stream has audio data</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-691">SDL::MPEG::Info#has_video</a> -- Get whether an MPEG stream has video data</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-692">SDL::MPEG::Info#width</a> -- Get width of video</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-693">SDL::MPEG::Info#height</a> -- Get height of video</li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-694">SDL::MPEG::Info#current_frame</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-695">SDL::MPEG::Info#current_fps</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-696">SDL::MPEG::Info#audio_string</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-697">SDL::MPEG::Info#audio_current_frame</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-698">SDL::MPEG::Info#current_offset</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-699">SDL::MPEG::Info#total_size</a> -- </li>
<li><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-700">SDL::MPEG::Info#current_time</a> -- </li>
</ul>
<h2><a name="label-661" id="label-661">MPEG playback methods</a></h2><!-- RDLabel: "MPEG playback methods" -->
<dl>
<dt><a name="label-662" id="label-662"><code>SDL::MPEG.new(<var>filename</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG.new" -->
<dt><a name="label-663" id="label-663"><code>SDL::MPEG.load(<var>filename</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG.load" -->
<dd>
<p>Loads a <var>filename</var> and returns 
new <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-659">SDL::MPEG</a> object.</p>
<p>Raises <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-3">SDL::Error</a> on failure</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-664">SDL::MPEG#info</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-681">SDL::MPEG#play</a></p></li>
</ul></dd>
<dt><a name="label-664" id="label-664"><code>SDL::MPEG#info</code></a></dt><!-- RDLabel: "SDL::MPEG#info" -->
<dd>
<p>Gets information about <var>self</var> as <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-660">SDL::MPEG::Info</a> object.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-660">SDL::MPEG::Info</a></p></li>
</ul></dd>
<dt><a name="label-665" id="label-665"><code>SDL::MPEG#enable_audio(<var>enable</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#enable_audio" -->
<dt><a name="label-666" id="label-666"><code>SDL::MPEG#enableAudio(<var>enable</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#enableAudio" -->
<dd>
<p>Enables or disables audio.
If <var>enable</var> is true, audio data is played, but if <var>enable</var>
is false, audio data is not played.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>NOTES</p>
<p>Audio enable/disable setting is reflected after
playing starts.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-667">SDL::MPEG#enable_video</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-664">SDL::MPEG#info</a></p></li>
</ul></dd>
<dt><a name="label-667" id="label-667"><code>SDL::MPEG#enable_video(<var>enable</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#enable_video" -->
<dt><a name="label-668" id="label-668"><code>SDL::MPEG#enableVideo(<var>enable</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#enableVideo" -->
<dd>
<p>Enables or disables audio.
If <var>enable</var> is true, movie data is played, but if <var>enable</var>
is false, movie data is not played.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-665">SDL::MPEG#enable_audio</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-664">SDL::MPEG#info</a></p></li>
</ul></dd>
<dt><a name="label-669" id="label-669"><code>SDL::MPEG#status</code></a></dt><!-- RDLabel: "SDL::MPEG#status" -->
<dd>
<p>Returns current status of <var>self</var> as follows:</p>
<ul>
<li>SDL::MEPG::ERROR - system has some errors</li>
<li>SDL::MPEG::STOPPED - movie is stopped</li>
<li>SDL::MPEG::PLAYING - movie is playing</li>
</ul>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-664">SDL::MPEG#info</a></p></li>
</ul></dd>
<dt><a name="label-670" id="label-670"><code>SDL::MPEG#set_volume(<var>volume</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#set_volume" -->
<dt><a name="label-671" id="label-671"><code>SDL::MPEG#setVolume(<var>volume</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#setVolume" -->
<dd>
<p>Set volume MPEG stream from 0 to 100.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>NOTES</p>
<p>You cannot get current volume.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-665">SDL::MPEG#enable_audio</a></p></li>
</ul></dd>
<dt><a name="label-672" id="label-672"><code>SDL::MPEG#set_display(<var>surface</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#set_display" -->
<dt><a name="label-673" id="label-673"><code>SDL::MPEG#setDisplay(<var>surface</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#setDisplay" -->
<dd>
<p>Sets the <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">surface</a> that the playing movie displays on.
Normally, the surface object returned by <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-58">SDL.set_video_mode</a>
is used as <var>surface</var>.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>NOTES</p>
<p>MPEG playback system call <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-72">SDL::Screen#update_rect</a> from 
a (native) sub thread.</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">SDL::Surface</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-681">SDL::MPEG#play</a></p></li>
</ul></dd>
<dt><a name="label-674" id="label-674"><code>SDL::MPEG#set_loop(<var>repeat</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#set_loop" -->
<dt><a name="label-675" id="label-675"><code>SDL::MPEG#setLoop(<var>repeat</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#setLoop" -->
<dd>
<p>Set or clear looping play on <var>self</var>.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-681">SDL::MPEG#play</a></p></li>
</ul></dd>
<dt><a name="label-676" id="label-676"><code>SDL::MPEG#scale_xy(<var>width</var>, <var>height</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#scale_xy" -->
<dt><a name="label-677" id="label-677"><code>SDL::MPEG#scaleXY(<var>width</var>, <var>height</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#scaleXY" -->
<dd>
<p>Set scale pixel display on <var>self</var>.
The Unit of <var>width</var> and <var>height</var> is pixel.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-678">SDL::MPEG#scale</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-680">SDL::MPEG#set_display_region</a></p></li>
</ul></dd>
<dt><a name="label-678" id="label-678"><code>SDL::MPEG#scale(<var>scale</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#scale" -->
<dd>
<p>Set scale display on <var>self</var>.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-676">SDL::MPEG#scale_xy</a></p></li>
</ul></dd>
<dt><a name="label-679" id="label-679"><code>SDL::MPEG#move(<var>x</var>, <var>y</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#move" -->
<dd>
<p>Moves the video display to (<var>x</var>, <var>y</var>) 
within the destination surface set by <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-672">SDL::MPEG#set_display</a>.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-672">SDL::MPEG#set_display</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-680">SDL::MPEG#set_display_region</a></p></li>
</ul></dd>
<dt><a name="label-680" id="label-680"><code>SDL::MPEG#set_display_region(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#set_display_region" -->
<dd>
<p>Set the region of the video to be shown at 
the rectangle of <var>x</var>, <var>y</var>, <var>w</var>, <var>h</var></p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-679">SDL::MPEG#move</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-676">SDL::MPEG#scale_xy</a></p></li>
</ul></dd>
<dt><a name="label-681" id="label-681"><code>SDL::MPEG#play</code></a></dt><!-- RDLabel: "SDL::MPEG#play" -->
<dd>
<p>Plays an MPEG object.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>NOTES</p>
<p>You don't have to access surface set by <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-672">SDL::MPEG#set_display</a>.
x</p></li>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-683">SDL::MPEG#pause</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-682">SDL::MPEG#stop</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-684">SDL::MPEG#rewind</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-685">SDL::MPEG#seek</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-686">SDL::MPEG#skip</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-687">SDL::MPEG#render_frame</a></p></li>
</ul></dd>
<dt><a name="label-682" id="label-682"><code>SDL::MPEG#stop</code></a></dt><!-- RDLabel: "SDL::MPEG#stop" -->
<dd>
<p>Stop play back of <var>self</var>.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-681">SDL::MPEG#play</a></p></li>
</ul></dd>
<dt><a name="label-683" id="label-683"><code>SDL::MPEG#pause</code></a></dt><!-- RDLabel: "SDL::MPEG#pause" -->
<dd>
<p>Pauses/Resumes playback of <var>self</var>.
Pauses playback if <var>self</var> is playing, and
Resume playback if paused.</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-684" id="label-684"><code>SDL::MPEG#rewind</code></a></dt><!-- RDLabel: "SDL::MPEG#rewind" -->
<dd>
<p>Rewinds the play position of <var>self</var>
to the beginning of the MPEG.</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-685" id="label-685"><code>SDL::MPEG#seek(<var>bytes</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#seek" -->
<dd>
<p>Seeks <var>bytes</var> <em>bytes</em> the play position of <var>self</var>.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-681">SDL::MPEG#play</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-686">SDL::MPEG#skip</a></p></li>
</ul></dd>
<dt><a name="label-686" id="label-686"><code>SDL::MPEG#skip(<var>seconds</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#skip" -->
<dd>
<p>Skips <var>seconds</var> seconds in <var>self</var> MPEG stream.
<var>seconds</var> can be Float or Integer.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-681">SDL::MPEG#play</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-685">SDL::MPEG#seek</a></p></li>
</ul></dd>
<dt><a name="label-687" id="label-687"><code>SDL::MPEG#render_frame(<var>framenum</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#render_frame" -->
<dd>
<p>Render the <var>framenum</var>-th frame in the surface set by
<!-- Reference, RDLabel "SDL::MEPG#set_display" doesn't exist --><em class="label-not-found">SDL::MEPG#set_display</em><!-- Reference end -->.</p>
<p>You need SMPEG to use this method.</p>
<ul>
<li><p>See Also</p>
<p><a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-688">SDL::MPEG#render_final</a>, <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-681">SDL::MPEG#play</a></p></li>
</ul></dd>
<dt><a name="label-688" id="label-688"><code>SDL::MPEG#render_final(<var>dst</var>, <var>x</var>, <var>y</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#render_final" -->
<dd>
<p>Render the last frame of <var>self</var> video 
at (<var>x</var>, <var>y</var>) in the <var>dst</var> <a href="http://www.kmc.gr.jp/~ohai/rubysdl_ref_2.en.html#label-20">surface</a>.</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-689" id="label-689"><code>SDL::MPEG#set_filer(<var>filter</var>)</code></a></dt><!-- RDLabel: "SDL::MPEG#set_filer" -->
<dd>
<p>Selects video filter from one of following:</p>
<ul>
<li>SDL::MPEG::NULL_FILTER no filter</li>
<li>SDL::MPEG::BILIEAR_FILTER bilinear filter</li>
<li>SDL::MPEG::DEBLOCKING_FILTER deblocking filter</li>
</ul>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-690" id="label-690"><code>SDL::MPEG::Info#has_audio</code></a></dt><!-- RDLabel: "SDL::MPEG::Info#has_audio" -->
<dd>
<p>Returns true if <var>self</var> MPEG stream has audio data,
otherwise returns false.</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-691" id="label-691"><code>SDL::MPEG::Info#has_video</code></a></dt><!-- RDLabel: "SDL::MPEG::Info#has_video" -->
<dd>
<p>Returns true if <var>self</var> MPEG stream has video data,
otherwise returns false.</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-692" id="label-692"><code>SDL::MPEG::Info#width</code></a></dt><!-- RDLabel: "SDL::MPEG::Info#width" -->
<dd>
<p>Returns the width of video as pixels.</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-693" id="label-693"><code>SDL::MPEG::Info#height</code></a></dt><!-- RDLabel: "SDL::MPEG::Info#height" -->
<dd>
<p>Returns the width of video as pixels.</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-694" id="label-694"><code>SDL::MPEG::Info#current_frame</code></a></dt><!-- RDLabel: "SDL::MPEG::Info#current_frame" -->
<dd>
<p>not documented yet</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-695" id="label-695"><code>SDL::MPEG::Info#current_fps</code></a></dt><!-- RDLabel: "SDL::MPEG::Info#current_fps" -->
<dd>
<p>not documented yet</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-696" id="label-696"><code>SDL::MPEG::Info#audio_string</code></a></dt><!-- RDLabel: "SDL::MPEG::Info#audio_string" -->
<dd>
<p>not documented yet</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-697" id="label-697"><code>SDL::MPEG::Info#audio_current_frame</code></a></dt><!-- RDLabel: "SDL::MPEG::Info#audio_current_frame" -->
<dd>
<p>not documented yet</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-698" id="label-698"><code>SDL::MPEG::Info#current_offset</code></a></dt><!-- RDLabel: "SDL::MPEG::Info#current_offset" -->
<dd>
<p>not documented yet</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-699" id="label-699"><code>SDL::MPEG::Info#total_size</code></a></dt><!-- RDLabel: "SDL::MPEG::Info#total_size" -->
<dd>
<p>not documented yet</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-700" id="label-700"><code>SDL::MPEG::Info#current_time</code></a></dt><!-- RDLabel: "SDL::MPEG::Info#current_time" -->
<dd>
<p>not documented yet</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-701" id="label-701"><code>SDL::MPEG#total_time</code></a></dt><!-- RDLabel: "SDL::MPEG#total_time" -->
<dd>
<p>not documented yet</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-702" id="label-702"><code>SDL::MPEG#delete</code></a></dt><!-- RDLabel: "SDL::MPEG#delete" -->
<dd>
<p>not documented yet</p>
<p>You need SMPEG to use this method.</p></dd>
<dt><a name="label-703" id="label-703"><code>SDL::MPEG#deleted?</code></a></dt><!-- RDLabel: "SDL::MPEG#deleted?" -->
<dd>
<p>not documented yet</p>
<p>You need SMPEG to use this method.</p></dd>
</dl>



</body></html>